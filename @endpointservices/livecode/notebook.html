<!doctype html>
<notebook theme="air">
  <title>Livecode a webserver in a browser</title>
  <script id="0" type="text/markdown">
    # *Livecode* a webserver *in a browser*

    [WEBcode.run](https://webcode.run) lets you create serverless endpoints within Observable notebooks, so you can implement webhooks, dashboard servers and webapps without leaving your browser. *The* defining feature of [WEBCode.run](https://webcode.run) over other serverless platforms is **livecoding**. Livecoding routes production traffic to your browser, so live traffic is served in realtime with the very latest code without a deploy step. **It transfers Observable's reactive development workflow to server side development**, and it allows **browser tools to debug, intercept and reply-to production traffic**. This is only possible because serverside and development are both browser based, and therefore can be swapped freely. 
  </script>
  <script id="1309" type="text/markdown">
    ## 10 second demo

    In this article we demo some interactive live coding examples around the theme of building a webserver. Livecoding can be shaped to leave an execution trace across cells. This trace is useful for inspecting the steps in the request processing, and furthermore, thanks to Observable hot-code reloading, can be used to develop incrementally based off the memoized data. 

    Here is what it looks like in practice when building a webhook integration. Live events from a WhatsApp cascade through the notebook. Code changes *are instantly applied* enabling a super tight feedback loop. That's right! Webhook development with a tight feedback loop!

    <video controls="controls" width="${Math.min(width, 640)}" height="400" loop name="Video Name">
      <source src="https://storage.googleapis.com/publicartifacts/blogimages/notebookwebhook.mov">
    </video>
  </script>
  <script id="1304" type="application/vnd.observable.javascript">
    toc("h2,h3")
  </script>
  <script id="676" type="text/markdown">
    ## Prerequisites: Observable Basics
    To reap the benefit of *livecoding*, you should understand [Observable]()'s non-linear reactive cells execution model. Firstly, Observable's runtime is framework around **normal javascript**, so you can do normal Javascript things. _Hell, you can store your crap in the global window if you want_. Secondly, the runtime organises a program into **named code cells**, which can read and emit values. Together cells Cells reevaluate primarily for two reasons, 1, if their inputs are dirty *or, 2, you change their code definition*.

    So when you code, only the dependant computational graph is recomputed. It's significantly less disruptive than a full restart. React developers might have experienced _Hot Module Reload (HMR)_ before, this is like that but more reliable as its baked into the runtime. 

    Non-linear, reactive execution is *so* ergonomic for development, that it deserves (and needs) support at runtime if it is to be reliable and intuitive. **Reactive hot code reload is simply a better way to program**.

  </script>
  <script id="697" type="text/markdown">
    ### Extended to Serverless

    WEBCode takes Observable's ergonomic reactive programming model, and extends it to serverless, so you can *develop* serverside code in an explorative way too. To get the full reactive programming experience, *your* browser session is put on critical path of the server when in **livecode** mode.

    In the notebook we will explore how to get the most out of **livecode**. But first, you will need the **webcode** dependency:
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    import { endpoint } from "@endpointservices/webcode"
  </script>
  <script id="101" type="text/markdown">
    ## Declarative Endpoints
  </script>
  <script id="103" type="text/markdown">
    WEBCode's API is declarative. You can simply declare an endpoint with `endpoint(<name>, <handler>, <options>)`. There is no deploy step, this is pure *infra-as-code*.

    **Endpoints will be instantaneously live on the internet**, if *livecode* is enabled, otherwise, if nobody is *livecoding*, the request will be handled by *the last **published** version of the notebook*. If the notebook has never been published, the endpoint will `404`.

    ‚ö†Ô∏è *livecoding* cannot run when the page is not in the foreground (upvote [issue](https://github.com/observablehq/feedback/issues/458) if you want this fixed)
  </script>
  <script id="59" type="application/vnd.observable.javascript" pinned="">
    exampleEndpoint = endpoint(
      /* endpoint name, must be unique per notebook */ "example",
      /* endpoint handler, written like an express handler https://expressjs.com/en/api.html#app */
      async (req, res) => {
        console.log(`Received request from '${req.query.name}'`, req);
        console.log("Writing to response", res);
        mutable handlerLog = mutable handlerLog.concat(req);
        debugger; // üëà triggers a breakpoint if DevTools is open
        res.send({
          msg: `Hi! ${req.query.name}`,
          time: Date.now()
        });
      },
      /* endpoint options */ {
        // For _this_ example, we turn on **public livecoding** in the options with `{livecode: 'public'}`
        // I production use you would only allow livecoding by a developer (the default).
        // Never combine secrets and *public* livecoding!
        // Any secrets bound to a *public* livecode endpoint will be exposed.
        // In contrast, default livecoding secrets are only exposed to the authenticated team members,
        // who presumably had access by other means anyway.
        livecode: "public",
        host // WEBCode is a federated compute technology, you can host it yourself on a custom domain
      }
    )
  </script>
  <script id="113" type="text/markdown">
    Our implementation does a *console.log* of the inbound [request](https://observablehq.com/@endpointservices/webcode-docs?collection=@endpointservices/webcode-run#request) payload, and sends an object to the [response](https://observablehq.com/@endpointservices/webcode-docs?collection=@endpointservices/webcode-run#response). The response is computed based on the value of an incoming HTTP URL parameter *name*.
  </script>
  <script id="122" type="text/markdown">
    ### Making a GET

    The following UI uses the *fetch* API client-side, to make a simple request to our endpoint. The URL of the endpoint is the *href* parameter of the endpoint.

    When public livecoding, the URL of the server contains the session ID, so the server knows which tunnel to route through. Public livecode endpoints are isolated between participants.
  </script>
  <script id="1151" type="application/vnd.observable.javascript">
    response || html``
  </script>
  <script id="71" type="application/vnd.observable.javascript">
    viewof name = Inputs.text({
      label: "name",
      placeholder: "Please enter your name (or don't)"
    })
  </script>
  <script id="67" type="application/vnd.observable.javascript" pinned="">
    viewof response = Inputs.button("Make random request (press me!)", {
      reduce: async () => {
        try {
          console.log(`Sending request with name parameter '${name}'`);
          const response = await fetch(
            exampleEndpoint.href + `?name=${encodeURIComponent(name)}`
          );
          console.log("Got response", response);
          return response.json();
        } catch (err) {
          return err.message;
        }
      }
    })
  </script>
  <script id="201" type="text/markdown">
    After clicking the button we can render what the response was (after JSON deserialization). Try changing the name value sent and making more requests.
  </script>
  <script id="79" type="application/vnd.observable.javascript" pinned="">
    response || html``
  </script>
  <script id="205" type="text/markdown">
    Updating a value in response to a button press does not seem that impressive until you realize the request is going over the public internet. So you don't need to initiate the request inside the browser, you can also use curl from your console for instance:
  </script>
  <script id="231" type="text/markdown">
    ```

    curl '${exampleEndpoint.href + `?name=fromcurl`}'
    ```
  </script>
  <script id="262" type="text/markdown">
    The story is even more interesting when you pop <a target="_blank" href="https://balsamiq.com/support/faqs/browserconsole">open your developers tools</a>. You should see that the `console.log` messages inside the handler have executed, indicating the endpoint code was executed inside your browser.

    We also write to a `mutable seversideLog` inside the request handler you can confirm the request was handled in *your* notebook session.
  </script>
  <script id="380" type="application/vnd.observable.javascript">
    Inputs.table(
      handlerLog.map((d) => ({
        ...d,
        query: JSON.stringify(d.query),
        headers: JSON.stringify(d.headers)
      }))
    )
  </script>
  <script id="353" type="application/vnd.observable.javascript">
    mutable handlerLog = []
  </script>
  <script id="361" type="application/vnd.observable.javascript">
    Inputs.button("clear log", {
      reduce: () => (mutable handlerLog = [])
    })
  </script>
  <script id="480" type="text/markdown">
    you can change the handler code and the **changes will be reflected instantly**, no need to deploy!
  </script>
  <script id="407" type="text/markdown">
    ## Livecode a webserver

    Endpoint changes are **instantly** visible to livecode. When combined with Observable hot-code reload we can build ergonomic developer reactive workflows. For example, if we put a dataflow dependency of a client on the server, if the server handler changes, the client will refresh automatically, using the very latest deployed code. **livecode propagates serverside code changes at the speed of Observable's reactive dataflow**. 


    In this example the client will be an iframe, and the server with be a webserver definition. In this arrangement, we can reactively develop a server, and always be viewing the latest webpage on the client
  </script>
  <script id="178" type="text/markdown">
    ### Sidequest: Unrolling request processing across cells

    with [flowQueue](https://observablehq.com/@tomlarkworthy/flow-queue)

    As server gets complex, visibility into its request processing pipeline becomes important. We can a [flowQueue](https://observablehq.com/@tomlarkworthy/flow-queue) to lay processing steps across cells in the _dataflow_ style. You call *send* to add a task to the [flowQueue](https://observablehq.com/@tomlarkworthy/flow-queue). The next task will not be loaded until the notebook calls resolve/rejects on the flowQueue *view* for the previous task.
  </script>
  <script id="436" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="420" type="application/vnd.observable.javascript" pinned="">
    webserver = endpoint(
      "webserver",
      async (req, res, ctx) => {
        try {
          mutable weblog = mutable weblog.concat(Date.now());
          // Forward to a flowQueue for (async) processing
          const response = await viewof webRequest.send({
            req,
            res,
            ctx
          });
        } catch (err) {
          res.status(err.code || 500).send(err.message);
        }
      },
      {
        livecode: "public",
        host
      }
    )
  </script>
  <script id="475" type="text/markdown">
    ### `webRequest`, request processing in the dataflow style 

    "viewof webRequest" refers the flowQueue, whereas "webRequest" refers to the current task. When live coding is turned on "webRequest"'s value will be the last seen incoming request to that endpoint. **We can exploit Observable's runtime to leave a trace of server execution**.
  </script>
  <script id="427" type="application/vnd.observable.javascript" pinned="">
    viewof webRequest = flowQueue({
      timeout_ms: 1000
    })
  </script>
  <script id="499" type="application/vnd.observable.javascript" pinned="">
    webRequest
  </script>
  <script id="621" type="text/markdown">
    ### Creating multiple routes

    You can server multiple pages from the webserver by inspecting the `url` param. 

    You can discover the `url` param without reading documentation, by making a random request (click below), and expanding the `webRequest` value (above).

  </script>
  <script id="630" type="application/vnd.observable.javascript">
    viewof randomResponse = Inputs.button("Make request with random path", {
      value: { text: () => "" },
      reduce: () =>
        fetch(webserver.href + "/" + Math.random().toString(16).substring(3))
    })
  </script>
  <script id="740" type="application/vnd.observable.javascript" pinned="">
    webRequest.req.url
  </script>
  <script id="745" type="text/markdown">
    The `req` payload contains all the incoming HTTP information, including the HTTP verb, headers and query parameters!
  </script>
  <script id="748" type="application/vnd.observable.javascript" pinned="">
    webRequest.req
  </script>
  <script id="783" type="text/markdown">
    You can define routes in the [express](https://observablehq.com/@tomlarkworthy/api-hosting-with-express) style if you want, but it is easier to develop incrementally if we use a `flowQueue` for each route.

    We will need a `default` route to handle our random requests, and a most specific ones we will go back to later
  </script>
  <script id="780" type="application/vnd.observable.javascript" pinned="">
    router = {
      switch (webRequest.req.url) {
        default:
          return viewof webRequest.resolve(viewof defaultRequest.send(webRequest));

        // Form handling example
        case "/form.html":
          return viewof webRequest.resolve(viewof formRequest.send(webRequest));

        // Image serving (SVG and PNG)
        case "/weblog.svg":
          return viewof webRequest.resolve(viewof imgRequest.send(webRequest));
        case "/weblog.png":
          return viewof webRequest.resolve(viewof imgRequest.send(webRequest));

        // HTML streaming
        case "/stream.html":
          return viewof webRequest.resolve(viewof streamRequest.send(webRequest));
      }
    }
  </script>
  <script id="801" type="text/markdown">
    ### Responding to a request: `defaultRequest`
  </script>
  <script id="799" type="application/vnd.observable.javascript" pinned="">
    viewof defaultRequest = flowQueue()
  </script>
  <script id="807" type="application/vnd.observable.javascript" pinned="">
    defaultRequest
  </script>
  <script id="809" type="text/markdown">
    The appropriate response to a random request is to return status code 404
  </script>
  <script id="812" type="application/vnd.observable.javascript" pinned="">
    defaultRequestHandler = {
      const message = `Unknown path ${defaultRequest.req.url}`;
      defaultRequest.res.status(404).send(message);
      return message;
    }
  </script>
  <script id="823" type="text/markdown">
    We end the processing by resolving the flowQueue
  </script>
  <script id="827" type="application/vnd.observable.javascript">
    defaultRequestResolver = {
      defaultRequestHandler; // triggered after defaultRequestHandler has run
      viewof defaultRequest.resolve();
    }
  </script>
  <script id="837" type="application/vnd.observable.javascript">
    randomResponse.text()
  </script>
  <script id="839" type="application/vnd.observable.javascript">
    Inputs.button("Make request with random path", {
      reduce: () => viewof randomResponse.querySelector("button").click()
    })
  </script>
  <script id="793" type="text/markdown">
    ### Responding with HTML `formRequest`

    WEBCode is ideal for creating little utilities that can slot in other websites. For example, handling a form data or displaying a chart.
  </script>
  <script id="797" type="application/vnd.observable.javascript" pinned="">
    viewof formRequest = flowQueue()
  </script>
  <script id="857" type="application/vnd.observable.javascript" pinned="">
    formRequest
  </script>
  <script id="874" type="application/vnd.observable.javascript" pinned="">
    formResponseContent = {
      if (formRequest.req.method === "POST") {
        return await viewof formPostRequest.send(formRequest);
      } else if (formRequest.req.method === "GET") {
        return `<form method="post">
      <textarea id="note" name="note"
        rows="5" cols="40"></textarea>
      <div><button type="submit">Submit</button></div>
    </form>`;
      }
    }
  </script>
  <script id="910" type="text/markdown">
    ### Preview a HTML response in an `iframe`

    We can of course put the rendered form in our own iframe so we can see the result
  </script>
  <script id="1023" type="application/vnd.observable.javascript">
    Inputs.button("refresh preview", {
      reduce: () => mutable refreshForm++
    })
  </script>
  <script id="860" type="text/html" pinned="">
    ${/* Programatically refresh this cell by incrementing refreshForm */ (refreshForm, '')}
    <iframe width="${width}" height="170px" src=${webserver.href + "/form.html"}></iframe>
  </script>
  <script id="921" type="text/markdown">
    ### Automated preview refreshing

    If we are a little clever with our dataflow, we can get the iframe to auto refresh on changes. Recall that in a flowQueue, a single request must processed before the next is exposed. If we see the same request more than once, that means intermediate cells have refreshed for reasons *other* than a new request arriving. This is likely a code change so we can tell the preview to refresh when the request the same as the previous one.

    With this little bit of code we can edit the source of the formHandler and the preview updates automatically. Every request has a unique id associated with it (the id) so we can use this to track for repeated exposure to the same request.
  </script>
  <script id="546" type="application/vnd.observable.javascript">
    mutable refreshForm = (webserver, Promises.delay(2000, 0))
  </script>
  <script id="916" type="application/vnd.observable.javascript" pinned="">
    formResponder = {
      if (formRequest.req.id !== /* previous value of cell */ this) {
        // New request, respond to it
        formRequest.res.status(200).send(formResponseContent);
      } else {
        mutable refreshForm++;
      }
      return formRequest.req.id;
    }
  </script>
  <script id="1006" type="text/markdown">
    ### Handling a Form POST response

    When a user clicks the submit button on a form, and the form action is 'POST', the browser makes a POST request to an endpoint with the data in the form encoded in the body. This is the original way of enable a user to pass data to a webserver.
  </script>
  <script id="1008" type="application/vnd.observable.javascript" pinned="">
    viewof formPostRequest = flowQueue()
  </script>
  <script id="1012" type="application/vnd.observable.javascript" pinned="">
    formPostRequest
  </script>
  <script id="1048" type="text/markdown">
    Form data, when using the POST action, is URL encoded in the body.
  </script>
  <script id="1045" type="application/vnd.observable.javascript" pinned="">
    formDataRaw = formPostRequest.req.body
  </script>
  <script id="1052" type="text/markdown">
    The modern way to decode it is with URLSearchParams...
  </script>
  <script id="1056" type="application/vnd.observable.javascript" pinned="">
    decodedFormData = new URLSearchParams(formDataRaw)
  </script>
  <script id="1059" type="text/markdown">
    a URLSearchParams object is not very inspectible on its own, so I often convert into an ordinary data object, which is easier to work with
  </script>
  <script id="1061" type="application/vnd.observable.javascript" pinned="">
    formData = Object.fromEntries(decodedFormData.entries())
  </script>
  <script id="1014" type="application/vnd.observable.javascript" pinned="">
    formPostRequestResolver = {
      formPostRequest;
      viewof formPostRequest.resolve(
        `<h2>Thanks, your note was:</h2><p>${formData.note}</p>`
      );
    }
  </script>
  <script id="1082" type="text/markdown">
    ### Serving media (e.g. images)

    To server images (or video) you must return the data along with the correct [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) in the [`content-type` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type).

    Let's show how this works by serving an Observable Plot (SVG) and a random png. 
  </script>
  <script id="1084" type="application/vnd.observable.javascript" pinned="">
    viewof imgRequest = flowQueue()
  </script>
  <script id="1104" type="application/vnd.observable.javascript" pinned="">
    imgRequest
  </script>
  <script id="1112" type="text/markdown">
    Lets visualize what requests the webserver has seen in its history. When _livecoding_ the log will be just your session, when not _livecoding_, this will scoped to the shared serverside session (!)
  </script>
  <script id="1090" type="application/vnd.observable.javascript">
    mutable weblog = []
  </script>
  <script id="1597" type="text/markdown">
    We have to decouple dataflow from weblog updates so the `imgRequest` pipeline is not triggered by `weblog` changes. We can use a `mutable` for this.
  </script>
  <script id="1561" type="application/vnd.observable.javascript">
    visualizationUpdater = {
      mutable weblogDataviz = Plot.plot({
        x: {
          type: "time",
          label: "time"
        },
        marks: [Plot.tickX(weblog)]
      });
    }
  </script>
  <script id="1119" type="application/vnd.observable.javascript">
    mutable weblogDataviz = undefined
  </script>
  <script id="1155" type="text/markdown">
    To serve an image (and other media), you need to set the correct MIME type and send the data in an arrayBuffer. Step one is converting it to a blob. Mike Bostock has an [excellent notebook on the topic](https://observablehq.com/@mbostock/saving-svg), so we can reuse his work to convert an SVG to a Blob 
  </script>
  <script id="1165" type="application/vnd.observable.javascript">
    import { rasterize, serialize } from "@mbostock/saving-svg"
  </script>
  <script id="1163" type="application/vnd.observable.javascript" pinned="">
    imageData = {
      if (imgRequest.req.url.endsWith(".svg")) {
        return serialize(mutable weblogDataviz);
      } else if (imgRequest.req.url.endsWith(".png")) {
        return rasterize(mutable weblogDataviz);
      } else {
        const error = new Error(
          `Unrecognised image extension ${imgRequest.req.url}`
        );
        error.code = 400;
        viewof imgRequest.reject(error);
        throw error;
      }
    }
  </script>
  <script id="1181" type="text/markdown">
    A correctly constructed blob has the MIME type in the type field:-
  </script>
  <script id="1178" type="application/vnd.observable.javascript" pinned="">
    imageData.type
  </script>
  <script id="1185" type="text/markdown">
    The binary data can also be extracted with '.arrayBuffer()'. Passing an buffer to the response object will send binary data.
  </script>
  <script id="1188" type="application/vnd.observable.javascript" pinned="">
    imgRequestResponder = {
      imgRequest.res.header("content-type", imageData.type);
      imgRequest.res.send(await imageData.arrayBuffer());
    }
  </script>
  <script id="1213" type="text/markdown">
    After sending the data we can unlock the flowQueue task so the next can be handled. Again, we can look for duplicate requests to trigger refreshing the preview too (see above) because that means there was a code change in the request pipeline.
  </script>
  <script id="1202" type="application/vnd.observable.javascript" pinned="">
    imgRequestResolve = {
      imgRequestResponder;
      if (imgRequest.req.id !== this) {
        viewof imgRequest.resolve("OK");
        return imgRequest.req.id;
      } else {
        mutable refreshDashboardImage++;
        return this;
      }
    }
  </script>
  <script id="1217" type="text/markdown">
    If we are serving SVG correctly, we can use it as the src of an image.
  </script>
  <script id="1106" type="text/html" pinned="">
    ${(refreshDashboardImage, '')}
    <img width="${Math.min(width, 640)}" src=${webserver.href + "/weblog.svg"}></img>
  </script>
  <script id="1234" type="text/markdown">
    If we are serving PNG correctly, we can also use it as the src of an image.
  </script>
  <script id="1231" type="text/html" pinned="">
    ${(refreshDashboardImage, '')}
    <img width="${Math.min(width, 640)}" src=${webserver.href + "/weblog.png"}></img>
  </script>
  <script id="1210" type="application/vnd.observable.javascript">
    mutable refreshDashboardImage = Promises.delay(3000, 0)
  </script>
  <script id="1337" type="text/markdown">
    ### Streamed Responses

    So far we have explored a few of the request/response idioms of webservers. Webservers can also stream data, which can be useful for realtime applications or [high performance websites/progressive rendering](https://dev.to/tigt/the-weirdly-obscure-art-of-streamed-html-4gc2).
  </script>
  <script id="1380" type="application/vnd.observable.javascript" pinned="">
    viewof streamRequest = flowQueue()
  </script>
  <script id="1390" type="application/vnd.observable.javascript" pinned="">
    streamRequest
  </script>
  <script id="1576" type="text/markdown">
    In this example every time a control changes we HTML that includes a Javascript snippet to scrub the previous value, so we can have a page displaying the latest value of a control.
  </script>
  <script id="1399" type="application/vnd.observable.javascript" pinned="">
    streamRequestResponse = {
      yield "ok"; // Yeild a value so request processing can proceed dowstream

      // Run the streaming outside of the runtime with event listeners
      // Its not easily possible to handle concurrent long lived requests using dataflow
      const res = streamRequest.res;
      const req = streamRequest.req;
      const changeHandler = () => {
        console.log(`change ${req.id}`);
        res.write(
          `<script>document.querySelector("pre")?.remove()<\/script>` +
            `<pre>latest: ${viewof streamValue.value}</pre>`
        );
      };
      console.log(`opening ${req.id}`);
      res.write(`<body>Streaming for request ${req.id}`);
      changeHandler();

      viewof streamValue.addEventListener("input", changeHandler);
      invalidation.then(() => {
        console.log(`close ${req.id}`);
        viewof streamValue.removeEventListener("input", changeHandler);
        res.end();
      });
    }
  </script>
  <script id="1501" type="application/vnd.observable.javascript" pinned="">
    streamRequestResolver = {
      streamRequestResponse;
      if (this !== streamRequest.req.id) {
        viewof streamRequest.resolve("ok");
      } else {
        mutable streamingPreviewRefresh++;
      }
      return streamRequest.req.id;
    }
  </script>
  <script id="1473" type="application/vnd.observable.javascript">
    viewof streamingPreview = Inputs.toggle({
      label: "turn on streaming preview"
    })
  </script>
  <script id="1570" type="application/vnd.observable.javascript">
    Inputs.button("refresh streaming", {
      reduce: () => mutable streamingPreviewRefresh++
    })
  </script>
  <script id="1392" type="application/vnd.observable.javascript">
    viewof streamValue = Inputs.range([0, 1], { step: 0.001, value: 0, label: "wiggle me" })
  </script>
  <script id="1403" type="text/html" pinned="">
    ${runStreamingPreview && streamingPreviewRefresh}
    <iframe width="${width}" height="100px" src=${link}></iframe>

  </script>
  <script id="1547" type="text/markdown">
    You can read streaming responses in `curl` but you need to turn buffering off

    ```
     curl --no-buffer '${link}' 

    ```
  </script>
  <script id="1537" type="application/vnd.observable.javascript">
    link = webserver.href + "/stream.html"
  </script>
  <script id="1486" type="application/vnd.observable.javascript">
    runStreamingPreview = streamingPreview ? "" : invalidation
  </script>
  <script id="1507" type="application/vnd.observable.javascript" pinned="">
    mutable streamingPreviewRefresh = 0
  </script>
  <script id="1580" type="text/markdown">
    ## Ideas for more Livecoding/Webserver examples?

    Leave a comment if you want to see how to livecode up other webserver functionality
  </script>
  <script id="1292" type="text/markdown">
    ---
  </script>
  <script id="1590" type="text/markdown">
    ## Supporting notebook functionality
  </script>
  <script id="296" type="text/markdown">
    ### Config
  </script>
  <script id="299" type="application/vnd.observable.javascript">
    viewof host = Inputs.bind(
      Inputs.select(["webcode.run", "http://localhost:8080"], {
        label: "host"
      }),
      /* localStorageView allows us to persist the value across refreshed */
      localStorageView("WEBCODE_HOST", {
        defaultValue: "webcode.run"
      })
    )
  </script>
  <script id="303" type="application/vnd.observable.javascript">
    import { localStorageView } from "@tomlarkworthy/local-storage-view"
  </script>
  <script id="321" type="text/markdown">
    ### Notebook Enhancements
  </script>
  <script id="224" type="application/vnd.observable.javascript">
    {
      // After import {endpoint} from 'webcode' snippet is the use of the keyword 'endpoint'
      /* Upstream */ webserver, exampleEndpoint, streamingCurl;
      {
        [...document.querySelectorAll("pre")].forEach((el) =>
          installCopyCode(el, { invalidation })
        );
      }

      installCopyCode(curl_get, { invalidation });
      installCopyCode(curl_get, { invalidation });
      return md`*üëà [copy-code](https://observablehq.com/@tomlarkworthy/copy-code) button for examples*`;
    }
  </script>
  <script id="216" type="application/vnd.observable.javascript">
    import { installCopyCode } from "@tomlarkworthy/copy-code"
  </script>
  <script id="1301" type="application/vnd.observable.javascript">
    import { toc } from "@nebrius/indented-toc"
  </script>
  <script id="327" type="text/markdown">
    ### Notebook Backup, Analytics and monitoring
  </script>
  <script id="149" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer-with-backups"
  </script>
  <script id="152" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
