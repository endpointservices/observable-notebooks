<!doctype html>
<notebook theme="air">
  <title>Simple notebook storage: cellstore</title>
  <script id="1264" type="text/markdown">
    # Simple notebook storage: `cellstore`
  </script>
  <script id="0" type="text/markdown">
    Realtime durable state comes to Observable! Features

    - **simple**, it works using existing Observable login identities and requires no configuration of 3rd party services
    - **empowered**, end users retain bidirectional access to their data even after *forking*
    - **realtime**, mutations are synced to all connected notebooks automatically
    - **secure**, specify who has read and write access using access control lists.
    - **idiomatic**, data flows out reactively, writes are [synchronized](https://observablehq.com/@observablehq/synchronized-inputs) in.

    The aim is to make building custom, persisted, abstractions on Observable easier, to make interoperability with external platforms simpler, and to allow sharing of privileged information between team members while embracing the end-user's right to modify experiences programmatically through [forking](https://observablehq.com/@observablehq/fork-suggest-merge).
  </script>
  <script id="2593" type="application/vnd.observable.javascript">
    import { toc } from "@nebrius/indented-toc"
  </script>
  <script id="2597" type="application/vnd.observable.javascript">
    toc("h2,h3,h4")
  </script>
  <script id="1989" type="text/markdown">
    ## Motivation

    *"There doesn't seem to be a way of building up higher-level abstractions [on Observablehq] and saving and reusing them."* -- Jimmy Miller, [Future of Coding Slack](https://linen.futureofcoding.org/t/2162521/it-s-time-we-rethought-the-text-editor-our-editors-today-are#2e87db8c-bb7b-48fc-be01-0ad7e566dde7), Aug 2022

    I used to worry about Observable extensibility but then I went on to build [an Oauth Authorization Server](https://observablehq.com/@endpointservices/auth), an [OpenAI Tarot Card Reader](https://thetarot.online/), a [CORS Proxy](https://observablehq.com/@tomlarkworthy/fetchp), on-demand [Minecraft Server](https://observablehq.com/@tomlarkworthy/minecraft-servers), a [notebook debugger](https://observablehq.com/@tomlarkworthy/ndd), a [Twitter bot](https://twitter.com/trendingnotebo2) and a API [latency monitor](https://observablehq.com/@tomlarkworthy/serverless-cell-latency-monitor). To meet my growing needs I added plugins for [analytics](https://observablehq.com/@endpointservices/plausible-analytics), [continuous integration](https://observablehq.com/@endpointservices/healthcheck), [error monitoring](https://observablehq.com/@endpointservices/sentry) and [backups](https://observablehq.com/@tomlarkworthy/github-backups). And so I conclude there is very little you cannot do on Observable, however, setting these things up required specialized Cloud knowledge unrelated to the fun part of creation. It shouldn't be so time-consuming and technical! **Jimmy has a point**.

    So with `cellstore` I am taking my experience of building stateful applications on Observable and refactoring out a common-case state abstraction. While I am at it, I can fix some philosophical issues, like end-user forkability, once-and-for-all, and now I can put it all into a single declarative function you can just call. There are no additional steps to do! It's super easy to add state to notebooks now. I can't wait to see what you will do with it!

  </script>
  <script id="2031" type="text/markdown">
    ## Quickstart

    Import `cellstore` and its async dependency loader job with
    ```js
    import {cellstore, cellstoreDeps} from '@endpointservices/cellstore-min'
    ```

    Depend on `cellstoreDeps` somewhere.

    ~~~js
    cellstoreDeps
    ~~~

    The split cell trick allows locally cached values to be returned _before_ dependencies have loaded and is important for fast startup performance. Hopefully, we can eventually remove the trick from the external API ([issue](https://github.com/observablehq/feedback/issues/470)).

    Create a new synchronized storage location with 

    ```js
    viewof myStore = cellstore({
      key: "myStore", // storage identifier
      owner: "YOUR_USERNAME", // team or username administrator
      writers: ["YOUR USERNAME"], // 'all' or an array of usernames
      readers: "all", // 'all' or an array of usernames
      per_user: false, // A shared store or a store per user?
      writes_per_day: 10 // rate limit
    })
    ```

    It will pop open a UI like the one below. You will need to sign in with `admin` permissions for it to update the storage configuration.
  </script>
  <script id="475" type="application/vnd.observable.javascript">
    viewof myStore = cellstore({
      key: "myKey",
      owner: "endpointservices",
      per_user: true,
      writes_per_day: 55,
      writers: "all",
      readers: "all"
    })
  </script>
  <script id="2081" type="text/markdown">

    You read from the store by referencing the variable 'myStore' anywhere in the notebook. 
  </script>
  <script id="2084" type="application/vnd.observable.javascript" pinned="">
    latestValue = myStore
  </script>
  <script id="2054" type="text/markdown">
    Write to the store by writing into the view with `viewof store.value = <VALUE>` or by [view synchronization](https://observablehq.com/@observablehq/synchronized-inputs) (binding).
  </script>
  <script id="761" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("Write by assignment", {
      reduce: () => {
        viewof myStore.value = Math.random();
      }
    })
  </script>
  <script id="2058" type="application/vnd.observable.javascript" pinned="">
    Inputs.bind(
      Inputs.range([0, 1], {
        label: "write by syncronization"
      }),
      viewof myStore
    )
  </script>
  <script id="1334" type="text/markdown">
    ## Option: *per_user* global or per user storage setting

    Either the state is common to everybody, which is useful for sharing configuration, secrets etc. or the state store offers isolated storage for each person, useful for building apps. Control with the *per_user* option flag.
  </script>
  <script id="1349" type="text/markdown">
    ## Demo: Team Shared secret

    In this example *tomlarkworthy* has setup a shared secret that he can setup for his Cloud backend that only *saneef* and *pstuffa* can read.
  </script>
  <script id="1345" type="application/vnd.observable.javascript" pinned="">
    viewof cloud_key = cellstore({
      owner: "endpointservices",
      key: "cloud_key",
      writers: ["tomlarkworthy"],
      readers: ["tomlarkworthy", "saneef", "pstuffa"]
    })
  </script>
  <script id="1361" type="text/markdown">
    To read the key you just use the variable name. As *you* do not have access this cell will be unresolved
  </script>
  <script id="1359" type="application/vnd.observable.javascript" pinned="">
    cloud_key
  </script>
  <script id="1368" type="text/markdown">
    For a secret, it makes sense to [bind]((https://observablehq.com/@observablehq/synchronized-inputs) to an [Inputs.password](https://observablehq.com/@observablehq/input-text#password) field.
  </script>
  <script id="1379" type="application/vnd.observable.javascript" pinned="">
    Inputs.bind(
      Inputs.password({
        // Or use Inputs.password if you don't want the plain text revealed
        label: "edit secret",
        submit: true
      }),
      viewof cloud_key
    )
  </script>
  <script id="1402" type="text/markdown">
    ## Demo: Publicly Readable Cache of HTTP Data

    You want to embed the analysis of an expensive data gathering process in a notebook for everybody to see. Only a small trusted group of people can update the cache, but you want everybody to be able to view it and see the data preparation steps.
  </script>
  <script id="1407" type="application/vnd.observable.javascript" pinned="">
    viewof cache = cellstore({
      owner: "endpointservices",
      key: "cache_example",
      writers: ["tomlarkworthy"], // Only I can update the cache!
      readers: "all"
    })
  </script>
  <script id="2163" type="application/vnd.observable.javascript">
    viewof updateCache = Inputs.button("updateCache", {
      required: true
    })
  </script>
  <script id="2186" type="application/vnd.observable.javascript">
    import { fetchp } with { ALLOW_DOMAINS } from "@tomlarkworthy/fetchp"
  </script>
  <script id="2193" type="application/vnd.observable.javascript">
    ALLOW_DOMAINS = ["news.ycombinator.com"]
  </script>
  <script id="2166" type="application/vnd.observable.javascript">
    fetchData = {
      updateCache; // run this only if the button is bushed
      return {
        hackernews: await (await fetchp("https://news.ycombinator.com")).text()
      };
    }
  </script>
  <script id="2210" type="text/markdown">
    To write the data you can create an Inputs.input to hold the data then bind it to the cache, but I think the imperative API is the simplest
  </script>
  <script id="1915" type="application/vnd.observable.javascript" pinned="">
    {
      viewof cache.value = fetchData;
    }
  </script>
  <script id="2237" type="text/markdown">
    You can use the cached results by referencing the cache variable, for example rendering the HTML. Everybody will see the same results and you do not put any traffic pressure on the source server. A single button click updates the cache, but only those with write permissions can make changes that affect everyone.
  </script>
  <script id="2221" type="application/vnd.observable.javascript" pinned="">
    html`${cache.hackernews}`
  </script>
  <script id="2250" type="text/markdown">
    ## Demo: Custom Abstractions, a Rust editor

    The main motivation behind `cellstore` was experimenting with new programming abstractions. If you set the storage to `per_user` and bump up the `writes_per_day` you can provide isolated storage for user' programs. Here we demo an embedded rust IDE, but you are not limited to just text interfaces!
  </script>
  <script id="2993" type="text/markdown">
    ⚠️ Currently disabled, had some import issue which when resolved caused a circular loop
  </script>
  <script id="2390" type="application/vnd.observable.javascript" pinned="">
    viewof rustProgram = cellstore({
      owner: "endpointservices",
      key: "rust_program",
      writers: "all",
      readers: "all",
      per_user: true,
      writes_per_day: 2000
    })
  </script>
  <script id="2253" type="application/vnd.observable.javascript" pinned="">
    import {
      CodeMirror,
      esmCodeMirror,
      codemirror,
      myDefaultTheme
    } from "@tomlarkworthy/codemirror-6"
  </script>
  <script id="2281" type="application/vnd.observable.javascript">
    rustPlugin = esmCodeMirror("lang-rust@6.0.0")
  </script>
  <script id="2438" type="application/vnd.observable.javascript">
    Inputs.button("load example program", {
      reduce: () => {
        viewof rustProgram.value = `fn main() {
        // Print text to the console
        println!("Hello World!");
    }`;
      }
    })
  </script>
  <script id="2395" type="application/vnd.observable.javascript" pinned="">
    // viewof editor = Inputs.bind(
      CodeMirror("", {
        extensions: [codemirror.basicSetup, rustPlugin.rust(), myDefaultTheme]
      }),
      viewof rustProgram
    )
  </script>
  <script id="2452" type="text/markdown">
    In simple cases you should consider the `cellstore` as the authority, and trigger downstream toolchains from it, but be prepared for more complex cases to use the imperative API.
  </script>
  <script id="2561" type="text/markdown">
    ## Option: `writes_per_day` rate limit


    The maximum number of writes per day for a `per_user` store is 10000


    The maximum number of writes per day for a *NOT* `per_user` store is 100


    The global shared store write limit is much smaller because it can potentially fan out to many readers. I strongly suggest you do not set your rate limits to the maximum, otherwise, if you ever hit the limit due to an infinite loop programming bug, you will have to wait a day for a refill! It is quite easy to cause an infinite loop, hence we have the rate limits!
  </script>
  <script id="2950" type="text/markdown">
    ## Options: `firebaseApp`, `prepareBackendURL`, `verifyBackendURL` and `database`` for bring-your-own-Firebase

    You can bring your own firebase realtime database. You will also need to provide a custom auth token signing backend using a service account from the same project. While `cellstore` uses login-with-comment-v2, the auth backend is actually still the [v1](https://observablehq.com/embed/@endpointservices/login-with-comment), so it's the v1 you will want to fork to create your own custom auth backend.

    The auth backend adds [custom claims](https://firebase.google.com/docs/auth/admin/custom-claims) including which namespace the user signed in from (the realm) as well as the teams they are part of. Using those custom claims we are able to implement the forking logic. Firebase Security rules also enforce write and version counters are incremented as data mutations happen and also enforce rate limits are respected. I will send you rules on request.
  </script>
  <script id="2893" type="text/markdown">
    ---
  </script>
  <script id="2919" type="text/markdown">
    ## Implementation
  </script>
  <script id="2895" type="application/vnd.observable.javascript">
    import {
      cellstore,
      signOut,
      auth,
      canRead,
      canWrite,
      createLogin,
      UI,
      defaultApp,
      cellstoreDeps
    } from "@endpointservices/cellstore-min"
  </script>
  <script id="2916" type="application/vnd.observable.javascript">
    cellstoreDeps
  </script>
  <script id="2838" type="text/markdown">
    ---
  </script>
  <script id="2614" type="text/markdown">
    ## Development tooling

    This is not relevant for users, but I don't feel the need to hide it in another notebook. This tools help with the development and testing of `cellstore`. Like the documentation, I don't want them included with the minimized library.
  </script>
  <script id="2624" type="text/markdown">
    ### New user Journey Manual Test

    Its important that a fresh cellstore works, however, the user might not be logged in, and all the permissions are keyed of a config that may not have written, so we need to ensure that an anonymous user can login as an owner and get started right away. If the config is not written first, the data listeners get permission denied and fail, so there is an important ordering that should be tested.

    This test is somewhat manual as we need someone to really login, so just press the buttons and follow the instructions (if you are a team member of endpointservices)!
  </script>
  <script id="2641" type="application/vnd.observable.javascript">
    viewof newUserJourneyParams = Inputs.button("test journey", {
      reduce: () => Math.random(),
      required: true
    })
  </script>
  <script id="2713" type="application/vnd.observable.javascript">
    viewof afterLogin = (viewof newUserJourneyStore,
    Inputs.button("press after logging in as an admin", {
      required: true
    }))
  </script>
  <script id="2628" type="application/vnd.observable.javascript">
    viewof newUserJourneyStore = (clearNewUserJourneyStoreConfig,
    cellstore({
      owner: "endpointservices",
      key: "userJourneyTest",
      writers: "all",
      readers: "all",
      writes_per_day: 100
    }))
  </script>
  <script id="2752" type="application/vnd.observable.javascript">
    viewof newUserJourney = createSuite({ name: null, timeout_ms: 99999999 })
  </script>
  <script id="2756" type="application/vnd.observable.javascript">
    newUserJourney.test("new user can login and write data", (done) => {
      newUserJourneyParams; // reset

      const listener = () => {
        try {
          const testData = viewof newUserJourneyResults.value;
          expect(testData.dataflowRead).toBe(testData.written);
          expect(testData.backendRead).toBe(testData.written);
        } catch (err) {
          done(err);
        }
        done();
      };
      viewof newUserJourneyResults.addEventListener("input", listener);
      invalidation.then(() =>
        viewof newUserJourneyResults.removeEventListener("input", listener)
      );
    })
  </script>
  <script id="2730" type="application/vnd.observable.javascript" pinned="">
    newUserJourneyParams
  </script>
  <script id="2692" type="application/vnd.observable.javascript">
    mutable authRef = undefined
  </script>
  <script id="2700" type="application/vnd.observable.javascript">
    (mutable authRef = auth)
  </script>
  <script id="2656" type="application/vnd.observable.javascript">
    clearNewUserJourneyStoreConfig = {
      newUserJourneyParams;
      // signout
      await signOut(mutable authRef);

      return fetch(
        "https://datacell-us.firebaseio.com/config/endpointservices/userJourneyTest.json",
        {
          method: "PUT",
          body: "null"
        }
      );
    }
  </script>
  <script id="2654" type="application/vnd.observable.javascript">
    doWrite = (afterLogin,
    (viewof newUserJourneyStore.value = newUserJourneyParams))
  </script>
  <script id="2677" type="application/vnd.observable.javascript">
    backendRead = {
      doWrite;
      const backendValue = await (
        await fetch(
          "https://datacell-us.firebaseio.com/data/endpointservices/userJourneyTest/_.json"
        )
      ).json();

      if (!backendValue.error) return JSON.parse(backendValue);

      return backendValue;
    }
  </script>
  <script id="2652" type="application/vnd.observable.javascript">
    dataflowRead = newUserJourneyStore
  </script>
  <script id="2726" type="application/vnd.observable.javascript">
    viewof newUserJourneyResults = Inputs.input()
  </script>
  <script id="2769" type="application/vnd.observable.javascript">
    {
      viewof newUserJourneyResults.value = {
        written: newUserJourneyStore,
        dataflowRead,
        backendRead
      };
      viewof newUserJourneyResults.dispatchEvent(new Event("input"));
      return viewof newUserJourneyResults.value;
    }
  </script>
  <script id="1651" type="text/markdown">
    ### Permissions Prediction Tests
  </script>
  <script id="1564" type="application/vnd.observable.javascript">
    viewof permissions = createSuite({ name: null })
  </script>
  <script id="1562" type="application/vnd.observable.javascript">
    import { createSuite, expect } from "@tomlarkworthy/testing"
  </script>
  <script id="1693" type="application/vnd.observable.javascript">
    permissions.test("can write is false without uid", () => {
      expect(
        canWrite({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          // uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          writers: ["observablehq|tomlarkworthy"]
        })
      ).toBe(false);
    })
  </script>
  <script id="1697" type="application/vnd.observable.javascript">
    permissions.test("can write is false with wrong uid", () => {
      expect(
        canWrite({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          writers: ["observablehq|endpointservices"] // note
        })
      ).toBe(false);
    })
  </script>
  <script id="1569" type="application/vnd.observable.javascript">
    permissions.test("can write is true using [uid] in writer", () => {
      expect(
        canWrite({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          writers: ["observablehq|tomlarkworthy"],
          per_user: true
        })
      ).toBe(true);
    })
  </script>
  <script id="1618" type="application/vnd.observable.javascript">
    permissions.test("can write is true with 'all' as writer", () => {
      expect(
        canWrite({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          writers: "all",
          per_user: true
        })

      ).toBe(true);
    })
  </script>
  <script id="1702" type="application/vnd.observable.javascript">
    permissions.test("can write is true on forked realm for forker", () => {
      expect(
        canWrite({
          $shard: "forker",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|forker",
          realm: "forker",
          teams: ["forker"],
          writers: "all",
          per_user: true
        })
      ).toBe(true);
    })
  </script>
  <script id="1705" type="application/vnd.observable.javascript">
    permissions.test("can write is false on forked realm for non-forker", () => {
      expect(
        canWrite({
          $shard: "forker",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|forker",
          realm: "otherforker",
          teams: ["forker"],
          writers: "all",
          per_user: true
        })
      ).toBe(false);
    })
  </script>
  <script id="1598" type="application/vnd.observable.javascript">
    permissions.test("can write is false without writer", () => {
      expect(
        canWrite({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          per_user: true
        })
      ).toBe(false);
    })
  </script>
  <script id="1786" type="application/vnd.observable.javascript">
    permissions.test("can write is true when shard is _ and !per_user", () => {
      expect(
        canWrite({
          $shard: "_", // note
          per_user: false, // note
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          writers: ["observablehq|tomlarkworthy"]
        })
      ).toBe(true);
    })
  </script>
  <script id="1789" type="application/vnd.observable.javascript">
    permissions.test(
      "can write is false when shard is user_id and per_user",
      () => {
        expect(
          canWrite({
            $shard: "tomlarkworthy", // note
            per_user: false, //note
            $owner: "endpointservices",
            $key: "myKey",
            uid: "observablehq|tomlarkworthy",
            realm: "endpointservices",
            teams: ["tomlarkworthy"],
            writers: ["observablehq|tomlarkworthy"]
          })
        ).toBe(false);
      }
    )
  </script>
  <script id="1777" type="application/vnd.observable.javascript">
    permissions.test("can write is false when shard is _ and per_user", () => {
      expect(
        canWrite({
          $shard: "_", // note
          per_user: true, // note
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          writers: ["observablehq|tomlarkworthy"]
        })
      ).toBe(false);
    })
  </script>
  <script id="1625" type="application/vnd.observable.javascript">
    permissions.test("can read is true using [uid] in reader", () => {
      expect(
        canRead({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          readers: ["observablehq|tomlarkworthy"],
          per_user: true
        })
      ).toBe(true);
    })
  </script>
  <script id="1634" type="application/vnd.observable.javascript">
    permissions.test("can read is true using 'all' in reader", () => {
      expect(
        canRead({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          readers: "all",
          per_user: true
        })
      ).toBe(true);
    })
  </script>
  <script id="1637" type="application/vnd.observable.javascript">
    permissions.test("can read is false without reader", () => {
      expect(
        canRead({
          $shard: "tomlarkworthy",
          $owner: "endpointservices",
          $key: "myKey",
          uid: "observablehq|tomlarkworthy",
          realm: "endpointservices",
          teams: ["tomlarkworthy"],
          per_user: true
        })
      ).toBe(false);
    })
  </script>
  <script id="93" type="text/markdown">
    ### UI Playground
  </script>
  <script id="272" type="application/vnd.observable.javascript">
    viewof sample = UI({
      userView: createLogin({
        firebaseApp: defaultApp,
        prepareBackendURL:
          "https://webcode.run/observablehq.com/@endpointservices/endpoint-login-with-comment;prepare",
        varifyBackendURL:
          "https://webcode.run/observablehq.com/@endpointservices/endpoint-login-with-comment;verify"
      }),
      showLogin: false,
      showData: true,
      owner: "tomlarkworthy",
      key: "myStore",
      user: "@tomlarkworthy",
      permissions: "none",
      version: 13,
      writes: 9,
      writes_per_day: 10,
      data: {
        string: "cool"
      }
    })
  </script>
  <script id="333" type="application/vnd.observable.javascript">
    sample
  </script>
  <script id="386" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.radio(["info", "login-with-comment"], { label: "screen" }),
      viewof sample.screen
    )
  </script>
  <script id="368" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.toggle({
        label: "signIn"
      }),
      viewof sample.signIn
    )
  </script>
  <script id="400" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.toggle({
        label: "signOut"
      }),
      viewof sample.signOut
    )
  </script>
  <script id="1919" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.toggle({
        label: "showData"
      }),
      viewof sample.showData
    )
  </script>
  <script id="1894" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.toggle({
        label: "showWriteRate"
      }),
      viewof sample.showWriteRate
    )
  </script>
  <script id="337" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.range([0, 10], {
        label: "writes",
        step: 1
      }),
      viewof sample.writes
    )
  </script>
  <script id="353" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.range([0, 10], {
        label: "writes_per_day",
        step: 1
      }),
      viewof sample.writes_per_day
    )
  </script>
  <script id="2925" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer-with-backups"
  </script>
  <script id="2943" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
