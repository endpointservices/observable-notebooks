<!doctype html>
<notebook theme="air">
  <title>Declarative Infra-as-code Helpers</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`# Declarative Infra-as-code Helpers

    Following Kubernetes paradigm, the description of a service is the desired _spec_ and the current state. Current state might change for reasons outside your control. 

    Following Terraform paradigm, we commit the _spec_ to source control (in this case a notebook). _So you must always publish your changes_.

    Following declarative resource orientated design principles, we describe the system into nouns (resources). The user states what they want (e.g. a bucket name 'foo' in europe), and the SDK attempts to make reality match the description of resources described by the user as a JSON document.

    This notebook abstracts a pattern for hosting infra on observable.

    - Create a resource description function by wrapping higher order function _resource).
    - Create a backend implementation by supplying an *apply(current, space, token)*  to a *resource_endpoint* function.

    Firestore hosts the dynamic state (at configPath). Observable hosts the user's intent. 

    The pattern generates a UI with a _sync_ button that 
    1. error checks the latest changes have been committed to the notebook
    -  calls the apply function at the backend with the latest spec
    - reads the result of apply and if successful commits it to the database
    - The user UI updates to reflect the new reality.
    - Counts usage and enforces a _max_ parameter

    Thus the service develop just needs to worry about how the apply function is implemented, and the domain specific fields of the resource.


    `
  </script>
  <script id="343" type="application/vnd.observable.javascript" pinned="">
    widget({
      name: "bill",
      location: "US"
    })
  </script>
  <script id="339" type="application/vnd.observable.javascript" pinned="">
    function widget({
        name = "widget_default",
        location = "europe"
      }) { 
      return resource({
        fields: ["", "name", "location"],
        endpoint: resource_endpoint({
          name: "widget",
          configPath: (domain, notebook, config) => `/domains/${domain}/notebooks/${notebook}/widgets/${config.name}`
        })
      })({
        name, location
      })
    }
  </script>
  <script id="56" type="application/vnd.observable.javascript" pinned="">
    function resource({
        fields = undefined,
        name = "default",
        endpoint
      } = {}) {

      return async (proposedConfig) => {

        async function sync(proposedConfig) {
          const response = await fetch(endpoint.href,
            {
              method: "PUT",
              body: JSON.stringify({
                notebook: notebook(),
                subdomain: subdomain(),
                expected: proposedConfig
              })
            }
          );
          if (response.status !== 200) {
            throw new Error(`Error code ${response.status}. ${await response.text()}`)
          }
          const body = await response.json();
          if (body.message) throw new Error(body.message)
        }

        let error = undefined;
        let updating = false;

        // We create a HTTP endpoint to serve our desired configuration.
        const resource_config = deploy(`public ${endpoint.name} config ${name}`,
                                       (req, res) => res.json(proposedConfig));

        let render = async () => {
          const currentConfig = (await firebase.firestore().doc(endpoint.configPath(subdomain(), notebook(), proposedConfig)).get()).data();
          error = error || currentConfig?.error
          const ui = html`
            ${error ? html`<p style="color:red">${error}</p>`: null}
            ${Table([
              {'': 'current', ...currentConfig},
              {'': 'spec',    ...proposedConfig}
            ], {
              width: 'auto',
              columns: fields
            })}
            ${ updating
              ? html`<button class="update-btn" disabled> updating...</button>`
              : html`<button class="update-btn" onclick=${() => updateClick()}>Sync</button>`
            }
          ` 
          ui.value = proposedConfig
          return ui;
        }

        let ui = await render()
        let updateClick = async () => {
          updating = true;
          ui = reconcile(ui, await render());
          error = undefined;
          try {
            await sync(proposedConfig);
          } catch (err) {
            error = err.message
          }
          updating = false;
          ui = reconcile(ui, await render());
        }

        return ui;
      }
    }
  </script>
  <script id="98" type="application/vnd.observable.javascript" pinned="">
    function resource_endpoint({
        name,
        configPath,
        max = 99999,
        hostNotebook,
        apply = (current, config, token) => config 
      } = {}) {
      const endpoint = deploy(name, async (req, res, ctx) => {
        try {
          const serviceAccount = JSON.parse(ctx.secrets['endpointservices_secretadmin_service_account_key']);
          const token =  await getAccessTokenFromServiceAccount(serviceAccount);
          await signinWithAccessToken(token);

          const {
            subdomain,
            notebook,
            expected,
          } = JSON.parse(req.body);

          const countRef = firebase.firestore().doc(`services/usage/subdomains/${subdomain}/resources/${name}`)
          const currentPromise = firebase.firestore().doc(configPath(subdomain, notebook, expected)).get();
          const currentUsagePromise = countRef.get();

          // We can only safely sync with what has been published
          // So we read configuration is deployed rather than rely on what has been sent in the request
          // Its still useful for the deployer to send what they want to deploy as we can see if they have
          // forgotten to publish the Notebook.
          const actualResponse = await fetchWithTimeout(`https://endpointservice.web.app/notebooks/@${subdomain}/${notebook}/deployments/public%20${name}%20config%20${expected.name}`);
          if (actualResponse.status !== 200) {
            return res.status(404).json({
              error: "No published config found, did you forget to publish/share?"
            });
          }
          const actual = await actualResponse.json()

          // Check the published version matches what the caller is expecting
          if (!_.isEqual(actual, expected)) {
            return res.status(400).json({
              error: "The published config does not match your view, did you forget to publish/share?"
            });
          }

          const current = (await currentPromise).data() || {};
          delete current.error;
          const currentExists = current.state && current.state !== 'deleted'
          const proposedExists = actual.state && actual.state !== 'deleted'
          const proposedChange = (proposedExists ? 1 : 0) - (currentExists ? 1 : 0);

          // Check limits
          const currentUsage = (await currentUsagePromise).data() || {n: 0};

          if (proposedChange > 0 && currentUsage.n + proposedChange > max) {
            return res.status(422).send(`${currentUsage.n}/${max} ${name} resources used. Limit reached.`);
          }


          try {
            await apply(current, actual, {
              notebook: notebook,
              subdomain: subdomain,
              token
            });
          } catch (err) {
            current.error = err.message || err.body
          }

          await firebase.firestore().runTransaction(async (transaction) => {
            const countDoc = (await transaction.get(
              countRef
            )).data() || {
              updates: 0,
              n: 0
            };


            const newExists = current.state && current.state !== 'deleted'
            const change = (newExists ? 1 : 0) - (currentExists ? 1 : 0)

            transaction.set(
              firebase.firestore().doc(configPath(subdomain, notebook, actual))
              , {
                ...current
              }
            );

            transaction.set(countRef, {
              ...countDoc,
              n: countDoc.n + 1, 
              updates: countDoc.updates + 1,
              last_updated: firebase.firebase_.firestore.FieldValue.serverTimestamp(),
            });
          });

          res.json(current);
        } catch (err) {
          console.log(err.message, JSON.stringify(req.body))
          res.status(500).json({
            message: err.message || err.body
          })
        }
      }, {
        hostNotebook: hostNotebook,
        secrets: ['endpointservices_secretadmin_service_account_key']
      });

      return {
        configPath: configPath,
        name: name,
        href: endpoint.href
      }
    }
  </script>
  <script id="104" type="application/vnd.observable.javascript">
    fetchWithTimeout = async (url, options, timeout = 10000) => {
        return await Promise.race([
            fetch(url, options),
            new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Cannot fetch config, did you publish the notebook?')), timeout)
            )
        ]);
    }
  </script>
  <script id="107" type="application/vnd.observable.javascript">
    import {_} from '@mbostock/hello-lodash-fp'
  </script>
  <script id="10" type="application/vnd.observable.javascript">
    import {firebase, listen, subdomain, notebook, signinWithAccessToken, getAccessTokenFromServiceAccount} from '@endpointservices/utils'
  </script>
  <script id="13" type="application/vnd.observable.javascript">
    import {reconcile} from '@tomlarkworthy/reconcile-nanomorph'
  </script>
  <script id="17" type="application/vnd.observable.javascript">
    import {deploy} from '@endpointservices/serverless-cells'
  </script>
  <script id="23" type="application/vnd.observable.javascript">
    import {Table} from '@observablehq/inputs'
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    import {html} from '@observablehq/htl'
  </script>
  <script id="44" type="application/vnd.observable.javascript">
    import {signature} from '@mootari/signature'
  </script>
  <script id="452" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer-with-backups"
  </script>
  <script id="456" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
