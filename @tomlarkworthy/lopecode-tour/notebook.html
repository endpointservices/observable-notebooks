<!doctype html>
<notebook theme="air">
  <title>The Lopecode Tour</title>
  <script id="0" type="text/markdown">
    # The Lopecode Tour


    Lopecode is a web-based live programming environment built on three core principles: the runtime is the source of truth, everything runs in user space, and minimal dependencies. 

    The idea of Lopecode is *not* that it is a notebook, however, it is compatible with Observable notebooks and the notebook format is the only UX built with it yet. The notebook experience is provided by userspace modules. These modules can be edited live just like any other code run by Lopecode.

  </script>
  <script id="1104" type="text/html">
    <details>
      ${lite_youtube_css}
      <summary>Lopecode video tour presented at <a href="https://futureofcoding.org/">Future of Coding</a></summary>
      <lite-youtube videoid="In_BjcsDlfY" playlabel="Lopecode demo at Futore of Code" params="start=972"></lite-youtube>
    </details>
  </script>
  <script id="1100" type="application/vnd.observable.javascript">
    import { lite_youtube_css } from "@tomlarkworthy/lite-youtube-embed"
  </script>
  <script id="19" type="text/markdown">
    ## Architecture

    Inside there is a reactive μ-kernel that executes locally in the browser. It offers hot-code reload, dataflow, modules and meta-programming. Its the [Observable Runtime](https://github.com/observablehq/runtime) but without the hosted Notebook frontend.

    _Everything else_ you see here is made in userspace, including the editor, the presentation and the cell based programming model. Using only the μ-kernel, we are able to build a complete reactive programming system which is reprogrammable at runtime.


    _“If a system is to serve the creative spirit, it must be entirely comprehensible to a single individual… Any barrier that exists between the user and some part of the system will eventually be a barrier to creative expression. Any part of the system that cannot be changed or that is not sufficiently general is a likely source of impediment.”_

    –- ”Design Principles Behind Smalltalk,” Byte 1981(Ingalls 286)
  </script>
  <script id="13" type="text/html">
    <img src="${await architecture.url()}" />
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    import { architecture } from "@tomlarkworthy/reactive-reflective-testing"
  </script>
  <script id="42" type="text/markdown">
    ## 1. The runtime is a collection of cooperating modules
  </script>
  <script id="44" type="text/markdown">
    Modules contain reactive variables in a scope. Reactive variables can depend on other variables and updates automatically cascade.


  </script>
  <script id="1140" type="application/vnd.observable.javascript">
    viewof a = Inputs.range()
  </script>
  <script id="1143" type="application/vnd.observable.javascript">
    a
  </script>
  <script id="1135" type="text/markdown">
    To enable meta-programming, the current set of modules in the runtime is available as a reactive variable, so that any code can reactively update to changes in the current module listing. For instance, the plot below visualizes the *current* set of modules, and reacts to new modules being loaded into the runtime.
  </script>
  <script id="51" type="application/vnd.observable.javascript">
    import {
      visualizeModules,
      viewof currentModules
    } from "@tomlarkworthy/module-map"
  </script>
  <script id="206" type="application/vnd.observable.javascript">
    currentModules
  </script>
  <script id="56" type="application/vnd.observable.javascript">
    mainVisualizeModules = visualizeModules()
  </script>
  <script id="72" type="text/markdown">
    You can add new modules at runtime with the userspace UI below. This will look for the module locally first, and if it cannot be found, pulls from the Observable API.
  </script>
  <script id="66" type="application/vnd.observable.javascript">
    html`<div>
      ${viewof additional_module}
      ${viewof create_module}
      ${viewof remove_module}
    </div>`
  </script>
  <script id="68" type="application/vnd.observable.javascript">
    additionalModules
  </script>
  <script id="62" type="application/vnd.observable.javascript">
    import {
      viewof create_module,
      viewof remove_module,
      viewof additional_module,
      additionalModules
    } from "@tomlarkworthy/module-selection"
  </script>
  <script id="816" type="application/vnd.observable.javascript">
    import { linkTo } from "@tomlarkworthy/lopepage-urls"
  </script>
  <script id="1151" type="text/markdown">
    With meta-programming we are able to build software components that work over the whole of the runtime, for instance, creating module listings UIs and navigators.
  </script>
  <script id="605" type="text/markdown">
    ## Modules define reactive variables
  </script>
  <script id="619" type="text/markdown">
    Reactive variables are owned by a module. Variables have other variables as inputs, and automatically recompute when upstream changes. The variables in the runtime collectively form a dataflow graph arranged in a DAG. 

    A variable's value might recompute for several reasons, perhaps it tracks user input, or its code definition was changed, or it might be a generator that algorithmically emits many values.

    The following chart is a *live* visualization of *this* runtime's variables. It is unusaully busy because this notebook imports *a lot* of other notebooks! Clicking will take you to that cell in the *Lopebook*.
  </script>
  <script id="611" type="application/vnd.observable.javascript">
    import {
      cellMap,
      viewof cellMapViz,
      filteredMap,
      runtimeMap,
      detailVizTitle,
      viewof detailViz
    } from "@tomlarkworthy/cell-map"
  </script>
  <script id="615" type="application/vnd.observable.javascript">
    viewof mainCellMapViz = viewof cellMapViz
  </script>
  <script id="1157" type="text/markdown">
    Note the code that displays the above visualization is nothing *special*, it is written in userspace and you can live edit the code. Thanks to reactive meta-programming UIs that manipulate the entire runtime are possible. Thanks to modules you can import these into the runtime as needed and reuse across lopebooks.
  </script>
  <script id="637" type="text/markdown">
    ## Low level _variables_ are compiled from high level _cells_
  </script>
  <script id="677" type="text/markdown">
    Low level variables are implemented as plain Javascript functions (or generators) with known arguments that the μ-kernel injects when scheduling a recompilation. Choosing the right function type, specifying the arguments is tedius and error prone, so Observable Notebooks wraps the process with a higher level language ([Observable Javascript](https://observablehq.com/documentation/cells/observable-javascript)) that is close to Javascript but in a form that can be auto-wired and that lends itself to implementing common reactive patterns.

    It is the higher level language that introduced the programming model of *cells*. We can look at some examples below. The following diagram unrolls all the dependancies of a specific cell `mainVisualizeModules` owned by the module `main` (when viewed on Observable.com) or `@tomlarkworthy/lopecode-tour` when viewed in Lopecode.
  </script>
  <script id="669" type="application/vnd.observable.javascript">
    {
      if (cellMapViz == null) {
        viewof cellMapViz.value = demoCell;
        viewof cellMapViz.dispatchEvent(new Event("input"));
      }
    }
  </script>
  <script id="728" type="application/vnd.observable.javascript">
    runtimeMap
  </script>
  <script id="655" type="application/vnd.observable.javascript">
    demoCell = {
      mainVisualizeModules;
      return runtimeMap.filter((cell) => cell.name == "mainVisualizeModules")[0];
    }
  </script>
  <script id="644" type="application/vnd.observable.javascript">
    mainDetailVizTitle = detailVizTitle
  </script>
  <script id="647" type="application/vnd.observable.javascript">
    viewof mainDetailCell = viewof detailViz
  </script>
  <script id="699" type="text/markdown">
    The majority of cells are simple (denoted with a circle), and map to a single reactive variable, but there are some special types like `viewof` (triangle) and `mutable` (plus) cells that contain two or three reactive variables. Explaining the full programming model is beyond the scope of this tour. The Observable documentation explains [Observable Javascript](https://observablehq.com/@observablehq/observable-javascript) in detail.

    Lopecode implements its own [Observable Javascript compiler/decompiler in userspace](${linkTo("@tomlarkworthy/observablejs-toolchain")}).

    Note _cells_ are not an innate runtime feature of the μ-kernel, so there is no dependancy on the language [Observable Javascript](https://observablehq.com/@observablehq/observable-javascript) within the μ-kernel. [Observable Javascript](https://observablehq.com/@observablehq/observable-javascript) is front end language that compiles to the low level runtime representation and is implemented in userspace. We can use other languages if they target the low level runtime representation.
  </script>
  <script id="30" type="text/markdown">
    # The runtime is the source of truth
  </script>
  <script id="32" type="text/markdown">
    Thus, there is no external source code representation. The state of the μ-kernel is the source of truth.

    When an [Observable Javascript](https://observablehq.com/@observablehq/observable-javascript) interface is needed to some variables (perhaps to offer a programming UI), the variables are dynamically decompiled, on demand, from live low level functions. 

    The can be achieved because [Javascript functions have a `toString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString) that lists their source. Because the μ-kernel manages all cross-references, no additional lexical scope needs to be considered, and so `toString` is all you need to recover the implementation of the dataflow graph

  </script>
  <script id="142" type="text/markdown">
    Here is a walk through of how it does step-by-step.
  </script>
  <script id="850" type="text/markdown">
    ### 0. Setup

    Let us declare a simple cell that returns the value of a DEPENDANCY.
  </script>
  <script id="92" type="application/vnd.observable.javascript">
    DEPENDANCY = "This should be the value of secret"
  </script>
  <script id="37" type="application/vnd.observable.javascript" pinned="">
    secret = {
      // Can you get this source code from the runtime?
      return DEPENDANCY;
    }
  </script>
  <script id="132" type="text/markdown">
    ### 1. find the variable via meta-programming

    The cell is compiled to a variable, so we can query the runtime to find that variable as an Object
  </script>
  <script id="81" type="application/vnd.observable.javascript">
    import {
      runtime_variables,
      observe,
      lookupVariable,
      thisModule,
      runtime,
      variables
    } from "@tomlarkworthy/runtime-sdk"
  </script>
  <script id="84" type="application/vnd.observable.javascript">
    viewof tourModule = thisModule()
  </script>
  <script id="39" type="application/vnd.observable.javascript" pinned="">
    secret_variable = {
      secret;
      return lookupVariable("secret", tourModule);
    }
  </script>
  <script id="153" type="text/markdown">
    ### 2. Extracts the low level definition of a variable

    We can find the source code of that variable by `toString` the variables `_definition`. This is what a simple cell gets compiled to.
  </script>
  <script id="88" type="application/vnd.observable.javascript" pinned="">
    low_level = secret_variable._definition.toString()
  </script>
  <script id="860" type="text/markdown">
    ⚠️ note is the low level runtime representation, dependancies are represented as arguments to a function. The runtime knows how to fill those arguments because the low level variable also specifies its dependancies in the `_input` field.
  </script>
  <script id="863" type="application/vnd.observable.javascript" pinned="">
    secret_variable._inputs.map((input) => input._name)
  </script>
  <script id="139" type="text/markdown">
    ### 3. _decompiles_ the low level variable definitions to a high level language

    To recover the high-level cell representation can *decompile*, going from low level back to high level
  </script>
  <script id="96" type="application/vnd.observable.javascript">
    import { compile, decompile } from "@tomlarkworthy/observablejs-toolchain"
  </script>
  <script id="90" type="application/vnd.observable.javascript" pinned="">
    high_level = decompile([secret_variable])
  </script>
  <script id="869" type="text/markdown">
    This now looks like the original source code, though perhaps formatted slightly differently
  </script>
  <script id="158" type="text/markdown">
    ### 4. display source code to the programmer

    If we were writing a cell editor we would offer some kind of editable interface to the high-level Observable Javascript source.
  </script>
  <script id="166" type="application/vnd.observable.javascript">
    viewof source = Inputs.textarea({
      label: "Observable Javascript",
      value: high_level.replace("DEPENDANCY", "DEPENDANCY_2")
    })
  </script>
  <script id="1079" type="text/markdown">
    At this point we have recovered a high level cell representation directly from low level runtime representation.
  </script>
  <script id="160" type="text/markdown">

    ### 5. on edit, compile back to the low level representation and updates the variable with a new definition

    We can go from high-level to low level using *compile*.
  </script>
  <script id="104" type="application/vnd.observable.javascript">
    DEPENDANCY_2 = "Where did this come from?"
  </script>
  <script id="101" type="application/vnd.observable.javascript" pinned="">
    low_level_edit = compile(source)
  </script>
  <script id="879" type="application/vnd.observable.javascript">
    Inputs.textarea({
      label: "compiled",
      value: low_level_edit[0]._definition,
      rows: 4,
      disabled: true
    })
  </script>
  <script id="889" type="text/markdown">
    Because the μ-kernel offers hot-code reload, we can hot patch any variable's definition at any time programmatically.
  </script>
  <script id="109" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("hot patch edit", {
      reduce: () => {
        let _fn;
        eval("_fn = " + low_level_edit[0]._definition);
        secret_variable._module.redefine(
          low_level_edit[0]._name,
          low_level_edit[0]._inputs,
          _fn
        );
      }
    })
  </script>
  <script id="469" type="text/markdown">
    When the hot patch is clicked the source of secret is hot patched and all dependancies update 
  </script>
  <script id="892" type="application/vnd.observable.javascript" pinned="">
    secret
  </script>
  <script id="173" type="text/markdown">
    ## The projection of program values to the document DOM is userspace too
  </script>
  <script id="181" type="text/markdown">
    Reactive variables compute Javascript values. Javascript values have no inherent webpage representation. The _visualizer_ maps variable values to DOM nodes to present them in a notebook-like format.   
  </script>
  <script id="192" type="application/vnd.observable.javascript">
    import { visualizer } from "@tomlarkworthy/visualizer"
  </script>
  <script id="256" type="application/vnd.observable.javascript">
    options = new Map([...currentModules.values()].map((m) => [m.name, m]))
  </script>
  <script id="533" type="text/markdown">
    You can pick a module to render, even one dynamically added in the "the runtime is a collection of modules" section above.
  </script>
  <script id="200" type="application/vnd.observable.javascript">
    viewof vizualize_module = Inputs.select(options, {
      label: "select a module to vizualize",
      value: options.get("@tomlarkworthy/reactive-reflective-testing")
    })
  </script>
  <script id="195" type="application/vnd.observable.javascript">
    visualize = html`<div style="width: 90%; height: 400px; overflow: scroll; background: #fee; border: 1rem solid; margin: 1rem; padding: 1rem">
      ${visualizer(runtime, {
        invalidation,
        module: vizualize_module.module,
        detachNodes: true
      })}
    </div>`
  </script>
  <script id="906" type="text/markdown">
    Because the visualizer is a userspace module, we can change it on the fly, or supply a second mapping of program state. The visualizer leverages no special access to the runtime, it simply observes variable value changes with an API that available to every userspace service. 

    Lets do a simple walkthrough for a tabular view of name variables in the Tour notebook
  </script>
  <script id="932" type="text/markdown">
    #### Obtain a reactive reference to variables of interest
  </script>
  <script id="923" type="application/vnd.observable.javascript">
    observedVariables = [...runtime_variables].filter(
      (v) =>
        (v._module == tourModule && v?._name == "observedA") ||
        v?._name == "observedB"
    )
  </script>
  <script id="949" type="text/markdown">
    #### Create a destination for state change
  </script>
  <script id="954" type="application/vnd.observable.javascript">
    stateChangeLog = html`<div>dsds</div>`
  </script>
  <script id="936" type="text/markdown">
    #### Stream the state changes with `observe`
  </script>
  <script id="944" type="application/vnd.observable.javascript" pinned="">
    {
      const observers = observedVariables.map((v) =>
        observe(
          v,
          {
            fulfilled: (value, name) =>
              (stateChangeLog.innerHTML = `<div>'${name}' changed to ${value}</div>`)
          },
          { invalidation }
        )
      );
    }
  </script>
  <script id="959" type="application/vnd.observable.javascript">
    viewof observedA = Inputs.range()
  </script>
  <script id="978" type="application/vnd.observable.javascript">
    viewof observedB = Inputs.range()
  </script>
  <script id="996" type="text/markdown">
    Superficially this looks like what could be achieved with normal Observable Javascript programming, but importantly we have done this programatically and so we can come up with different views of program state.
  </script>
  <script id="247" type="text/markdown">
    ## A Lopebook is a hypertext navigator for _all_ the modules in the runtime

    But why only render a single module, when they are all reactively linked and active in the runtime? A _Lopebook_ visualizes multiple modules and allows navigation through hyperlinks.

    clicking this [link](#view=R100%28S50%28%40tomlarkworthy%2Fmodule-selection%29%2CS50%28%40tomlarkworthy%2Fflow-queue%29%29) appends to the document URL fragment. The lopebook synchronised with the document fragment, and adds a userspace context menu.

    So now you can browse the runtime module structure, with dockable pages, from within the runtime.
  </script>
  <script id="264" type="application/vnd.observable.javascript">
    import { page, background_jobs, context_menu } from "@tomlarkworthy/lopepage"
  </script>
  <script id="262" type="application/vnd.observable.javascript">
    page
  </script>
  <script id="287" type="application/vnd.observable.javascript" pinned="">
    context_menu
  </script>
  <script id="268" type="application/vnd.observable.javascript">
    background_jobs
  </script>
  <script id="280" type="text/markdown">
    ## Exporter can serialize the runtime graph to a single file
  </script>
  <script id="298" type="text/markdown">
    Because "runtime is the source of truth" and the runtime supports meta-programming, the whole runtime dataflow graph can be serialized. 

    The `exporter` chooses to encode the program as a single HTML file. Through importmap magic, we can inline all modules (which are native Browser ESM modules), and all file attachments, as base64 encoded strings. The resultant HTML file can be opened from an operating system without a local webserver because there are no cross-origin requests (its a single file that bundles everything needed without futher network requests).
  </script>
  <script id="292" type="application/vnd.observable.javascript">
    import { exporter } from "@tomlarkworthy/exporter"
  </script>
  <script id="1015" type="text/markdown">
    If you click "Preview" the runtime will be serialized to a HTML file which is then converted to a blob resource, which is then opened in a new tab. It also prints out a handy overview of where all the space is used.
  </script>
  <script id="295" type="application/vnd.observable.javascript">
    exporter2 = exporter()
  </script>
  <script id="392" type="text/markdown">
    Of course, the exporter was implemented in userspace and as userspace has been serialized, the resultant export contains the means to re-export itself _ad infinitum_. With the addition of exporter, _Lopecode_ becomes self-hosting.
  </script>
  <script id="305" type="text/markdown">
    ## File Attachments: include assets for offline-first operation
  </script>
  <script id="307" type="text/markdown">
    Modules support attaching binary assets in userspace. This includes npm sourced Javascript modules. All of Lopecode's Javascript dependancies have been attached to modules, including the Observable runtime μ-kernel. This means an exported single file HTML file will open and fully operate without a network connection.

    Remember how a lopepage navigates through the URL fragment? That works offline too because the hash specifier is not considered a different page and does not cause a network request. Thus it is possible to embed a navigable universe of computation in a single HTML file. 
  </script>
  <script id="325" type="text/markdown">
    ## Writable File Attachments
  </script>
  <script id="327" type="text/markdown">
    Attachments are runtime state, so they can be changed (how else would you set them?). **The runtime is the source of truth**, and and **exporter serialized the runtime**, _therefore_ file attachments can be used as databases or config for state that persists across exports
  </script>
  <script id="336" type="application/vnd.observable.javascript">
    viewof note = Inputs.textarea({
      label: "note",
      rows: 20,
      value: await FileAttachment("task.md").text()
    })
  </script>
  <script id="343" type="application/vnd.observable.javascript">
    import {
      createFileAttachment,
      setFileAttachment
    } from "@tomlarkworthy/fileattachments"
  </script>
  <script id="349" type="application/vnd.observable.javascript">
    attachment = {
      const blob = new Blob([note], {
        type: "application/text;charset=utf-8"
      });
      const url = URL.createObjectURL(blob);
      return createFileAttachment(url, "task.md", "application/text");
    }
  </script>
  <script id="346" type="application/vnd.observable.javascript" pinned="">
    setFileAttachment(attachment, tourModule)
  </script>
  <script id="364" type="text/markdown">
    Updates to the note will be remembered after export, so while dataflow values are forgotten during serialization, there are facilities for binary storage under userspace control through file attachments.
  </script>
  <script id="359" type="application/vnd.observable.javascript">
    exporter()
  </script>
  <script id="369" type="text/markdown">
    ## Dataviz enabled

    d3 and Observable Plot are included. I believe the future coding substrates should be reactive, multi-modal, literate, visual where appropriate and interactive
  </script>
  <script id="376" type="application/vnd.observable.javascript">
    import { manipulate, invert } from "@tomlarkworthy/manipulate"
  </script>
  <script id="381" type="application/vnd.observable.javascript">
    viewof x_simple = Inputs.input([
      { x: 0.1, y: 0.1 },
      { x: 0.9, y: 0.1 },
      { x: 0.1, y: 0.9 },
      { x: 0.5, y: 0.5 }
    ])
  </script>
  <script id="379" type="application/vnd.observable.javascript">
    manipulate({
      this: this,
      viewofData: viewof x_simple,
      viewofPlot: viewof plot_simple,
      invalidation,
      onInteraction: ({
        event,
        pixelStart,
        pixelCurrent,
        dataStart,
        dataCurrent,
        viewofPlot
      }) => {
        const scaleX = viewofPlot.scale("x");
        const scaleY = viewofPlot.scale("y");
        dataCurrent.x = invert(
          scaleX,
          scaleX.apply(dataStart.x) + pixelCurrent[0] - pixelStart[0]
        );
        dataCurrent.y = invert(
          scaleY,
          scaleY.apply(dataStart.y) + pixelCurrent[1] - pixelStart[1]
        );
        event.preventDefault(); // prevents scrolling on mobile
      }
    })
  </script>
  <script id="384" type="application/vnd.observable.javascript">
    viewof plot_simple = Plot.plot({
      marks: [
        Plot.density(x_simple, {
          x: "x",
          y: "y",
          stroke: "blue",
          fill: "#fefeff",
          thresholds: 5,
          bandwidth: 70,
          strokeWidth: 0.25
        }),
        Plot.dot(x_simple, { x: "x", y: "y", value: true, r: 20 }),
        Plot.dot(
          x_simple,
          Plot.pointer({
            x: "x",
            y: "y",
            fill: "red",
            r: 20,
            maxRadius: Infinity
          })
        )
      ]
    })
  </script>
  <script id="389" type="application/vnd.observable.javascript">
    Inputs.table(x_simple)
  </script>
  <script id="399" type="text/markdown">
    ## Nothing is _special_, everything is replacable, runtime state is a *shared* resource.

    The programming system is implemented in userspace and userspace has reactive meta-programming access to everything. You could use the inbuilt editor to edit the editor, or add your own alterantive. 

    You can write your own visualizer, in fact, it is very useful to construct alternative visualization of program state, for example the reactive debugger that places all variable state transitions on a timeline. (tick unpause to see it in action)
  </script>
  <script id="414" type="application/vnd.observable.javascript">
    import { _ndd, viewof pause, events } from "@tomlarkworthy/debugger"
  </script>
  <script id="495" type="application/vnd.observable.javascript">
    {
      viewof pause.value = true;
      viewof pause.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="419" type="application/vnd.observable.javascript">
    notebook_debugger = _ndd
  </script>
  <script id="583" type="text/markdown">
    Similarly the serialised HTML file that the exporter exports is not canonical. You can write a different serialisation format and use both at the same time.
  </script>
  <script id="423" type="text/markdown">
    ## Meta-programming is the tool to build tools
  </script>
  <script id="425" type="text/markdown">
    _Want reactive unit testing that is faster than watch mode?_ Use userspace metaprogramming and search for variables beginning with "test_"
  </script>
  <script id="431" type="application/vnd.observable.javascript">
    import { tests } from "@tomlarkworthy/tests"
  </script>
  <script id="435" type="application/vnd.observable.javascript">
    tests({
      filter: (test) => test.state !== "paused"
    })
  </script>
  <script id="443" type="application/vnd.observable.javascript">
    viewof should_throw = Inputs.toggle({
      label: "throw?"
    })
  </script>
  <script id="439" type="application/vnd.observable.javascript" pinned="">
    test_has_it_thrown = {
      if (should_throw) throw "I threw";
    }
  </script>
  <script id="473" type="text/markdown">
    # AI is the ultimate meta-programmer

    A multimodal literal programming sandboxed reactive runtime that is capable of reflection, self modification and an explicit runtime dependancy graph that can be easily forked to disk is a great place for an agentic AI to play!

    Roboco-op 2 is able to add and edit cells, and, unlike agents like Cursor, it is implemented in userspace and is able to inspect runtime values and construct its own tools. 
  </script>
  <script id="479" type="application/vnd.observable.javascript">
    import { ui } from "@tomlarkworthy/agentic-planner"
  </script>
  <script id="481" type="application/vnd.observable.javascript">
    ui
  </script>
  <script id="1025" type="text/markdown">
    ## Acknowledgements

    Thank you *Mike Bostock* for so much. For building the Observable Runtime, d3, Plot and for seeing the future of a dataviz driven programming environment. Thanks *Philippe Rivière* for the outstanding work on Plot. Thanks *Fabian Iwand* for stretching what is possible on Observable Notebooks. Thanks _Thomas Ballinger_, _Tom MacWright_, _Jeremy Ashkenas_, _Toph Tucker_, _Visnu Pitiyanuvath_, _Allison Horst_, _Ian Johnson_, _Cobus Theunissen_, _Wayne Sutton_ and many more for building Observable.

    Thanks to *Tomas Petricek* for introducing me to the computational *substrates* research discipline, which seems to fit what Lopecode is. Thank *you* for reading!
  </script>
</notebook>
