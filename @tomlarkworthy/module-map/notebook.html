<!doctype html>
<notebook theme="air">
  <title>Module map</title>
  <script id="0" type="text/markdown">
    # Module map


  </script>
  <script id="802" type="application/vnd.observable.javascript">
    visualizeModules()
  </script>
  <script id="700" type="text/markdown">
    Figures out the import structure of a runtime, just pass a runtime to the function `moduleMap` to get a summary of the modules. Returns a map indexed by a Module object to a record.

    ```
    module -> {
      type: "notebook import" | "module variable",
      name: <module name>,
      module: <module object ref>
      ...
    }
    ```
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    moduleMap = async (_runtime = runtime) => {
      keepalive(myModule, "submit_summary");
      keepalive(myModule, "sync_modules");
      return await viewof queue.send(_runtime);
    }
  </script>
  <script id="244" type="text/markdown">
    ### `currentModules`
  </script>
  <script id="786" type="application/vnd.observable.javascript">
    sync_modules = {
      runtime_variables;
      const latest = await moduleMap();
      let dirty = false;
      if (
        !_.isEqual(
          new Set(latest.keys()),
          new Set(viewof currentModules.value.keys())
        )
      ) {
        dirty = true;
      }
      viewof currentModules.value = latest;
      if (dirty) {
        viewof currentModules.dispatchEvent(new Event("input"));
      }
    }
  </script>
  <script id="787" type="application/vnd.observable.javascript">
    viewof currentModules = Inputs.input(await moduleMap())
  </script>
  <script id="254" type="application/vnd.observable.javascript">
    Inputs.table([...currentModules.values()], {
      format: {
        dom: (d) => d.innerHTML,
        specifiers: JSON.stringify,
        variable: (v) => v._name
      }
    })
  </script>
  <script id="897" type="text/markdown">
    ### Visualization
  </script>
  <script id="880" type="application/vnd.observable.javascript" pinned="">
    tipTitle = ([k, c]) => 
    `${k}\ndependsOn: [\n  ${(c[3].dependsOn || []).join(
      "\n  "
    )}\n]\ndependedBy: [\n  ${(c[3].dependedBy || []).join("\n  ")}\n]`
  </script>
  <script id="706" type="application/vnd.observable.javascript">
    visualizeModules = {
      return () => {
        const modules = [...currentModules.values()];
        const layout = (module, index) => [
          ...d3.pointRadial((index * 2 * Math.PI) / modules.length, 100),
          (index * 360) / modules.length,
          module
        ];
        const nodes = new Map(modules.map((m, i) => [m.name, layout(m, i)]));
        const edges = modules.flatMap((from, i) =>
          (from.dependsOn || []).map((to) => [
            [from.name, nodes.get(from.name)],
            [to, nodes.get(to)]
          ])
        );
        const plot = Plot.plot({
          inset: 180,
          aspectRatio: 1,
          axis: null,
          marks: [
            () => htl.svg`<defs>
                <linearGradient id="gradient">
                  <stop offset="15%" stop-color="red" />
                  <stop offset="100%" stop-color="gold" />
                </linearGradient>
              </defs>`,
            Plot.arrow(edges, {
              x1: ([[, [x1]]]) => x1,
              y1: ([[, [, y1]]]) => y1,
              x2: ([, [, [x2]]]) => x2,
              y2: ([, [, [, y2]]]) => y2,
              bend: true,
              stroke: "url(#gradient)",
              strokeOpacity: 0.5,
              strokeLinejoin: "miter",
              headLength: 3,
              inset: 5
            }),
            Plot.text(
              [...nodes.entries()].filter(([k, c]) => c[2] > 180),
              {
                textAnchor: "end",
                x: ([, c]) => c[0],
                y: ([, c]) => c[1],
                rotate: ([, c]) => -c[2] - (c[2] > 180 ? 90 : -90),
                text: ([k]) => k
              }
            ),
            Plot.text(
              [...nodes.entries()].filter(([k, c]) => c[2] <= 180),
              {
                fontSize: 12,
                textAnchor: "start",
                x: ([, c]) => c[0],
                y: ([, c]) => c[1],
                rotate: ([, c]) => -c[2] - (c[2] > 180 ? 90 : -90),
                text: ([k]) => k
              }
            ),
            Plot.tip(
              nodes.entries(),
              Plot.pointer({
                x: ([, c]) => c[0],
                y: ([, c]) => c[1],
                title: tipTitle,
                maxRadius: Infinity
              })
            )
          ]
        });
        // Wrap text labels in hyperlinks
        const xmlns = "http://www.w3.org/2000/svg";
        const xlink = "http://www.w3.org/1999/xlink";
        for (const text of plot.querySelectorAll("text")) {
          const moduleName = text.textContent;
          let url;
          try {
            url = linkTo(moduleName);
          } catch (e) {
            console.error(e);
            continue;
          }
          const a = document.createElementNS(xmlns, "a");
          a.setAttributeNS(null, "href", url);
          a.setAttributeNS(xlink, "href", url);
          text.parentNode.insertBefore(a, text);
          a.appendChild(text);
        }
        return plot;
      };
    }
  </script>
  <script id="416" type="text/markdown">
    ### Random helpers
  </script>
  <script id="503" type="application/vnd.observable.javascript">
    viewof myModule = thisModule()
  </script>
  <script id="499" type="application/vnd.observable.javascript">
    tag = Symbol()
  </script>
  <script id="22" type="application/vnd.observable.javascript">
    forcePeek = {
      //console.log("force peek");
      return (variable, { forever = false } = {}) => {
        if (variable._value) return variable._value;
        let peeker;
        const promise = new Promise((resolve) => {
          peeker = variable._module.variable({}).define([variable._name], (m) => {
            resolve(m);
          });
        });
        if (!forever) promise.then((v) => peeker.delete());
        return promise;
      };
    }
  </script>
  <script id="599" type="application/vnd.observable.javascript">
    observe = (module, variable_name, observer) => {
      const variable = module
        .variable(observer)
        .define(`dynamic observe ${variable_name}`, [variable_name], (m) => m);
      return () => variable.delete();
    }
  </script>
  <script id="249" type="text/markdown">
    ### Implementation
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    viewof queue = flowQueue({ timeout_ms: 15000 })
  </script>
  <script id="101" type="text/markdown">
    We resolve what we can using variables named with prefix `module` that hold module values. We `forcePeek` the variables to make them resolve, which forces loading of the modules.
  </script>
  <script id="11" type="application/vnd.observable.javascript">
    module_definition_variables = {
      console.log("module_definition_variables");
      notebookImports;
      queue;
      let last_module_count = -1;
      let module_definition_variables = [];
      while (last_module_count < module_definition_variables.length) {
        last_module_count = module_definition_variables.length;
        module_definition_variables = await Promise.all(
          [...queue._variables]
            .filter((v) => v._name && v._name.startsWith("module "))
            .filter((v) => !v._name.startsWith("module <unknown"))
            .map(async (v) => {
              await forcePeek(v); // force module to load, may cause others to load
              return v;
            })
        );
      }
      return module_definition_variables;
    }
  </script>
  <script id="44" type="application/vnd.observable.javascript">
    modules = {
      console.log("modules");
      module_definition_variables;
      return [...new Set([...queue._variables].map((v) => v._module))];
    }
  </script>
  <script id="924" type="application/vnd.observable.javascript" pinned="">
    builtin = queue._builtin
  </script>
  <script id="927" type="application/vnd.observable.javascript" pinned="">
    main_modules = {
      const imports = new Set(runtime._modules.values());
      return modules.filter((m) => !imports.has(m) && m !== builtin);
    }
  </script>
  <script id="75" type="application/vnd.observable.javascript">
    resolve_modules = {
      console.log("resolve_modules");
      const module_definitions = new Map();
      const unresolved = [];
      modules.forEach((m) => {
        const md = module_definition_variables.find((md) => md._value == m);
        if (md) {
          module_definitions.set(m, {
            type: "module variable",
            name: findModuleName(md._module._scope, m),
            variable: md
          });
        } else {
          unresolved.push(m);
        }
      });
      return { module_definitions, unresolved };
    }
  </script>
  <script id="107" type="text/markdown">
    modules imported via notebook imports do not have module variables, so they are trickier to figure out. We can sniff the page DOM to find the import expressions, and try to map them to the modules we could to resolve earlier
  </script>
  <script id="12" type="application/vnd.observable.javascript">
    notebookImports = {
      console.log("notebookImports");
      main;
      return new Map(
        [...document.querySelectorAll(".observablehq--import")]
          .map((dom) => [dom, parser.parseCell(dom.textContent)])
          .map(([dom, node]) => [
            dom.parentElement,
            node.body.specifiers.map((s) => ({
              name: node.body.source.value,
              dom: dom.parentElement,
              ast: s,
              local: s.local.name,
              imported: s.imported.name
            }))
          ])
      );
    }
  </script>
  <script id="125" type="application/vnd.observable.javascript">
    notebookImportVariables = {
      console.log("notebookImportVariables");
      return [
        ...[...runtime._variables] // Observable DOM nodes are referenced in runtime variables
          .filter(
            (v) =>
              v._observer &&
              v._observer._node &&
              notebookImports.get(v._observer._node)
          )
          .map((v) => ({
            variable: v,
            notebookImports: notebookImports.get(v._observer._node)
          })),
        ...[
          ...[...notebookImports.entries()] // visualizer DOM nodes have the variable attached
            .filter(([pi, vars]) => pi.variable)
            .map(([pi, vars]) => ({
              variable: pi.variable,
              notebookImports: vars
            }))
        ]
      ].sort((a, b) => b.notebookImports.length - a.notebookImports.length); // sort by complexity
    }
  </script>
  <script id="474" type="application/vnd.observable.javascript">
    pageImportMatch = async (notebookImportVariables, modules) => {
      console.log("pageImportMatch");
      const backupHas = Map.prototype.has; // Save the original `has` method on Map.prototype

      let currentImport = undefined;
      const matches = new Map();
      // Override `Map.prototype.has` to intercept calls to `has` on any Map instance
      Map.prototype.has = function (...args) {
        const module = modules.find((m) => m._scope == this);
        if (currentImport && module) {
          matches.set(module, {
            name: currentImport.notebookImports[0].name,
            type: "notebook import",
            module: module,
            dependsOn: [],
            dependedBy: [],
            dom: currentImport.notebookImports[0].dom,
            specifiers: currentImport.notebookImports.map((pi) => ({
              local: pi.local,
              imported: pi.imported,
              variable: pi.variable
            }))
          });
        }
        return backupHas.call(this, ...args); // Call the original `has` method
      };

      // Iterate through the notebook imports and define them while capturing `has` calls

      await notebookImportVariables.reduce((chain, pageImportVariable) => {
        // Call the definition chain
        return chain.then(async () => {
          currentImport = pageImportVariable;
          try {
            await pageImportVariable.variable._definition();
          } catch (err) {
            console.warn(err);
          }
          currentImport = undefined;
        });
      }, Promise.resolve());

      // Restore the original `has` method after the operations are done
      Map.prototype.has = backupHas;

      return matches;
    }
  </script>
  <script id="431" type="application/vnd.observable.javascript">
    notebookImportMatches = {
      console.log("notebookImportMatches");
      return pageImportMatch(notebookImportVariables, modules);
    }
  </script>
  <script id="205" type="application/vnd.observable.javascript">
    summary = {
      console.log("generate summary");
      const modules = new Map([
        ...main_modules.map((main_module) => [
          main_module,
          {
            name: "main",
            module: main_module,
            dependsOn: [],
            dependedBy: []
          }
        ]),
        [
          builtin,
          {
            name: "builtin",
            module: builtin,
            dependsOn: [],
            dependedBy: []
          }
        ],
        ...notebookImportMatches.entries(),
        ...[...resolve_modules.module_definitions.entries()].map(([m, spec]) => [
          m,
          {
            ...spec,
            name: spec.name,
            module: m,
            dependsOn: [],
            dependedBy: []
          }
        ])
      ]);
      // add cross links
      // notebookImportVariables[0].variable._module == main
      [...notebookImportMatches.keys()].forEach((m) => {
        const hostModule = modules.get(main_modules[0]);
        const importedModule = modules.get(m);
        if (!hostModule?.dependsOn || !importedModule?.dependedBy) {
          console.error(
            "error building module dependancy map",
            hostModule,
            importedModule
          );
          return;
        }
        hostModule.dependsOn.push(importedModule.name);
        importedModule.dependedBy.push(main_modules[0].name);
      });

      module_definition_variables.forEach((v) => {
        const hostModule = modules.get(v._module);
        const importedModule = modules.get(v._value);
        if (!hostModule?.dependsOn || !importedModule?.dependedBy) {
          console.error(
            "error building module dependancy map",
            hostModule,
            importedModule
          );
          return;
        }
        hostModule.dependsOn.push(importedModule.name);
        importedModule.dependedBy.push(hostModule.name);
      });
      return modules;
    }
  </script>
  <script id="232" type="application/vnd.observable.javascript">
    submit_summary = {
      resolve_modules;
      queue;
      console.log("submit_summary");
      notebookImports;
      viewof queue.resolve(summary);
    }
  </script>
  <script id="809" type="application/vnd.observable.javascript">
    import { linkTo } from "@tomlarkworthy/lopepage-urls"
  </script>
  <script id="27" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="5" type="application/vnd.observable.javascript">
    import {
      parser,
      sourceModule,
      findModuleName
    } from "@tomlarkworthy/observablejs-toolchain"
  </script>
  <script id="540" type="application/vnd.observable.javascript">
    import {
      runtime,
      main,
      keepalive,
      thisModule,
      unorderedSync,
      viewof runtime_variables
    } from "@tomlarkworthy/runtime-sdk"
  </script>
</notebook>
