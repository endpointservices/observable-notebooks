<!doctype html>
<notebook theme="air">
  <title>Editor: Reactive Userspace Cell Mutator</title>
  <script id="0" type="text/markdown">
    # Editor: Reactive Userspace Cell Mutator

    [YouTube explainer](https://www.youtube.com/shorts/6FjeJRBC2iw)

    A cell that edits the source of other cells. It is implemented in userspace as a normal cell, so it follows exported notebooks, so exported notebooks become editable! It pairs particularly well with the [single file export](https://observablehq.com/@tomlarkworthy/exporter), because edits are also exported, so you can permanently save your works in a format that continues to be editable and exportable indefinitely. It works offline too!


    The editor is able to edit _any_ cell in the runtime, including those in dependancies. Import it into a notebook and then evaluate `viewof editor`

    ```js
    import {viewof editor} from '@tomlarkworthy/cell-editor'
    ```

    There is a minimal example of the exporter + editor setup [here](https://observablehq.com/@tomlarkworthy/editable-exports)

    #### Use cases
    - Edit notebooks offline
    - Try things out without committing to them
    - Improved debugging workflow, as you can insert `debugger` expressions to dependancies on-demand.

  </script>
  <script id="1987" type="application/vnd.observable.javascript">
    import { trackParent, preserveFocus } from "@tomlarkworthy/track-parent"
  </script>
  <script id="1783" type="application/vnd.observable.javascript">
    viewof editor = {
      console.log("rebuilding editor mutable editor_state", mutable editor_state);
      pull_jobs;
      const combined = view`<div class="cell-editor" 
        style="display: flex;
               flex-direction: column;">
      <style>
        .picking .observablehq:hover {
          background: #ddd2;
        }
        .picked {
          outline: 1px dashed #999;
        }
        .cell-editor form {
          width: auto
        }
        .cm-editor {
          height: fit-content
        }
      </style>
      <div style="display: flex;">
        ${["module", reversibleAttach(combine, viewof module)]}
        <span style="flex-grow: 1;"></span>
      </div>
      <div style="display: flex;">
        ${["cell", reversibleAttach(combine, viewof named_cell)]}
        <span style="flex-grow: 1;"></span>
        ${["remove_variables", reversibleAttach(combine, viewof remove)]}
        ${["apply", reversibleAttach(combine, viewof apply)]}
      </div>
      <div style="flex-grow: 1;">
        ${["editor", reversibleAttach(combine, viewof code_editor)]}
      </div>
      ${["log", reversibleAttach(combine, viewof log)]}

    </div>`;

      combined.addEventListener("mouseup", (event) => {});
      combined.addEventListener("click", (evt) => {
        evt.stopPropagation();
      });
      return combined;
    }
  </script>
  <script id="800" type="text/markdown">
    Save edits by exporting to a single file
  </script>
  <script id="635" type="application/vnd.observable.javascript">
    exporter()
  </script>
  <script id="422" type="text/markdown">
    ## TODO

    - tagged templates
    - better syntax highlighter -- highlight syntax errors -- quite a lot of work, started, but see https://observablehq.com/@tomlarkworthy/observablehq-lezer)
    - Imports (maybe this is a different concern)
  </script>
  <script id="895" type="text/markdown">
    ### Known Issues
    - If you create a new cell, it is invisible, it will appear after exporting.
  </script>
  <script id="517" type="text/markdown">
    ### Editor UI Components
  </script>
  <script id="523" type="application/vnd.observable.javascript">
    viewof combine = Inputs.toggle({
      label: "untick to destructure",
      value: true
    })
  </script>
  <script id="75" type="application/vnd.observable.javascript">
    viewof refresh = Inputs.button("🔄")
  </script>
  <script id="1946" type="application/vnd.observable.javascript">
    viewof remove = Inputs.button("🗑️", {
      reduce: () => {
        remove_variables(named_cell[1]);
      }
    })
  </script>
  <script id="215" type="application/vnd.observable.javascript">
    viewof apply = {
      const button = Inputs.button("▶️", {
        reduce: () => {
          compile_and_update(viewof code_editor.value, named_cell);
        }
      });
      // supress gaining focus
      // doesn't work on observable iframe
      // https://issues.chromium.org/issues/40654608
      button.tabIndex = "-1";
      button.onmousedown = (e) => e.preventDefault();
      return button;
    }
  </script>
  <script id="2210" type="application/vnd.observable.javascript" pinned="">
    moduleOptions = [{ name: "main", module: main }, ...modules.values()]
  </script>
  <script id="904" type="application/vnd.observable.javascript">
    viewof module = {
      const prior =
        moduleOptions.find((o) => o.name == mutable editor_state.last_module) ||
        moduleOptions[0];
      const select = Inputs.select(moduleOptions, {
        //label: "module",
        value: prior,
        format: (info) => info.name
      });

      return select;
    }
  </script>
  <script id="20" type="application/vnd.observable.javascript" pinned="">
    viewof named_cell = {
      cells.set("<new cell>", []);
      const entries = [...cells.entries()];
      const prior =
        mutable editor_state.last_cell &&
        entries.find((cell) => cell[1][0] === mutable editor_state.last_cell[1][0]);

      // Also allow clicking to select cell
      const clickHandler = (evt) => {
        if (document.body.classList.contains("picking") && evt.isTrusted) {
          const div = evt.target.closest(".observablehq");
          viewof picked_dom.value = div;
          viewof picked_dom.dispatchEvent(new Event("input"));

          const entry = divToCell(entries, div);

          if (entry && entry._module) {
            if (entry._module !== module.module) {
              viewof module.value = moduleOptions.find(
                (m) => m.module == entry._module
              );
              viewof module.dispatchEvent(new Event("input"));
            }
          } else {
            select.value = entry;
            select.dispatchEvent(new Event("input"));
          }
        }
      };
      document.body.addEventListener("click", clickHandler);
      invalidation.then(() =>
        document.body.removeEventListener("click", clickHandler)
      );

      const select = Inputs.select(entries, {
        //label: "cell",
        value: prior,
        nonce: refresh,
        format: (v) => v[0]
      });
      return select;
    }
  </script>
  <script id="262" type="application/vnd.observable.javascript">
    viewof code_editor = {
      const editor = CodeMirror("initial text", {
        extensions: [
          codemirror.keymap.of([
            {
              key: "Shift-Enter",
              run: (...args) => editor.apply(...args)
            }
          ]),
          codemirror.EditorView.lineWrapping,
          javascriptPlugin.javascript(),
          codemirror.basicSetup,
          myDefaultTheme
        ]
      });

      editor.addEventListener("click", (evt) => {
        evt.stopPropagation();
      });
      invalidation.then(preserveFocus(editor));
      return editor;
    }
  </script>
  <script id="416" type="application/vnd.observable.javascript">
    viewof log = Inputs.textarea({
      rows: 2,
      resize: false
    })
  </script>
  <script id="2045" type="text/markdown">
    ## API
  </script>
  <script id="2047" type="application/vnd.observable.javascript">
    createCell = async ({ source = "{}" } = {}) =>
      viewof command.send({
        command: "createCell",
        args: {
          source
        }
      })
  </script>
  <script id="2180" type="application/vnd.observable.javascript" pinned="">
    deleteCell = async () =>
      viewof command.send({
        command: "deleteCell"
      })
  </script>
  <script id="2165" type="application/vnd.observable.javascript" pinned="">
    focusEditor = async ({} = {}) =>
      viewof command.send({
        command: "focusEditor"
      })
  </script>
  <script id="2089" type="application/vnd.observable.javascript">
    viewof command = flowQueue() // need to isolate from all the refreshes
  </script>
  <script id="2108" type="application/vnd.observable.javascript" pinned="">
    command
  </script>
  <script id="2098" type="application/vnd.observable.javascript" pinned="">
    command_processor = {
      if (command.processed) return;

      let result = undefined;
      if (command.command == "createCell") {
        result = compile_and_update("{}", ["<new cell>", []]);
      } else if (command.command == "focusEditor") {
        viewof code_editor.querySelector("[contenteditable]").focus();
        result = true;
      } else if (command.command == "deleteCell") {
        remove_variables(named_cell[1]);
        result = true;
      }
      if (result) {
        command.processed = true;
        viewof command.resolve(result);
      }
    }
  </script>
  <script id="1518" type="text/markdown">
    ### UI State
  </script>
  <script id="236" type="application/vnd.observable.javascript">
    viewof cells = {
      refresh;
      return Inputs.input(await cellMap(module.module));
    }
  </script>
  <script id="754" type="application/vnd.observable.javascript">
    mutable editor_state = ({
      last_cell: undefined
    })
  </script>
  <script id="1899" type="application/vnd.observable.javascript">
    last_selected_variable = {
      if (named_cell && named_cell[0] !== "<new cell>") {
        mutable editor_state.last_selected_variable = named_cell;
        console.log("last_selected_variable editor_state", mutable editor_state);
      }
      return mutable editor_state.last_selected_variable;
    }
  </script>
  <script id="2038" type="application/vnd.observable.javascript">
    viewof picked_dom = Inputs.input(null)
  </script>
  <script id="1525" type="text/markdown">
    ### UI Action
  </script>
  <script id="1705" type="application/vnd.observable.javascript">
    pull_jobs = {
      const jobs = [...runtime._variables].find((v) => v._name == "editor_jobs");
      invalidation.then(observe(jobs._module, jobs._name, {}));
    }
  </script>
  <script id="184" type="application/vnd.observable.javascript">
    editor_manager = {
      viewof code_editor.apply = (view) => {
        const doc = view.state.doc.toString();
        compile_and_update(doc, named_cell);
        return true;
      };
      console.log("updating editor", decompiled);
      viewof code_editor.value = decompiled;
      viewof code_editor.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="1345" type="application/vnd.observable.javascript">
    enable_picking = {
      document.body.classList.add("picking");
      invalidation.then(() => document.body.classList.remove("picking"));
    }
  </script>
  <script id="1434" type="application/vnd.observable.javascript">
    highlight_picked = {
      if (!named_cell || !named_cell[1][0]) return;
      const dom = isnode(named_cell[1][0]._value)
        ? named_cell[1][0]._value
        : named_cell[1][0]._observer._node;
      if (!dom) return;
      dom.classList.add("picked");
      invalidation.then(() => {
        dom.classList.remove("picked");
      });
    }
  </script>
  <script id="1352" type="application/vnd.observable.javascript">
    divToCell = (entries, div) => {
      if (!div) return undefined;
      if (div.variable) {
        return (
          entries.find(
            ([name, cell]) => cell[0] && cell.find((v) => v == div.variable)
          ) || div.variable
        );
      } else {
        return entries.find(
          ([name, cell]) => cell[0] && cell[0]._observer._node === div
        );
      }
    }
  </script>
  <script id="615" type="text/markdown">
    ### Decompiler
  </script>
  <script id="1281" type="application/vnd.observable.javascript">
    modules = {
      refresh;
      forcePeek([...runtime._variables].find((v) => v._name == "submit_summary"));
      return moduleMap(runtime);
    }
  </script>
  <script id="619" type="application/vnd.observable.javascript">
    decompiled = {
      if (named_cell[1].length == 0) return "";
      return decompile(named_cell[1]);
    }
  </script>
  <script id="1285" type="application/vnd.observable.javascript" pinned="">
    editor_jobs = {
      // auto subscribe with forcePeek
      command_processor;
      enable_picking;
      highlight_picked;
      editor_manager;
      submit_summary;
      last_selected_variable;
      return "editor_jobs";
    }
  </script>
  <script id="402" type="text/markdown">
    ### Apply Update
  </script>
  <script id="364" type="application/vnd.observable.javascript" pinned="">
    compile_and_update = (source, named_cell) => {
      viewof log.value = "";
      const cell = named_cell[1];
      try {
        let reposition = false,
          insertionIndex = -1;
        const newVariables = compile(source);
        if (!cell || cell.length !== newVariables.length) {
          reposition = true;
          cell.forEach((v) => v.delete());
          for (let i = 0; i < newVariables.length; i++) {
            const newVariable = main.variable({});
            cell.push(newVariable);
          }
        }
        if (reposition) {
          insertionIndex =
            [...runtime._variables].findIndex(
              (v) => v == mutable editor_state.last_selected_variable[1].at(-1)
            ) + 1;
        }
        newVariables.forEach((v, i) => {
          const variable = cell[i];
          let _fn;
          eval("_fn = " + v._definition);
          if (v._name) {
            variable.define(v._name, v._inputs, _fn);
          } else {
            variable.define(v._inputs, _fn);
          }
          if (reposition)
            repositionSetElement(runtime._variables, variable, insertionIndex + i);
        });
        mutable editor_state.last_cell = named_cell;
        mutable editor_state.last_module = module.name;

        console.log("compile_and_update: mutable editor_state", mutable editor_state);
        viewof refresh.dispatchEvent(new Event("input"));
        return named_cell;
      } catch (e) {
        viewof log.value = e.toString();
        debugger;
      }
    }
  </script>
  <script id="1960" type="text/markdown">
    ### Remove Cells
  </script>
  <script id="1952" type="application/vnd.observable.javascript" pinned="">
    remove_variables = (variables) => {
      variables.forEach((v) => v.delete());
      viewof refresh.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="405" type="text/markdown">
    ### Runtime Representation
  </script>
  <script id="434" type="application/vnd.observable.javascript">
    viewof variable = Inputs.radio(named_cell[1], {
      label: "variable in cell group",
      format: (v) => v._name,
      value: named_cell[1][0]
    })
  </script>
  <script id="432" type="application/vnd.observable.javascript">
    name = variable._name
  </script>
  <script id="118" type="application/vnd.observable.javascript">
    inputs = variable._inputs.map((v) => v._name)
  </script>
  <script id="47" type="application/vnd.observable.javascript">
    viewof definition = Inputs.textarea({
      label: "variable._definition",
      value: variable._definition.toString(),
      rows: 10
    })
  </script>
  <script id="84" type="application/vnd.observable.javascript">
    Inputs.button("update definition", {
      disabled: definition === variable._definition.toString(),
      reduce: () => {
        let _fn;
        eval("_fn = " + definition);
        variable.define(variable._name, inputs, _fn);
      }
    })
  </script>
  <script id="394" type="text/markdown">
    ### Editor Libraries
  </script>
  <script id="977" type="application/vnd.observable.javascript">
    import { toObject, isnode, repositionSetElement} from "@tomlarkworthy/runtime-sdk"
  </script>
  <script id="6" type="application/vnd.observable.javascript">
    import { runtime, main } from "@mootari/access-runtime"
  </script>
  <script id="260" type="application/vnd.observable.javascript">
    import {
      CodeMirror,
      codemirror,
      myDefaultTheme
    } from "@tomlarkworthy/codemirror-6-22-2-view"
  </script>
  <script id="154" type="application/vnd.observable.javascript">
    import {
      decompile,
      compile,
      cellMap,
      sourceModule,
      findModuleName,
      parser
    } from "@tomlarkworthy/observablejs-toolchain"
  </script>
  <script id="316" type="application/vnd.observable.javascript">
    javascriptPlugin = codemirror
  </script>
  <script id="496" type="text/markdown">
    ### Libraries
  </script>
  <script id="1531" type="application/vnd.observable.javascript">
    unzip = async (attachment) => {
      const response = await new Response(
        (await attachment.stream()).pipeThrough(new DecompressionStream("gzip"))
      );

      return response.blob();
    }
  </script>
  <script id="511" type="application/vnd.observable.javascript">
    import { view } from "@tomlarkworthy/view"
  </script>
  <script id="514" type="application/vnd.observable.javascript">
    import { reversibleAttach } from "@tomlarkworthy/reversible-attachment"
  </script>
  <script id="632" type="application/vnd.observable.javascript">
    import { exporter } from "@tomlarkworthy/exporter"
  </script>
  <script id="1275" type="application/vnd.observable.javascript">
    import {
      moduleMap,
      submit_summary,
      forcePeek,
      observe
    } from "@tomlarkworthy/module-map"
  </script>
  <script id="2086" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
</notebook>
