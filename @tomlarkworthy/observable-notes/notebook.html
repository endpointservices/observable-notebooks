<!doctype html>
<notebook theme="air">
  <title>How the Observable Runtime works</title>
  <script id="0" type="text/markdown">
    # How the Observable Runtime works
    ## Living documentation
  </script>
  <script id="5" type="text/markdown">
    A lot of Observable is open source and MIT/ISC licensed. Additional tools have been built by the community

    1st party
    - [Observable JS parser](https://github.com/observablehq/parser)
    - [Lezer Grammar for Observable JS](https://github.com/observablehq/lezer)
    - [Observable Runtime](https://github.com/observablehq/runtime)
    - [Standard Library](https://observablehq.com/documentation/misc/standard-library)
    - [Inspector](https://github.com/observablehq/inspector)

    3rd party
    - [Access the runtime](https://observablehq.com/@mootari/access-runtime)
    - [The Unofficial Observable Compiler](https://github.com/asg017/unofficial-observablehq-compiler/tree/beta)
    - [Userspace Observable compiler and decompiler](https://observablehq.com/@tomlarkworthy/observablejs-toolchain)
    - [Notebook Distiller](https://observablehq.com/@tmcw/notebook-distiller)
    - [Single File Exporter](https://observablehq.com/@tomlarkworthy/exporter)
  </script>
  <script id="24" type="application/vnd.observable.javascript">
    cell_map_diagram = mermaid`
    stateDiagram-v2

    observablehq.com --> user
    user --> cell: <a href="https#colon;//observablehq.com/@tmcw/codemirror-inside-of-observable">codemirror</a>

    user --> FileAttachment: upload
    cell --> user: <a href="https#colon;//observablehq.com/blog/bringing-the-typescript-language-server-to-observable">LSP</a>

    cell --> user: <a href="https#colon;//github.com/observablehq/lezer">highlight</a>
    state ___.static.observableusercontent.com {
    cell --> variable: <a href="https#colon;//github.com/observablehq/parser">parse</a> + compile
    variable --> cell:  <a href="observablejs-toolchain">decompile</a>
    cell --> module: <a href="https#colon;//github.com/observablehq/runtime?tab=readme-ov-file#moduleimportname-alias-from">import _ from _</a>
    variable --> main_module: <a href="https#colon;//github.com/observablehq/runtime?tab=readme-ov-file#modulevariableobserver">define</a>

    FileAttachment --> stdlib: <a href="https#colon;//github.com/observablehq/stdlib/blob/main/src/fileAttachment.js"> part of </a>
    module --> runtime: <a href="https#colon;//github.com/observablehq/runtime?tab=readme-ov-file#runtimemoduledefine-observer">defines</a>
    state static {

      main_module --> runtime
    runtime --> main_module: <a href="https#colon;//observablehq.com/@mootari/access-runtime">access-runtime</a>

      stdlib --> runtime
      runtime --> inspector
    }
      inspector --> DOM: <a href="https#colon;//github.com/observablehq/inspector">inspect</a>

    }

    DOM --> observablehq.com: iframe
    `
  </script>
  <script id="325" type="text/markdown">
    ## How Observable works

    In this section I try to explain the main concepts, surfacing the runtime concepts as live variables you can explore inline.
  </script>
  <script id="355" type="text/markdown">
    ### the sandbox
  </script>
  <script id="358" type="text/markdown">
    The main security mechanism on [observablehq.com](https://Observablehq.com) is to run all user javascript inside a sandboxed iframe. Each user has their own subdomain, so local storage of user code is isolated from one another and from the main webpage. 
  </script>
  <script id="376" type="application/vnd.observable.javascript" pinned="">
    iframe_location = document.location // we are inside the sandbox, so the document is the iframe
  </script>
  <script id="935" type="text/markdown">
    A drawback of the sandbox approach is several Web APIs don't work (sharedArrayBuffer, Bluetooth) and default forms submission will redirect the inner page.
  </script>
  <script id="338" type="text/markdown">
    ### The runtime
  </script>
  <script id="215" type="text/markdown">
    At the core is the [Observable runtime](https://github.com/observablehq/runtime), which hot-reloads and schedules recompilation of the dependancy graph. Its the engine of reactivity, implemented in Javascript, executing javascript snippets in units called `variables`.
  </script>
  <script id="348" type="text/markdown">
    The runtime runs *inside* the sandbox, so we can use [[mootari]()](https://observablehq.com/@mootari)'s hack to get a reference to the runtime from within an Observable notebook. 
  </script>
  <script id="246" type="application/vnd.observable.javascript">
    import { runtime, main } from "@mootari/access-runtime"
  </script>
  <script id="342" type="application/vnd.observable.javascript">
    runtime_reference = toObject(runtime)
  </script>
  <script id="340" type="text/markdown">
    ### Variables
  </script>
  <script id="231" type="text/markdown">
    The runtime holds a set of variables.
  </script>
  <script id="384" type="application/vnd.observable.javascript" pinned="">
    runtime_variables = [...runtime._variables].map(toObject)
  </script>
  <script id="226" type="text/markdown">
    Variables are scoped to a module. All notebooks come with a "builtin" module which is defined by the stdlib
  </script>
  <script id="397" type="application/vnd.observable.javascript">
    builtin_module_ref = [...runtime._modules][0][1]
  </script>
  <script id="411" type="application/vnd.observable.javascript">
    builtin_module = toObject(builtin_module_ref)
  </script>
  <script id="250" type="application/vnd.observable.javascript" pinned="">
    builtin_variables = toMap(
      ...[...runtime._variables].filter((v) => v._module === builtin_module_ref)
    )
  </script>
  <script id="268" type="text/markdown">
    Two variables clash if they are named the same and belong to the same scope. However, when you import a module, you only expose a few variables to another module, so it is possible to have variables of the same name but in different modules.
  </script>
  <script id="1048" type="text/markdown">
    ### Variable Definitions

    Variable updates are scheduled when inputs become available. The runtime abstracts over the difference between async and syncronous execution via its scheduler. A variable can emit multiple values per update when defined as a generator.

    When definitions are called, the `this` value bound to the prior state, allowing cells to reduce over executions i.e. chain state forward.
  </script>
  <script id="1049" type="application/vnd.observable.javascript">
    viewof count_button = Inputs.button("count")
  </script>
  <script id="1050" type="application/vnd.observable.javascript" pinned="">
    {
      count_button;
      return this + 1 || 0; // Add 1 to prior state (this)
    }
  </script>
  <script id="1051" type="text/markdown">
    Observable does not enforce any kind of dataflow programming purity. Inputs are passed by reference, so definitions can mutate objects outside of the dataflow paradigm. Furthermore, definitions can reference globals like the window, change the DOM and perform arbitrary side effects outside the dataflow graph.

    While functional reactive purist may find this unattractive, being ordinary Javascript functions reduces integration friction when importing existing Javascript libraries.
  </script>
  <script id="1052" type="text/markdown">
    ### Glitch free Observable Reactivity Semantics
  </script>
  <script id="1053" type="text/markdown">
    Observable builds a dataflow dependancy graph between variables. When a variable is marked dirty, it is scheduled for recomputation next tick, as long as its inputs are not dirty. This batched computation avoids common pitfuls with reactivty such as glitching.
  </script>
  <script id="1054" type="application/vnd.observable.javascript">
    mermaid`graph TD
    A-->D
    A-->C
    B-->D["D ðŸ•£"]
    C-->E
    D-->E
    `
  </script>
  <script id="1055" type="text/markdown">
    In syncronous reactive systems without batching, an update to `A` will chain to C and D and then trigger E twice -- a so called "glitch" which can have unwanted side effects. In Observable, an update to `A` automatically marks A, C, D and E as dirty. C recomputes quickly and updates, followed by D and E after the asynchronous process in D completes. Thus E remains in the dirty state until D has completed and updates only once.

    If B and A update temporally close together, D still emits a value once, but internally the async computation is ran twice with overlap. E then only updates once.
  </script>
  <script id="1056" type="application/vnd.observable.javascript">
    Inputs.button("a", {
      reduce: () => viewof a.dispatchEvent(new Event("input"))
    })
  </script>
  <script id="1057" type="application/vnd.observable.javascript">
    Inputs.button("b", {
      reduce: () => viewof b.dispatchEvent(new Event("input"))
    })
  </script>
  <script id="1058" type="application/vnd.observable.javascript">
    viewof a = Inputs.input(0)
  </script>
  <script id="1059" type="application/vnd.observable.javascript">
    viewof b = Inputs.input(0)
  </script>
  <script id="1060" type="application/vnd.observable.javascript">
    c = {
      a, b;
      return this + 1 || 0;
    }
  </script>
  <script id="1061" type="application/vnd.observable.javascript">
    d = {
      a, b;
      await new Promise((r) => setTimeout(r, 1000));
      return this + 1 || 0;
    }
  </script>
  <script id="1062" type="application/vnd.observable.javascript">
    e = {
      c, d;
      debugger;
      return this + 1 || 0;
    }
  </script>
  <script id="1046" type="application/vnd.observable.javascript">
    viewof module = thisModule()
  </script>
  <script id="1087" type="application/vnd.observable.javascript" pinned="">
    vars = new Map([
      ["a", await lookupVariable("a", module)],
      ["b", await lookupVariable("b", module)],
      ["c", await lookupVariable("c", module)],
      ["d", await lookupVariable("d", module)],
      ["e", await lookupVariable("e", module)]
    ])
  </script>
  <script id="1092" type="text/markdown">
    #### Cycles

    You can get fake cycles by using a viewof and "posting upstream" programatically to the DAG
  </script>
  <script id="1119" type="application/vnd.observable.javascript">
    cycles = Inputs.button("do a cycle", {
      reduce: () => {
        viewof cycle.value = 0;
        viewof cycle.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="1095" type="application/vnd.observable.javascript" pinned="">
    viewof cycle = Inputs.input()
  </script>
  <script id="1123" type="application/vnd.observable.javascript" pinned="">
    cycle
  </script>
  <script id="1097" type="application/vnd.observable.javascript" pinned="">
    increment = {
      viewof cycle.value = cycle + 1;
      viewof cycle.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="1133" type="text/markdown">
    #### Glitch Free cycles (with caveats)

    If you use programmatic trigger, do we still get glitch free operation? i.e. do simultaneous triggers get merged into a single dataflow sweep? What about double triggers?
  </script>
  <script id="1160" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("n-multi trigger DAG", {
      reduce: () => {
        viewof left.value = 0;
        viewof right.value = 0;
        for (let i = 0; i < n; i++) {
          debugger;
          viewof left.dispatchEvent(new Event("input"));
          viewof right.dispatchEvent(new Event("input"));
        }
      }
    })
  </script>
  <script id="1167" type="application/vnd.observable.javascript">
    viewof n = Inputs.range([1, 10], { label: "n", step: 1, value: 1 })
  </script>
  <script id="1144" type="application/vnd.observable.javascript" pinned="">
    viewof left = Inputs.input()
  </script>
  <script id="1146" type="application/vnd.observable.javascript" pinned="">
    viewof right = Inputs.input()
  </script>
  <script id="1150" type="application/vnd.observable.javascript" pinned="">
    left_right = {
      left, right;
      return this + 1 || 0;
    }
  </script>
  <script id="1165" type="text/markdown">
    The above experiment shows triggers on seperate dataflow parents are merged in the same update batch (glitch free!). However,  repeated triggers lead to multiple batches up to a max of 2, which is super weird and unexpected.
  </script>
  <script id="1063" type="text/markdown">
    #### Responsiveness

    Observable prioritises user-responsiveness. Dataflow decendants of high frequency streams will miss updates when they exceed the animation frame rate (typically 60fps). Its best to view the Observable dataflow graph as monotonically converging to the latest state rather than a stream processing engine.
  </script>
  <script id="1064" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("burst 100", {
      reduce: async () => {
        Array.from({ length: 100 }).reduce(
          (promise) =>
            promise.then(async () => {
              await new Promise((r) => setTimeout(r, 0));
              viewof burst.dispatchEvent(new Event("input"));
            }),
          Promise.resolve()
        );
      }
    })
  </script>
  <script id="1065" type="application/vnd.observable.javascript">
    viewof burst = Inputs.input(0)
  </script>
  <script id="1066" type="application/vnd.observable.javascript" pinned="">
    burst_decendant = {
      burst;
      return this + 1 || 0;
    }
  </script>
  <script id="335" type="text/markdown">
    ### Cells
  </script>
  <script id="337" type="text/markdown">
    You program cells in notebooks using ObservableJS. They are compiled to the runtime definitions. There are few major types of cell.
    - Javascript cells
       - with some special handling for async, generator subtypes
    - viewof, mutables
    - Tagged template cells (e.g. markdown, html blocks)
    - import statements
  </script>
  <script id="468" type="text/markdown">
    #### Cell -> variables
  </script>
  <script id="470" type="text/markdown">
    Cells are mapped to one or more runtime variables. A 3rd party tool can group them for a given module. Most cells in this notebook are anonymous cells without names, e.g. markdown blocks.
  </script>
  <script id="475" type="application/vnd.observable.javascript" pinned="">
    main_cells = cellMap(main)
  </script>
  <script id="576" type="text/markdown">
    Each cell is mapped to several variables, for instance, a mutable cell has three variables, the initial value, the non-reactive value, and the reactive value. Cells recompute when the *inputs* change.
  </script>
  <script id="583" type="application/vnd.observable.javascript">
    viewof cell_variables = Inputs.select(main_cells, {
      label: "select a cell to expand"
    })
  </script>
  <script id="588" type="application/vnd.observable.javascript">
    cell_variables_table = Inputs.table(cell_variables.map(toObject), {
      columns: ["_name", "_inputs", "_definition"],
      format: {
        _definition: (d) =>
          Inputs.textarea({ value: d.toString(), disabled: true }),
        _inputs: (d) => d.map((i) => i._name)
      },
      width: {
        _definition: "50%"
      }
    })
  </script>
  <script id="945" type="text/markdown">
    The definition of a variable is the code that is executes when it recomputes. The arguments to that function are the dependancies that need to be computed first. A cell specifies its dependencies in the inputs array.
  </script>
  <script id="624" type="application/vnd.observable.javascript">
    mutable example_mutable = 0
  </script>
  <script id="630" type="text/markdown">
    Each imported variable exposes creates at least one variable to cross between modules.
    ```js
    import {a, b, c as d} from "@..."
    ```

    Importing viewofs and mutables are a bit more complex because both the container and the data channels are imported even if you only import one of them. `with` syntax is even more complicated as a seperate runtime is spawned.
  </script>
  <script id="451" type="text/markdown">
    #### Parsing
  </script>
  <script id="516" type="text/markdown">
    The first stage of transforming ObserrvableJS source code to the runtime variable representation is parsing. The [observablehq/parser](https://github.com/observablehq/parser) does this. Its a wrapper around [acorn](https://github.com/acornjs/acorn). 

    As the examples below show, where Observable goes beyond typical javascript is often expressed in the custom top level "cell" AST node. The other thing it does is figure out external references, which is what drives the dependancy resolution.
  </script>
  <script id="522" type="application/vnd.observable.javascript" pinned="">
    viewof_ast = parser.parseCell("viewof foo = 'bar'")
  </script>
  <script id="524" type="application/vnd.observable.javascript" pinned="">
    mutable_ast = parser.parseCell("mutable foo = 'bar'")
  </script>
  <script id="531" type="application/vnd.observable.javascript" pinned="">
    async_ast = parser.parseCell("foo = { await ''}")
  </script>
  <script id="528" type="application/vnd.observable.javascript" pinned="">
    generator_ast = parser.parseCell("foo = { yield 'async'}")
  </script>
  <script id="534" type="application/vnd.observable.javascript" pinned="">
    fileattachment_ast = parser.parseCell("foo = FileAttachment('filepath')")
  </script>
  <script id="544" type="application/vnd.observable.javascript" pinned="">
    viewof_ref_ast = parser.parseCell("foo = viewof bar")
  </script>
  <script id="638" type="application/vnd.observable.javascript" pinned="">
    import_ast = parser.parseCell("import {foo} from 'blah'")
  </script>
  <script id="554" type="application/vnd.observable.javascript">
    Inputs.table(
      [
        Object.assign(viewof_ast, { name: "viewof_ast" }),
        Object.assign(mutable_ast, { name: "mutable_ast" }),
        Object.assign(async_ast, { name: "async_ast" }),
        Object.assign(generator_ast, { name: "generator_ast" }),
        Object.assign(fileattachment_ast, { name: "fileattachment_ast" }),
        Object.assign(viewof_ref_ast, { name: "viewof_ref_ast" }),
        Object.assign(import_ast, { name: "import_ast" })
      ],
      {
        columns: [
          "name",
          "id",
          "async",
          "generator",
          "references",
          "fileAttachments"
        ],
        width: {
          async: "10%",
          generator: "10%"
        },
        format: {
          id: (id) => JSON.stringify(id),
          references: (r) => JSON.stringify(r),
          fileAttachments: (r) => [...r.keys()]
        }
      }
    )
  </script>
  <script id="663" type="text/markdown">
    ### Compiling
  </script>
  <script id="666" type="text/markdown">
    The Observable compiler is not open source. However, there is the community [unofficial-observablehq-compiler](https://github.com/asg017/unofficial-observablehq-compiler/tree/beta) and the [userspace decompiler/compiler](https://observablehq.com/@tomlarkworthy/observablejs-toolchain).
  </script>
  <script id="671" type="application/vnd.observable.javascript">
    import { compile } from "@tomlarkworthy/observablejs-toolchain"
  </script>
  <script id="674" type="application/vnd.observable.javascript" pinned="">
    compiled_variables = compile("mutable example = 12")
  </script>
  <script id="680" type="text/markdown">
    ## Running your own runtime
  </script>
  <script id="687" type="text/markdown">
    To execute a notebook outside of [observablehq.com](https://observablehq.com) you need to instantiate a runtime (this is what the [notebook export feature](https://observablehq.com/documentation/embeds/advanced) does). First grab import the runtime from npm:
  </script>
  <script id="700" type="application/vnd.observable.javascript" pinned="">
    observable = import(
      "https://cdn.jsdelivr.net/npm/@observablehq/runtime@5/dist/runtime.js"
    )
  </script>
  <script id="706" type="application/vnd.observable.javascript" pinned="">
    embedded_runtime = new observable.Runtime()
  </script>
  <script id="796" type="text/markdown">
    Create a main module
  </script>
  <script id="714" type="application/vnd.observable.javascript" pinned="">
    embedded_main = embedded_runtime.module()
  </script>
  <script id="800" type="text/markdown">
    Create and define variables, we will use the definitions that we compiled earlier
  </script>
  <script id="717" type="application/vnd.observable.javascript" pinned="">
    embedded_variables = compiled_variables.map((v) =>
      embedded_main
        .variable({})
        .define(v._name, v._inputs, toFunction(v._definition))
    )
  </script>
  <script id="743" type="application/vnd.observable.javascript">
    toFunction = (definition) => {
      let _fn;
      eval(`_fn = ${definition}`);
      return _fn;
    }
  </script>
  <script id="808" type="text/markdown">
    The runtime will just run automatically, but as the variables are asyncronously processed, it can take a little while before we can observe the value directly in `_value', so we can observe the promise instead.
  </script>
  <script id="723" type="application/vnd.observable.javascript" pinned="">
    {
      await new Promise((r) => setTimeout(r, 1000));
      return embedded_variables[0]._promise;
    }
  </script>
  <script id="827" type="text/markdown">
    ### Value change notification with Observers
  </script>
  <script id="845" type="text/markdown">
    When a variable is setup, you can set a callback for value changes. Supply functions for handling for `pending`, `fulfilled` and `rejected` ([observers](https://github.com/observablehq/runtime?tab=readme-ov-file#observers) docs). Here we create a variable on a timer and send it result to a Generator function.
  </script>
  <script id="855" type="application/vnd.observable.javascript" pinned="">
    Generators.observe((notify) => {
      // Generator.observe is a notebook userspace concept to make emitting values simpler
      embedded_main
        .variable({
          fulfilled: (value) => {
            // Observer.fulfilled
            notify(value); // pipe the variable notification up to userspace
          }
        })
        .define(async function* () {
          // zero input async generator
          // this is pure JS, normally the output a compile step
          // is used here
          let i = 0;
          while (true) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            yield i++;
          }
        });
    })
  </script>
  <script id="896" type="text/markdown">
    ### Rendering values with Inspector
  </script>
  <script id="830" type="text/markdown">
    To display cell values reactively on a _webpage_, the values need to be converted to DOM and kept up to date reactively. Observable provides the `Inspector` for this purpose, which implements the Observer interface 
  </script>
  <script id="905" type="text/markdown" pinned="">
    <div></div> <!-- DOM container we will pipe changes to -->
  </script>
  <script id="911" type="application/vnd.observable.javascript" pinned="">
    inspector = new observable.Inspector(cell_out) // connect Inspector to our DOM node
  </script>
  <script id="902" type="application/vnd.observable.javascript" pinned="">
    Generators.observe((notify) => {
      // Generator.observe is a notebook userspace concept to make emitting values simpler
      embedded_main.variable(inspector).define(async function* () {
        // zero input async generator
        // this is pure JS, normally the output a compile step
        // is used here
        let i = 0;
        while (true) {
          await new Promise((resolve) => setTimeout(resolve, 1000));
          yield i++;
        }
      });
    })
  </script>
  <script id="966" type="text/markdown">
    The Observer used in notebooks is not the same as the distributed Inspector, there is interesting metadata in the notebook's version. You can get a reference to it via the variable `_observer` reference. You can discover the type of cell by looking at the mode.
  </script>
  <script id="973" type="application/vnd.observable.javascript" pinned="">
    notebook_observer = main._scope.get("title_cell")._observer
  </script>
  <script id="995" type="application/vnd.observable.javascript" pinned="">
    notebook_observer.mode
  </script>
  <script id="984" type="text/markdown">
    Furthermore, you can relate the variable to the rendered DOM node in the notebook
  </script>
  <script id="991" type="application/vnd.observable.javascript" pinned="">
    main._scope.get("title_cell")._observer._node.innerHTML
  </script>
  <script id="1003" type="text/markdown">
    ## File Attachments

    FileAttachments are stored in a Map. The key is the name, the value is either 
    1. a string of a URL
    2. an object `{mimeType, url}`

    A FileAttachment builtin is registered with a module with `runtime.fileAttachments`, this wraps the Map.
  </script>
  <script id="1010" type="text/markdown">
    ## URLs

    Observablehq.com extensively uses native web features like links.


    | type | url |
    |---|---|
    | module (I) | `<BASE_URL>/@tomlarkworthy/exporter` | 
    | module (II) | `<BASE_URL>/d/936eb1bc1db1ac62` | 
    | cell (I) | `<BASE_URL>/@tomlarkworthy/exporter#parser`| 
    | cell (II) | `<BASE_URL>/d/936eb1bc1db1ac62#foo`

    Its worth keeping in mind several links might resolve to the same notebook. If the URL is changed the old name continues to resolve, and every notebook has an id which means the id based URL form always works as well.

  </script>
  <script id="333" type="text/markdown">
    ---
  </script>
  <script id="653" type="application/vnd.observable.javascript">
    exporter()
  </script>
  <script id="281" type="application/vnd.observable.javascript">
    toMap = (...objects) =>
      Object.fromEntries(
        [...objects].map((v) => [
          v._name,
          Object.fromEntries(Object.getOwnPropertyNames(v).map((k) => [k, v[k]]))
        ])
      )
  </script>
  <script id="292" type="application/vnd.observable.javascript">
    toObject = (v) =>
      Object.fromEntries(Object.getOwnPropertyNames(v).map((k) => [k, v[k]]))
  </script>
  <script id="462" type="application/vnd.observable.javascript">
    import { exporter, cellMap, parser } from "@tomlarkworthy/exporter"
  </script>
  <script id="1081" type="application/vnd.observable.javascript" pinned="">
    import { thisModule, lookupVariable } from "@tomlarkworthy/runtime-sdk"
  </script>
</notebook>
