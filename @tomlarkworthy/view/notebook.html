<!doctype html>
<notebook theme="air">
  <title>Composing viewofs with the view literal</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`# Composing viewofs with the _view_ literal

    Lets make custom UIs on Observable _easy_ by composing views.

    We wrap the amazing [hypertext literal](https://observablehq.com/@observablehq/htl) with a interceptor that looks for _[key, view]_ arguments. It uses the key to determine what field to map the view's value to in the container.

    ~~~js
    viewof container = view\`<div>
      \${["child1", Inputs.text()]}
      \${["child2", Inputs.range()]}\`
    ~~~

    The syntax of a 2 element array is inspired by [Object.entries(...)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries).

    By reusing the [hypertext literal](https://observablehq.com/@observablehq/htl) you are able to build your custom ui view using HTML, the best abstraction for layout. Because _view_ itself is a viewof, finally, we can hierarchically build up custom views from standard library views like [@observablehq/inputs](https://observablehq.com/@observablehq/inputs)

    ~~~js
         import {view} from '@tomlarkworthy/view'
    ~~~

    #### How to use the view-literal in UI development

    There is a substantial guide to [scaling UI development](https://observablehq.com/@tomlarkworthy/ui-development) which uses on this view literal quite heavily, and also has some weighty examples than the reference documentation here.


    `
  </script>
  <script id="1105" type="text/markdown">
    Known Issues:
    - https://observablehq.com/@tomlarkworthy/dynamic-controls-example cannot bind to arrayView (DocumentFragment does not emit events)
  </script>
  <script id="511" type="application/vnd.observable.javascript">
    toc()
  </script>
  <script id="321" type="application/vnd.observable.javascript">
    md`## Change log

    - 2021-03-03 *bindOneWay* has *onlyDefined* option added
    - 2021-12-09 Bugfix for *arrayView* not bubbling events.
    - 2021-11-05 *arrayView* refactored out
    - 2021-09-05 [@mootari](/mootari) added lazy loading for testing, thus slimming its footprint significantly in production..
    - 2021-07-29, hidden modifier added
    - 2021-07-05, _array_ binding is now dynamic
    - 2021-06-21, added _singleton_, _array_ and _object_ collection support

    `
  </script>
  <script id="255" type="application/vnd.observable.javascript">
    md`## About

    The original need for a UI composition helper was noted by [@mootari](/@mootari) in a [Github issue](https://github.com/observablehq/inputs/issues/73). [@mbostock](/@mbostock) wrote some very nice composition tactics and greatly clarified desired behavior and, finally, I added the template syntax and passthrough API. It took us several months to get to this!
    `
  </script>
  <script id="128" type="application/vnd.observable.javascript">
    md`#### Demo`
  </script>
  <script id="29" type="application/vnd.observable.javascript" pinned="">
    viewof composite = view`<div style="display: flex; justify-content:space-between; ">
    <div style="display: flex-column;">
      <div>${["r1", Inputs.range([0, 10])]}</div>
      <div>${["r2", Inputs.range([0, 3])]}</div>
      <div>${[
          "text",
          Inputs.text({
            label: "Enter some text"
          })
        ]}</div>
    </div>
    <img width="150"src="https://media.giphy.com/media/2vobTwCkFg88ZUnilt/giphy-downsized.gif"></img>
    </div>
    `
  </script>
  <script id="62" type="application/vnd.observable.javascript">
    md`## Back-writable

    You can write the values back into the component by setting 'value'. This works for sub-components too, as long as everything is following [reusability guidlines](https://observablehq.com/@tomlarkworthy/ui-linter).
    `
  </script>
  <script id="58" type="application/vnd.observable.javascript" pinned="">
    htl.html`<button onclick=${() => {
      viewof composite.value = {
        r1: Math.random() * 10,
        r2: Math.random() * 3,
        text: `${Math.random()}`
      };
      viewof composite.dispatchEvent(new Event('input'));
    }}> randomize composite`
  </script>
  <script id="347" type="application/vnd.observable.javascript">
    md`## Singletons

      Sometimes you want to just wrap an existing view with some HTML. Use the spread operators for this
    `
  </script>
  <script id="330" type="application/vnd.observable.javascript" pinned="">
    viewof singleton = view`<div><h4>My control</h4>${['...', Inputs.range()]}`
  </script>
  <script id="332" type="application/vnd.observable.javascript" pinned="">
    singleton
  </script>
  <script id="355" type="application/vnd.observable.javascript" pinned="">
    viewof singleton
  </script>
  <script id="275" type="application/vnd.observable.javascript">
    md`## Collections -- Arrays

      You can bind an array of views to a single parameter with _\[string, ArrayOfViews]_. 

    If you supply a third argument, a build function of _data => view_ the list can be dynamically resized  _\[label, ArrayOfViews, (data) => view]_
    `
  </script>
  <script id="279" type="application/vnd.observable.javascript" pinned="">
    viewof arrayCollection = view`<div>${[
      "elements",
      Array.from({ length: 5 }, () => Inputs.range())
    ]}`
  </script>
  <script id="1088" type="application/vnd.observable.javascript" pinned="">
    viewof arrayCollection.elements
  </script>
  <script id="382" type="application/vnd.observable.javascript">
    md`Array bindings are mutable, you can write DOM components to the viewof layer`
  </script>
  <script id="367" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("Add a slider", {
      reduce: () => {
        viewof arrayCollection.elements = [
          ...viewof arrayCollection.elements,
          Inputs.range() // Add another viewof
        ];
        // dispatch the input event so dataflow gets updated
        viewof arrayCollection.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="372" type="application/vnd.observable.javascript" pinned="">
    arrayCollection.elements
  </script>
  <script id="283" type="application/vnd.observable.javascript">
    arrayCollection
  </script>
  <script id="838" type="application/vnd.observable.javascript">
    md`### Dynamic Arrays

    If you provide a rowBuilder function as the third argument the view will build new UI elements in response to reassignments at the data layer. It's decribed in detail in [@tomlarkworthy/ui-development#dynamic_lists](https://observablehq.com/@tomlarkworthy/ui-development#dynamic_lists)
    `
  </script>
  <script id="852" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicArrayCollection = view`<div>${[
      'elements',
      [],
      val => Inputs.range([0, 1], { value: val }) // rowBuilder
    ]}`
  </script>
  <script id="855" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("Add a slider", {
      reduce: () => {
        dynamicArrayCollection.elements.push(Math.random());
        // dispatch the input event so dataflow gets updated
        viewof dynamicArrayCollection.elements.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="1101" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("Remove a slider", {
      reduce: () => {
        dynamicArrayCollection.elements.pop();
        // dispatch the input event so dataflow gets updated
        viewof dynamicArrayCollection.elements.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="291" type="application/vnd.observable.javascript">
    objects = md`## Collections -- Objects

      You can bind an object of [string, view] to many parameters with the special spread key '_..._'

    `
  </script>
  <script id="294" type="application/vnd.observable.javascript" pinned="">
    viewof objectCollection = view`${[
      '...',
      {
        number: Inputs.range(),
        text: Inputs.text()
      }
    ]}`
  </script>
  <script id="313" type="application/vnd.observable.javascript" pinned="">
    objectCollection
  </script>
  <script id="876" type="application/vnd.observable.javascript">
    md`### Dynamic Objects

    If you supply a view builder, _(data) => view_ as the third argument, you can dynamically add and remove entries to your view by assigning the a whole new object.
    `
  </script>
  <script id="882" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicObjectCollection = view`<div>${[
      '...',
      {},
      txt => Inputs.text({ value: txt })
    ]}`
  </script>
  <script id="936" type="application/vnd.observable.javascript" pinned="">
    dynamicObjectCollection
  </script>
  <script id="961" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicObjectCollection
  </script>
  <script id="910" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("Pick one of three keys and randomize their value", {
      reduce: () => {
        const key = "k" + Math.floor(Math.random() * 3);
        viewof dynamicObjectCollection.value = {
          ...viewof dynamicObjectCollection.value,
          [key]: key + " " + Math.random()
        };
        viewof dynamicObjectCollection.dispatchEvent(new Event('input', {bubbles: true}))
      }
    })
  </script>
  <script id="915" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("Delete a random key", {
      reduce: () => {
        const copy = { ...viewof dynamicObjectCollection.value };
        const key = "k" + Math.floor(Math.random() * 3);
        delete copy[key];
        viewof dynamicObjectCollection.value = copy;
        viewof dynamicObjectCollection.dispatchEvent(
          new Event('input', { bubbles: true })
        );
      }
    })
  </script>
  <script id="922" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicObjectCollection.value
  </script>
  <script id="727" type="application/vnd.observable.javascript">
    md`## Hidden views

      If you wish to bind a value to the view but not add it to the DOM, prefix the label with "_". This can be useful for bringing another view's value into the model without pruning its currently location.

    known issues: does not work well with singletons.|
    `
  </script>
  <script id="733" type="application/vnd.observable.javascript" pinned="">
    viewof hiddenView = view`<div><h4>My hidden control</h4>${[
      '_hidden',
      viewof singleton
    ]}`
  </script>
  <script id="742" type="application/vnd.observable.javascript" pinned="">
    {
      viewof hiddenView.hidden.value = 0.60;
      viewof hiddenView.hidden.dispatchEvent(new Event("input", { bubble: true }));
    }
  </script>
  <script id="521" type="application/vnd.observable.javascript">
    md`## Extras`
  </script>
  <script id="198" type="application/vnd.observable.javascript">
    md`### Cautious Wrapper

    You might not want changes to propagate immediately. For this usecase wrap with _cautious_.

    *Contributed by [@mootari](/@mootari) and [@jobleonard](/@jobleonard). _isTrusted_ backwriting bypass yoinked from [@mbostock](/@mbostock) in a [talk thread](https://talk.observablehq.com/t/what-is-the-best-way-to-make-range-slider-update-only-on-release/5112/4). Name of feature yoinked from [@tmcw/inputs](https://observablehq.com/@tmcw/inputs/2)*

    By default it wraps the inner node with a SPAN. This is usually the safest thing to do but not always, you can turn off this behaviour with the option _nospan: false_. Note: this will use the topmost node to hold the value.
    `
  </script>
  <script id="200" type="application/vnd.observable.javascript">
    function cautious(
      /* (apply, reset) => view */ viewBuilder,
      { nospan = false } = {}
    ) {
      const apply = DOM.uid().id;
      const reset = DOM.uid().id;

      function inputFilter(node, { filter } = {}) {
        node.addEventListener("input", (e) => {
          filter(e) || e.stopImmediatePropagation();
        });
        return node;
      }

      function wrapper(
        node,
        { initialOnly = false, signal = (e) => e.detail === reset } = {}
      ) {
        const ui = nospan ? node : html`<span>${node}</span>`;
        ui.value = { ...node.value };
        node.addEventListener("input", (e) => {
          if (signal(e)) {
            node.value = ui.value;
            e.stopImmediatePropagation();
          } else if (!initialOnly) {
            ui.value = { ...node.value };
          }
        });

        return ui;
      }

      function trigger(detail) {
        return (e) => {
          if (!e) console.log("An event needs to be passed to apply and reset");
          e.target.dispatchEvent(
            new CustomEvent("input", { bubbles: true, detail })
          );
        };
      }

      return wrapper(
        inputFilter(viewBuilder(trigger(apply), trigger(reset)), {
          filter: (e) => e.detail === apply || e.detail === reset || !e.isTrusted
        })
      );
    }
  </script>
  <script id="234" type="application/vnd.observable.javascript">
    md`#### Cautious demo`
  </script>
  <script id="213" type="application/vnd.observable.javascript">
    cautiousNestedDemo
  </script>
  <script id="207" type="application/vnd.observable.javascript" pinned="">
    viewof cautiousNestedDemo = view`
      ${[
        "c1",
        cautious(
          (apply, reset) => view`<div>
            ${['foo', Inputs.range([0, 100], { label: 'Foo', step: 1 })]}
            ${['bar', Inputs.text({ value: 'change me', label: 'Bar' })]}
            <hr style="margin:0;padding:10px;max-width:360px">
            <button onclick=${apply}>Apply</button>
            <button onclick=${reset}>Reset</button>`
        )
      ]}
      ${[
        "c2",
        cautious(
          (apply, reset) => view`<div>
            ${['baz', Inputs.range([0, 100], { label: 'Baz', step: 1 })]}
            ${['bat', Inputs.text({ value: 'change me', label: 'Bat' })]}
            <hr style="margin:0;padding:10px;max-width:360px">
            <button onclick=${apply}>Apply</button>
            <button onclick=${reset}>Reset</button>`
        )
      ]}

    `
  </script>
  <script id="525" type="application/vnd.observable.javascript">
    md`### bindOneWay

    As views become composite heirarchies, its useful to transform their values as you connect their parts unidirectionally.

    _bindOneWay(target, source, transform, options)_ is a *one-way* bind between event sources, that returns the target. _options_ keys include: _invalidation_, and _transform_.

    Transform allows you to alter the data as it passed between from source to target. Unlike _Inputs.bind_, an event is raised on the target, making it more useful for chaining.

    The signature follows Observables precedence (https://github.com/observablehq/inputs#bind)

    `
  </script>
  <script id="566" type="application/vnd.observable.javascript">
    viewof slider = Inputs.range([0, 10], { value: 0, label: "Try increasing me" })
  </script>
  <script id="550" type="application/vnd.observable.javascript" pinned="">
    viewof levels = bindOneWay(
      Inputs.radio(["0", "low", "high"], { disabled: true }),
      viewof slider,
      {
        transform: v => (v === 0 ? "0" : v < 5 ? "low" : "high")
      }
    )
  </script>
  <script id="590" type="application/vnd.observable.javascript" pinned="">
    viewof levelsText = bindOneWay(Inputs.text({ disabled: true }), viewof levels, {
      transform: l => `The level is ${l}`
    })
  </script>
  <script id="534" type="application/vnd.observable.javascript">
    // Copied from https://github.com/observablehq/inputs/blob/main/src/bind.js
    bindOneWay = {
      function disposal(element) {
        return new Promise((resolve) => {
          requestAnimationFrame(() => {
            if (!element.closest) return;

            const target = element.closest(".observablehq");
            if (!target) return resolve();
            const observer = new MutationObserver(() => {
              if (target.contains(element)) return;
              observer.disconnect(), resolve();
            });
            observer.observe(target, { childList: true });
          });
        });
      }

      return function bindOneWay(
        target,
        /* primary*/ source,
        { invalidation, transform = (d) => d, onlyDefined = false } = {}
      ) {
        const sourceEvent = eventof(source);
        const targetEvent = eventof(target);
        const onsource = () => {
          set(target, source);
          target.dispatchEvent(new Event(targetEvent, { bubbles: true }));
        };
        onsource();
        source.addEventListener(sourceEvent, onsource);
        if (!invalidation) invalidation = disposal(target);
        invalidation.then(() => source.removeEventListener(sourceEvent, onsource));
        return target;

        function get(input) {
          switch (input.type) {
            case "range":
            case "number":
              return input.valueAsNumber;
            case "date":
              return input.valueAsDate;
            case "checkbox":
              return input.checked;
            case "file":
              return input.multiple ? input.files : input.files[0];
            default:
              return input.value;
          }
        }

        function set(target, source) {
          const value = transform(get(source));
          if (onlyDefined && !value) return;
          switch (target.type) {
            case "range":
            case "number":
              target.valueAsNumber = value;
              break;
            case "date":
              target.valueAsDate = value;
              break;
            case "checkbox":
              target.checked = value;
              break;
            case "file":
              target.multiple ? (target.files = value) : (target.files = [value]);
              break;
            default:
              target.value = value;
              break;
          }
        }

        function eventof(input) {
          switch (input.type) {
            case "button":
            case "submit":
              return "click";
            case "file":
              return "change";
            default:
              return "input";
          }
        }
      };
    }
  </script>
  <script id="608" type="application/vnd.observable.javascript">
    md`### variable

    Variables allow you to add additional degrees of freedom to a component as normal views. They have an contained 'value', and they can be bind to.


    The contract of Observable states changes to a view's value should update visual appearance **but not cascade**, whereas if an _'input'_ events is dispatch the cell should cascade Dataflow. Thus a variable defines an additional event type 'assign' which is emmitted whenever the variable is assigned. This is so you can hook variables being assigned to and make DOM manipulations without causing a dataflow cascade.

    The toString of variable is a coercion of the value, so a variable as a view can be placed in attribute nodes etc.

    `
  </script>
  <script id="610" type="application/vnd.observable.javascript" pinned="">
    function variable(value, { name = "variable" } = {}) {
      const self = document.createComment(name);
      return Object.defineProperties(self, {
        value: {
          get: () => value,
          set: newValue => {
            value = newValue;
            self.dispatchEvent(new CustomEvent('assign', { detail: newValue }));
          },
          enumerable: true
        },
        toString: {
          value: () => `${value}`
        }
      });
    }
  </script>
  <script id="616" type="application/vnd.observable.javascript" pinned="">
    exmple_variable = variable(5)
  </script>
  <script id="650" type="application/vnd.observable.javascript" pinned="">
    (exmple_variable.value = 44)
  </script>
  <script id="653" type="application/vnd.observable.javascript" pinned="">
    {
      let resolve = null;
      exmple_variable.addEventListener('assign', evt => resolve(evt.detail));
      while (true) {
        yield new Promise(r => (resolve = r));
      }
    }
  </script>
  <script id="101" type="application/vnd.observable.javascript">
    md`## Code

    Most of the work is done by _htl_, we are simply adding a new _[key, HTML]_ case
    `
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    function view(strings, ...exprs) {
      return wrap(htl.html, strings, ...exprs);
    }
  </script>
  <script id="138" type="application/vnd.observable.javascript">
    function viewSvg(strings, ...exprs) {
      return wrap(htl.svg, strings, ...exprs);
    }
  </script>
  <script id="140" type="application/vnd.observable.javascript" pinned="">
    function wrap(fn, strings, ...exprs) {
      let singleton = undefined;
      let start = undefined; // To know where to start dynamic objects
      let builder = undefined; // For new keys are added dynamically
      const views = {};

      const pexpr = exprs.map((exp) => {
        // All special functions are [key, ...]
        // Otherwise we pass through
        if (!Array.isArray(exp) || typeof exp[0] !== "string") {
          return exp;
        }

        const hidden = exp[0].startsWith("_");
        const key = hidden ? exp[0].substring(1) : exp[0];
        if (key === "value") throw new Error("Cannot use 'value' as a key");
        let presentation;

        if (exp.length === 2 && exp[1] instanceof EventTarget) {
          // SINGLE VIEW PASSED IN
          if (key === "...") {
            // SINGLETON!
            singleton = exp[1];
          } else {
            // look for [key, HTML] entries
            views[key] = exp[1];
          }
          presentation = exp[1];
        } else if (
          // ARRAY PASSED IN (NO BUILDER)
          exp.length === 2 &&
          Array.isArray(exp[1]) &&
          exp[1].every((e) => e instanceof EventTarget)
        ) {
          if (key === "...") throw new Error("Spread not supported for arrays ATM");
          /*
          const start = document.createComment(key);
          arrayViews[key] = {
            start,
            array: exp[1]
          };
          presentation = [start, ...exp[1]];*/
          presentation = arrayView({
            name: key,
            initial: exp[1]
          });
          views[key] = presentation;
        } else if (
          // ARRAY PASSED IN (WITH BUILDER)
          exp.length === 3 &&
          Array.isArray(exp[1]) &&
          exp[1].every((e) => e instanceof EventTarget) &&
          typeof exp[2] === "function"
        ) {
          if (key === "...") throw new Error("Spread not supported for arrays ATM");
          /*
          const start = document.createComment(key);
          arrayViews[key] = {
            start,
            array: exp[1],
            builder: exp[2]
          };
          presentation = [start, ...exp[1]];*/
          presentation = arrayView({
            name: key,
            initial: exp[1],
            builder: exp[2]
          });
          views[key] = presentation;
        } else if (
          // SPREAD OBJECT (NO BUILDER)
          exp.length === 2 &&
          key === "..." &&
          typeof exp[1] === "object" &&
          Object.keys(exp[1]).every((e) => typeof e === "string") &&
          Object.values(exp[1]).every((e) => e instanceof EventTarget)
        ) {
          Object.entries(exp[1]).forEach((e) => (views[e[0]] = e[1]));
          presentation = Object.values(exp[1]);
        } else if (
          // SPREAD OBJECT (WITH BUILDER)
          exp.length === 3 &&
          key === "..." &&
          typeof exp[1] === "object" &&
          Object.keys(exp[1]).every((e) => typeof e === "string") &&
          Object.values(exp[1]).every((e) => e instanceof EventTarget) &&
          typeof exp[2] === "function"
        ) {
          Object.entries(exp[1]).forEach((e) => (views[e[0]] = e[1]));
          start = document.createComment(key);
          builder = exp[2];
          presentation = [start, ...Object.values(exp[1])];
        } else {
          presentation = exp;
        }

        if (hidden) {
          const forwardEvent = (evt) => {
            const clone = new evt.constructor(evt.type, evt);
            self.dispatchEvent(clone);
          };
          if (presentation.addEventListener) {
            presentation.addEventListener("input", forwardEvent);
          } else if (Array.isArray(presentation)) {
            presentation.forEach((p) => {
              // The first element can be the start event sometimes
              if (p.addEventListener) {
                p.addEventListener("input", forwardEvent);
              }
            });
          } else {
            throw new Error("Not sure how to deal with this hidden element");
          }

          return undefined; // No DOM representation
        } else {
          return presentation; // Places in DOM
        }
      });
      const self = fn(strings, ...pexpr);

      if (singleton) {
        if (Object.keys(views).length !== 0)
          throw new Error("Singleton defined but additional properties supplied");

        // Users are expected to call dispatchEvent on view, so the inner singleton
        // need to know about these events for the view to work
        // => events need to be copied over, if originating from here
        self.addEventListener("input", (evt) => {
          if (evt.target === self) {
            const clone = new evt.constructor(evt.type, evt);
            singleton.dispatchEvent(clone);
          }
        });

        return Object.defineProperties(self, {
          value: {
            get: () => singleton.value,
            set: (val) => (singleton.value = val),
            configurable: true
          },
          singleton: {
            value: singleton,
            enumerable: true
          }
        });
      }
      // Non-singleton (Object or Array)
      return Object.defineProperties(self, {
        value: {
          get() {
            return Object.defineProperties(
              {},
              Object.keys(views).reduce((acc, key) => {
                acc[key] = {
                  get: () => views[key].value,
                  set: (v) => (views[key].value = v),
                  enumerable: true
                };
                return acc;
              }, {})
            );
          },
          set(newValues) {
            Object.entries(newValues).forEach(([key, newValue]) => {
              if (views[key]) {
                views[key].value = newValue; // Update of existing child value
              } else if (start && builder) {
                // Adding a new key
                const parent = start.parentNode;
                const newView = builder(newValue);
                views[key] = newView;
                parent.appendChild(newView);
                // Add top level entry too
                Object.defineProperty(self, key, {
                  value: newView,
                  enumerable: true,
                  configurable: true
                });
              }
            });

            // If we are a dynamic Object, we need to remove keys too
            Object.entries(views).forEach(([key, oldValue]) => {
              if (!newValues.hasOwnProperty(key)) {
                // It needs to go
                const oldView = views[key];
                delete views[key];
                if (oldView.remove) oldView.remove();
                delete self[key];
              }
            });
          },
          configurable: true
        },
        ...Object.keys(views).reduce(
          // Add top level field to access the subviews in the parent viewof
          (acc, key) => {
            acc[key] = {
              get: () => views[key],
              set: (newView) => {
                const oldView = views[key];
                delete views[key];
                if (oldView.remove) oldView.remove();

                // assigning an arrayView (special cased)
                if (oldView.length && newView.length) {
                  newView = arrayView({
                    initial: newView,
                    builder: oldView.builder
                  });
                }

                views[key] = newView;
                if (newView instanceof Node) self.appendChild(newView);
              },
              enumerable: true,
              configurable: true
            };
            return acc;
          },
          {}
        )
      });
    }
  </script>
  <script id="1084" type="text/markdown">
    ### arrayView

    arrayView is a DocumentFragment whose nodes are subviews organised in an array. It is initialized with a *builder* of which is a function from data to a subview. E.g. `(str) => Inputs.text({value: str})`, and it can be initialised with a set of views.

    Its presentation layer is a DocumentFragment, but with added array like behaviour so subviews are indexable like an array.

    Its data object is an array, whose in-place methods (splice, push, pop, shift, unshift) are mirrored to DOM manipulation.

    So assigning a new data array *e.g.* `view.value = [...]`, will replace the whole DOM. Pushing an element on an array will insert a single DOM *e.g.* `view.push(...)` using the *builder* to make the new DOM element. By preferring in-place manipulations you can create efficient UIs that minimize DOM manipulations.

    <mark>
    todo
    - Its pretty confusing viewof array.splice does not work now
    </mark>
  </script>
  <script id="1083" type="application/vnd.observable.javascript" pinned="">
    function arrayView({
      name = "arrayNode" + DOM.uid().id,
      value = [],
      initial = [],
      builder
    } = {}) {
      if (value.length > 0 && !builder)
        throw new Error(
          "You cannot initialize an arrayView with data without a builder"
        );

      const frag = new DocumentFragment();

      const subviewToFragmentEventCloner = (e) => {
        const new_e = new e.constructor(e.type, e);
        frag.dispatchEvent(new_e);
      };

      const _builder = builder
        ? (arg) => {
            const subview = builder(arg);
            subview.addEventListener("input", subviewToFragmentEventCloner);
            return subview;
          }
        : undefined;

      const unbuilder = (subview) => {
        subview.removeEventListener("input", subviewToFragmentEventCloner);
      };

      initial.forEach((subview) =>
        subview.addEventListener("input", subviewToFragmentEventCloner)
      );

      const start = document.createComment("START:" + name);
      const end = document.createComment("END:" + name);
      let subviews = (_builder ? value.map(_builder) : []).concat(initial);
      frag.append(...[start, ...subviews, end]);

      frag.addEventListener("input", (e) => {
        // https://stackoverflow.com/questions/11974262/how-to-clone-or-re-dispatch-dom-events
        const new_e = new e.constructor(e.type, e);
        start.dispatchEvent(new_e);
      });

      const getIndexProperty = (index) => ({
        get: () => subviews[index],
        enumerable: true,
        configurable: true
      });

      const customSplice = (startIndex, deleteCount, ...items) => {
        const parent = start.parentNode;
        startIndex = Math.floor(startIndex);
        const removedData = [];
        // sync the splice with the DOM
        let node = start;
        // Forward to begining of the splice
        for (let i = 0; i < startIndex && i < subviews.length; i++)
          node = node.nextSibling;
        // delete 'deleteCount' times
        for (let i = 0; i < deleteCount && i < subviews.length; i++) {
          const toDelete = node.nextSibling;
          removedData.push(toDelete.value);
          unbuilder(toDelete);
          toDelete.remove();
        }
        // add additional items
        const itemViews = [];
        for (let i = items.length - 1; i >= 0; i--) {
          const subview = _builder(items[i]);
          Object.defineProperty(frag, i, getIndexProperty(i));
          let presentation =
            subview instanceof HTMLElement ? subview : htl.html`${subview}`;
          itemViews.unshift(subview);
          parent.insertBefore(presentation, node.nextSibling);
        }

        // Apply to cache
        subviews.splice(startIndex, deleteCount, ...itemViews);
        // Let flow upwards to array too
        return removedData;
      };
      // We intercept operations to the data array and use it to drive DOM operations too.
      const dataArrayProxyHandler = {
        get: function (target, prop, receiver) {
          const args = arguments;

          if (prop === "splice") {
            return customSplice;
          } else if (prop === "push") {
            return (...elements) => {
              customSplice(subviews.length, 0, ...elements);
              return subviews.length;
            };
          } else if (prop === "pop") {
            return () => {
              return customSplice(subviews.length - 1, 1)[0];
            };
          } else if (prop === "shift") {
            return () => {
              return customSplice(0, 1)[0];
            };
          } else if (prop === "unshift") {
            return (...elements) => {
              customSplice(0, 0, ...elements);
              return subviews.length;
            };
          }
          return Reflect.get(...args);
        },
        set(obj, prop, value) {
          if (!isNaN(+prop)) {
            // we also need to set the view
            customSplice(+prop, 1, value);
          }
          return Reflect.set(...arguments);
        }
      };

      // Add data channel
      Object.defineProperties(frag, {
        value: {
          get: () =>
            new Proxy(
              subviews.map((sv) => sv.value),
              dataArrayProxyHandler
            ),
          set: (newArray) => {
            const vArr = _.cloneDeep(newArray);
            const parent = start.parentNode;

            if (builder) {
              // We should be true to the operation and tear of the DOM and then replace it.
              subviews.forEach((sv) => (sv.remove ? sv.remove() : undefined));
              subviews = vArr.map((data) => {
                const subview = _builder(data);
                let presentation =
                  subview instanceof HTMLElement ? subview : htl.html`${subview}`;
                parent.insertBefore(presentation, end);
                return subview;
              });
            } else {
              // We have to work around the limitations and try to do the operation without
              // building, so this only can work if you are setting it to something smaller
              vArr.forEach((v, i) => {
                if (i < subviews.length) {
                  subviews[i].value = v; // mutate inplace
                } else {
                  let built = _builder(v); // append additional
                  subviews[i] = built;
                  if (!(built instanceof HTMLElement)) built = htl.html`${built}`;
                  parent.appendChild(built);
                }
              });

              for (var i = subviews.length - 1; i >= vArr.length; i--) {
                // delete backwards
                const deleted = subviews.pop();
                if (deleted.remove) deleted.remove();
              }
            }
          }
        }
      });

      // Add presentation channel
      return Object.defineProperties(frag, {
        remove: {
          value: () => {
            const toRemove = [];
            for (var node = start; node !== end; node = node.nextSibling) {
              toRemove.push(node);
            }
            toRemove.push(end);
            toRemove.forEach((n) => n.remove());
          }
        },
        length: {
          get: () => subviews.length,
          enumerable: true,
          configurable: true
        },
        [Symbol.iterator]: {
          value: () => {
            let index = 0;
            return {
              next() {
                if (index < subviews.length) {
                  let val = subviews[index];
                  index++;
                  return { value: val, done: false };
                } else return { done: true };
              }
            };
          }
        },
        ...subviews.reduce((acc, sv, index) => {
          acc[index] = getIndexProperty(index);
          return acc;
        }, {})
      });
    }
  </script>
  <script id="1082" type="application/vnd.observable.javascript">
    md`length: ${numbers.length} with elements: ${numbers.join(", ")}`
  </script>
  <script id="1081" type="application/vnd.observable.javascript">
    htl.html`<div style="display: flex;">
    ${Inputs.button("reset", {
      reduce: () => {
        viewof numbers.value = [1, 2, 3, 4, 5, 6];
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}
    ${Inputs.button("delete last", {
      reduce: () => {
        numbers.splice(numbers.length - 1, 1);
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}
    ${Inputs.button("delete random", {
      reduce: () => {
        const choice = Math.random() * numbers.length;
        numbers.splice(choice, 1);
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}
    ${Inputs.button("push number", {
      reduce: () => {
        numbers.push(numbers.length + 1);
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}

    ${Inputs.button("unshift", {
      reduce: () => {
        numbers.unshift(0);
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}

    ${Inputs.button("pop", {
      reduce: () => {
        numbers.pop();
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}

    ${Inputs.button("shift", {
      reduce: () => {
        numbers.shift();
        viewof numbers.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}
    `
  </script>
  <script id="1080" type="application/vnd.observable.javascript">
    viewof numbers = view`<table>
      ${[
        "...",
        arrayView({
          value: [1, 2, 3, 4, 5, 6],
          builder: (number) =>
            view`<tr><td>${["...", Inputs.number({ value: number })]}</td></tr>`
        })
      ]}
    </table>`
  </script>
  <script id="1079" type="application/vnd.observable.javascript" pinned="">
    viewof arrayViewTests = testing.createSuite({
      name: "arrayView Tests",
      timeout_ms: 1000
    })
  </script>
  <script id="1141" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView dispatchEvent bubbles to container", (done) => {
      const av = arrayView({ builder: (v) => Inputs.input(v) });
      const container = view`<div>${av}`;
      container.addEventListener("input", () => done());
      av.dispatchEvent(new Event("input", { bubbles: true }));
    })
  </script>
  <script id="1156" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView subview events bubble to arrayView", (done) => {
      const av = arrayView({
        value: [1],
        builder: (v) => Inputs.input(v)
      });
      av.addEventListener("input", () => done());
      av[0].dispatchEvent(new Event("input", { bubbles: true }));
    })
  </script>
  <script id="1078" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView initialization (data + builder)", () => {
      const av = arrayView({
        value: [1],
        builder: (number) => Inputs.input("foo")
      });
      expect(av[0].value).toBe("foo");
      expect(av.value[0]).toBe("foo");
    })
  </script>
  <script id="1077" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView initialization (initial)", () => {
      const av = arrayView({ initial: [Inputs.input("foo")] });
      expect(av[0].value).toBe("foo");
      expect(av.value[0]).toBe("foo");
    })
  </script>
  <script id="1091" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView write element", () => {
      const av = arrayView({
        initial: [Inputs.input("foo")],
        builder: Inputs.input
      });
      expect(av[0].value).toBe("foo");
      expect(av.value[0]).toBe("foo");

      av.value[0] = "bar";

      expect(av[0].value).toBe("bar");
      expect(av.value[0]).toBe("bar");
    })
  </script>
  <script id="1076" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView splice (delete)", () => {
      const av = arrayView({ initial: [Inputs.input("foo")] });
      expect(av[0].value).toBe("foo");
      expect(av.value[0]).toBe("foo");
      expect(av.length).toBe(1);
      expect(av.value.length).toBe(1);

      av.value.splice(0, 1);

      expect(av[0]).toBe(undefined);
      expect(av.value[0]).toBe(undefined);
      expect(av.value.length).toBe(0);
      expect(av.length).toBe(0);
    })
  </script>
  <script id="1075" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView splice out of bounds (delete)", () => {
      const av = arrayView({ initial: [Inputs.input("foo")] });
      expect(av[0].value).toBe("foo");
      expect(av.value[0]).toBe("foo");
      expect(av.length).toBe(1);
      expect(av.value.length).toBe(1);

      av.value.splice(1, 1);

      expect(av[0].value).toBe("foo");
      expect(av.value[0]).toBe("foo");
      expect(av.length).toBe(1);
      expect(av.value.length).toBe(1);
    })
  </script>
  <script id="1074" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView splice (add)", () => {
      const av = arrayView({ builder: (v) => Inputs.input(v) });
      av.value.splice(0, 0, 1);
      expect(av[0].value).toBe(1);
      expect(av.value[0]).toBe(1);
    })
  </script>
  <script id="1073" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView unshift", () => {
      const av = arrayView({ builder: (v) => Inputs.input(v) });
      av.value.unshift(1);
      expect(av[0].value).toBe(1);
      expect(av.value[0]).toBe(1);
    })
  </script>
  <script id="1072" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView shift", () => {
      const av = arrayView({ value: [1], builder: (v) => Inputs.input(v) });
      av.value.shift(1);
      expect(av[0]).toBe(undefined);
      expect(av.value[0]).toBe(undefined);
    })
  </script>
  <script id="1071" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView pop", () => {
      const av = arrayView({ value: [1], builder: (v) => Inputs.input(v) });
      av.value.pop();
      expect(av[0]).toBe(undefined);
      expect(av.value[0]).toBe(undefined);
    })
  </script>
  <script id="1070" type="application/vnd.observable.javascript" pinned="">
    arrayViewTests.test("arrayView push", () => {
      const av = arrayView({ builder: (v) => Inputs.input(v) });
      av.value.push(1);
      expect(av[0].value).toBe(1);
      expect(av.value[0]).toBe(1);
    })
  </script>
  <script id="1069" type="text/markdown">
    ## [Optional] Tests
  </script>
  <script id="989" type="application/vnd.observable.javascript">
    RUN_TESTS = true // htl.html`<a href="">`.href.includes("@tomlarkworthy/view")
  </script>
  <script id="985" type="application/vnd.observable.javascript">
    testing = {
      if (!RUN_TESTS) return invalidation;
      const [{ Runtime }, { default: define }] = await Promise.all([
        import(
          "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js"
        ),
        import(`https://api.observablehq.com/@tomlarkworthy/testing.js?v=3`)
      ]);
      const module = new Runtime().module(define);
      return Object.fromEntries(
        await Promise.all(
          ["expect", "createSuite"].map((n) => module.value(n).then((v) => [n, v]))
        )
      );
    }
  </script>
  <script id="484" type="application/vnd.observable.javascript">
    viewof suite = testing.createSuite({
      name: "Unit Tests",
      timeout_ms: 1000
    })
  </script>
  <script id="984" type="application/vnd.observable.javascript">
    expect = testing.expect
  </script>
  <script id="676" type="application/vnd.observable.javascript" pinned="">
    suite.test("Singleton spread reads from delagate", async () => {
      const v = view`<div>${["...", variable(1)]}`;
      expect(v.value).toEqual(1);
    })
  </script>
  <script id="677" type="application/vnd.observable.javascript" pinned="">
    suite.test("Singleton spread write propagates", async () => {
      const delegate = variable();
      const v = view`<div>${["...", delegate]}`;
      v.value = 4;
      expect(delegate.value).toEqual(4);
    })
  </script>
  <script id="696" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Singleton events propagate from container to inner singleton",
      async (done) => {
        const delegate = variable();
        delegate.addEventListener("input", (evt) => {
          done();
        });
        const v = view`<div>${["...", delegate]}`;
        v.dispatchEvent(new Event("input"));
      }
    )
  </script>
  <script id="772" type="application/vnd.observable.javascript" pinned="">
    suite.test("Hidden write propagates upstream", async () => {
      const delegate = variable();
      const v = view`<div>${["_hidden", delegate]}`;
      v.hidden.value = 4;
      expect(delegate.value).toEqual(4);
    })
  </script>
  <script id="774" type="application/vnd.observable.javascript" pinned="">
    suite.test("Hidden events propogate to self", async (done) => {
      const delegate = variable();
      const v = view`<div>${["_hidden", delegate]}`;
      v.addEventListener("input", (evt) => {
        done();
      });
      delegate.dispatchEvent(new Event("input"));
    })
  </script>
  <script id="796" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Hidden object collection member events propogate to self",
      async (done) => {
        const delegate = variable();
        const v = view`<div>${["_...", { a: delegate }]}`;
        v.addEventListener("input", (evt) => {
          done();
        });
        delegate.dispatchEvent(new Event("input"));
      }
    )
  </script>
  <script id="1064" type="application/vnd.observable.javascript" pinned="">
    suite.test("Nested write on arrayView replaces presentation", async () => {
      const v = view`<div>${["array", [html`<input id=nwoa1 value="foo">`]]}`;
      expect(v.querySelector("#nwoa1")).not.toBe(null);
      expect(v.querySelector("#nwoa2")).toBe(null);
      expect(v.array.value).toEqual(["foo"]);

      v.array = [html`<input id=nwoa2 value="fum">`];
      expect(v.querySelector("#nwoa1")).toBe(null);
      expect(v.querySelector("#nwoa2")).not.toBe(null);
      expect(v.array.value).toEqual(["fum"]);
    })
  </script>
  <script id="479" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Composite write spreads to array subproperty (deletion)",
      async () => {
        const v = view`<div>${["array", [Inputs.input()]]}`;
        v.value = { array: [] };
        expect([...v.array]).toEqual([]);
        expect(v.value.array).toEqual([]);
      }
    )
  </script>
  <script id="495" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Composite write spreads to array subproperty (addition) (via destructuring assignment)",
      async () => {
        const v = view`<div>${["array", [Inputs.input()], (v) => Inputs.input(v)]}`;
        v.value = { array: [1, 2] };
        expect(v.value.array).toEqual([1, 2]);
        expect(v.array).toContainEqual(Inputs.input(1));
        expect(v.array).toContainEqual(Inputs.input(2));
      }
    )
  </script>
  <script id="806" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Composite write spreads to array subproperty (addition) (via view.value assignment)",
      async () => {
        const v = view`<div>${["array", [Inputs.input()], (v) => Inputs.input(v)]}`;
        v.array.value = [1, 2]; // Should work but doesn't, we need some kind of ArrayView type
        expect(v.value.array).toEqual([1, 2]);
        expect(v.array).toContainEqual(Inputs.input(1));
        expect(v.array).toContainEqual(Inputs.input(2));
      }
    )
  </script>
  <script id="811" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Composite write spreads to array subproperty (addition) (via data assignment)",
      async () => {
        const v = view`<div>${["array", [Inputs.input()], (v) => Inputs.input(v)]}`;
        v.value.array = [1, 2];
        expect(v.value.array).toEqual([1, 2]);
        expect(v.array).toContainEqual(Inputs.input(1));
        expect(v.array).toContainEqual(Inputs.input(2));
      }
    )
  </script>
  <script id="498" type="application/vnd.observable.javascript" pinned="">
    suite.test("Array get", async () => {
      const v = view`<div>${["array", [Inputs.input(1)]]}`;
      expect(v.value.array).toEqual([1]);
      expect(v.array[0]).toEqual(Inputs.input(1));
      expect([...v.array]).toEqual([Inputs.input(1)]);
    })
  </script>
  <script id="500" type="application/vnd.observable.javascript" pinned="">
    suite.test("Array write with builder creates new elements", async () => {
      const v = view`<div>${["array", [Inputs.input()], (v) => Inputs.input(v)]}`;
      v.value.array = [1, 2];
      expect(v.value.array).toEqual([1, 2]);
      expect(v.array).toContainEqual(Inputs.input(1));
      expect(v.array).toContainEqual(Inputs.input(2));
    })
  </script>
  <script id="502" type="application/vnd.observable.javascript" pinned="">
    suite.test("Array write remove elements", async () => {
      const v = view`<div>${["array", [Inputs.input(0), Inputs.input(2)]]}`;
      v.value.array = [1];
      expect(v.value.array).toEqual([1]);
      expect(v.array).toContainEqual(Inputs.input(1));
    })
  </script>
  <script id="1057" type="application/vnd.observable.javascript" pinned="">
    suite.test("Array in-place splice support (delete), no builder", async () => {
      const v = view`<div>${["array", [Inputs.input(0), Inputs.input(2)]]}`;
      v.value.array.splice(0, 1);
      expect(v.value.array).toEqual([2]);
    })
  </script>
  <script id="1056" type="application/vnd.observable.javascript" pinned="">
    suite.test("Array in-place splice support (delete), with builder", async () => {
      const v = view`<div>${[
        "array",
        [Inputs.input(0), Inputs.input(2)],
        (v) => Inputs.input(v)
      ]}`;
      v.value.array.splice(0, 1);
      expect(v.value.array).toEqual([2]);
    })
  </script>
  <script id="1055" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Array in-place splice support (addition) with builder",
      async () => {
        const v = view`<div>${[
          "array",
          [Inputs.input(0)],
          (v) => Inputs.input(v)
        ]}`;
        v.value.array.splice(1, 0, 1);
        expect(v.value.array).toEqual([0, 1]);
        expect([...v.array]).toEqual([Inputs.input(0), Inputs.input(1)]);
      }
    )
  </script>
  <script id="504" type="application/vnd.observable.javascript" pinned="">
    suite.test("Dynamic Object value property assignment", async () => {
      const v = view`<div>${["field", Inputs.input()]}`;
      v.value = { field: 1 };
      expect(v.field.value).toEqual(1);
      expect(v.value.field).toEqual(1);
    })
  </script>
  <script id="1053" type="application/vnd.observable.javascript" pinned="">
    suite.test("Dynamic Object view property assignment", async () => {
      const v = view`<div>${["field", Inputs.input()]}`;
      v.field = Inputs.input("2");
      expect(v.field.value).toEqual("2");
      expect(v.value.field).toEqual("2");
    })
  </script>
  <script id="948" type="application/vnd.observable.javascript" pinned="">
    suite.test(
      "Dynamic Object write with builder creates new elements",
      async () => {
        const v = view`<div>${["...", {}, (v) => Inputs.text({ value: v })]}`;
        v.value = { a: "b" };
        expect(v.value).toEqual({ a: "b" });
        expect(v.a).toHaveProperty("name"); // It's a DOM node
      }
    )
  </script>
  <script id="970" type="application/vnd.observable.javascript" pinned="">
    suite.test("Dynamic Object write deletes old elements", async () => {
      const v = view`<div>${["...", { a: Inputs.text() }]}`;
      expect(v.value).toEqual({ a: "" });
      expect(v.a).toHaveProperty("name"); // It's a DOM node
      v.value = {};
      expect(v.value).toEqual({});
      expect(v.a).toBeUndefined();
    })
  </script>
  <script id="780" type="application/vnd.observable.javascript" pinned="">
    suite.test("Collection object creates matching keys", async () => {
      const v = view`<div>${[
        "...",
        {
          a: Inputs.input()
        }
      ]}`;
      expect(v.value).toHaveProperty("a");
    })
  </script>
  <script id="508" type="application/vnd.observable.javascript">
    toc = {
      const [{ Runtime }, { default: define }] = await Promise.all([
        import(
          "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js"
        ),
        import(`https://api.observablehq.com/@nebrius/indented-toc.js?v=3`)
      ]);
      const module = new Runtime().module(define);
      return module.value("toc");
    }
  </script>
  <script id="1030" type="application/vnd.observable.javascript">
    //import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="1035" type="application/vnd.observable.javascript">
    //footer
  </script>
  <script id="1203" type="application/vnd.observable.javascript" pinned="">
    import { exporter } from "@tomlarkworthy/exporter"
  </script>
  <script id="1207" type="application/vnd.observable.javascript" pinned="">
    exporter()
  </script>
</notebook>
