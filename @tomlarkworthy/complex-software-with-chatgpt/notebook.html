<!doctype html>
<notebook theme="air">
  <title>Experiments in Complex Software development with ChatGPT</title>
  <script id="0" type="text/markdown">
    # Experiments in Complex Software development with ChatGPT

    ChatGPT can be used to accelerate development but it doesn't seem possible with our current IDE UX. I challenged myself to write a _full_ featured game end-to-end with ChatGPT to test a new workflow of interleaved prompting and program execution. It mostly worked, there were challenges, I reach 600 lines of code per day, and found several places for further process improvements.

  </script>
  <script id="4475" type="application/vnd.observable.javascript">
    isSafari
      ? md`⚠️ The following is the game, however, it uses SVG transforms and runs like a pig on iPhone/Safari so it's been disabled on your device.`
      : md`The following is the game, click on it and press space to start`
  </script>
  <script id="3948" type="application/vnd.observable.javascript">
    viewof game = {
      ({
        prompt:
          "I have an image element called backdrop. I would like it to be the background, and the view and start button to be absolutely placed on top. Call the cell game ",
        time: 1701104418893,
        comment:
          "Create a cell to layout the background image, view, and start button"
      });

      const view = positionView;
      const startButton = positionStartButton;

      const game = htl.html`<div style="position: relative; width: 100%; height: 100%;">
        ${backdrop}
        <div style="
            position: absolute;
            top: ${positionView.y * 50 + 50}%;
            left: ${positionView.x * 50 + 50}%;
            width: ${positionView.width * 50 + 50}%;
            height: ${positionView.height * 50 + 50}%;">
          ${game_view}
        </div>
        <div style="
            position: absolute;
            top: ${positionStartButton.y}%;
            left: ${positionStartButton.x}%;
            width: ${positionStartButton.width}%;
            height: ${positionStartButton.height}%;">
          ${startButton}
        </div>
      </div>`;

      return game;
    }
  </script>
  <script id="4840" type="text/markdown">
    ## A game is an analogue for complex software

    I am not actually interested in game programming. I am using a game as an analogue for _"complex software"_. Previously, I have struggled with getting LLMs to scale to hard programming tasks. I hypothesise that it's a UX issues, so I have been working on an alternative programming model using materialised LLM context in computational notebooks ([roboco-op](https://observablehq.com/@tomlarkworthy/robocoop)). I needed a programming grand challenge to test the approach, and this is the article that summarises the results of that challenge.

    I wanted to explore all the random things a real program contains, so I aimed to implement all the ingredients of a real game: score, lives, enemies, graphics, audio and art. Of course, if I wanted to build a real game the best use of time would be to use a game making framework, but in general there are not always frameworks for every type of software that you want built. Thus I made this game "from scratch" using web technologies only, the graphics, for example, are just SVGs, but using all the advanced options available (SVG filters to provide blur, displacement filters to fit the boxing, Web Audio API etc.).

    So programming a game is hopefully transferable to achieving state-of-the-art results in other programming domains. Can LLM coding scale?
  </script>
  <script id="4488" type="text/markdown">
    ## Notebooks

    This game was incrementally built across a series of notebook.

    - Part I - Ideation and Architecture https://observablehq.com/d/b497b79c94d3fbd1
    - Part II - Pixels on a Screen https://observablehq.com/d/8571aa583512f2a4
    - Part III - UI All the things https://observablehq.com/d/1ec7e3f612d70414
    - Part IV - Enemies https://observablehq.com/d/fbab829d5bcdd7e2
    - Part V - (failed) Refactoring https://observablehq.com/d/025ff03d865684e9
    - Part VI - Polish https://observablehq.com/d/ef7ccf2e0ed653d1
    - Part VII - Boxing https://observablehq.com/d/49b1dd226a242821
    - Part VIIb - Displacement map Deepdive https://observablehq.com/@tomlarkworthy/make-a-game-part-viib-filter-sidequest
    - Part VIII - Audio https://observablehq.com/d/5cc90faa3b651500
    - Conclusion - https://observablehq.com/@tomlarkworthy/complex-software-with-chatgpt
  </script>
  <script id="4818" type="text/markdown">
    ## How long did it take?

    We can query the notebook history to get development statistics.

    ${Math.ceil(d3.sum(time_spent_hours, d => d. time_spent_hours))} hours total spent in spare time over 3 weeks. You can see I put in a sliver of time before work on weekdays, a big chunk after work, and the odd weekend day, so there was quite a lot of context switching.
  </script>
  <script id="4530" type="application/vnd.observable.javascript">
    events = data
      .reduce(
        (acc, data) => [
          ...acc,
          ...data.history.events.map((e) => ({ ...e, notebook: data.title }))
        ],
        []
      )
      .map((d) => ({
        ...d,
        ...enrich_time(d.time)
      }))
      .filter((d) => !["create"].includes(d.type))
      .filter((d) => d.node_id !== 0)
      .sort((a, b) => a.time - b.time)
  </script>
  <script id="4587" type="application/vnd.observable.javascript">
    time_spans = events
      .reduce((acc, d, index) => {
        if (index == 0) {
          acc.push({
            ...d,
            start: new Date(d.time.getTime()),
            ...enrich_time(d.time)
          });
        } else if (
          events[index - 1].time.getTime() + 30 * 60 * 1000 < d.time.getTime() ||
          events[index - 1].notebook !== d.notebook
        ) {
          acc[acc.length - 1].end = new Date(events[index - 1].time.getTime());
          acc.push({
            ...d,
            start: new Date(d.time.getTime()),
            ...enrich_time(d.time)
          });
        }
        if (index == events.length - 1) {
          acc[acc.length - 1].end = new Date(d.time.getTime());
        }

        acc[acc.length - 1].min_node_id = Math.min(
          d.node_id,
          acc[acc.length - 1].min_node_id || d.node_id
        );
        acc[acc.length - 1].max_node_id = Math.max(
          d.node_id,
          acc[acc.length - 1].max_node_id || d.node_id
        );
        return acc;
      }, [])
      .map((data) => ({ ...data, ...enrich_time(data.end, "end_") }))
      .flatMap((data) => {
        if (data.start.getHours() > data.end.getHours()) {
          const boundary = new Date(data.end);
          boundary.setHours(0);
          boundary.setMinutes(0);
          boundary.setSeconds(0);
          boundary.setMilliseconds(0);
          new Date(data.end);
          return [
            {
              ...data,
              end: boundary,
              ...enrich_time(boundary, "end_"),
              end_minute: 24
            },
            {
              ...data,
              start: boundary,
              ...enrich_time(boundary),
              end: data.end
            }
          ];
        } else {
          return data;
        }
      })
  </script>
  <script id="4622" type="application/vnd.observable.javascript">
    Plot.plot({
      x: {
        type: "time"
      },
      color: { legend: true },
      marks: [
        Plot.rect(time_spans, {
          x1: (d) => new Date(d.date).getTime() - 60 * 60 * 8 * 1000,
          x2: (d) => new Date(d.date).getTime() + 60 * 60 * 8 * 1000,
          y1: "minute",
          y2: "end_minute",
          stroke: "notebook",
          tip: true
        })
      ]
    })
  </script>
  <script id="4833" type="text/markdown">
    Most notebooks took about 3 hours to build. But significant work work was put in for the polish and boxing notebook which had a high degree of graphics programming. Part VII contained a complex SVG displacement map to give non-linearly warp the image into the display. This task was hard and I had to fork a separate notebook (VIIb) to focus on that specific problem.
  </script>
  <script id="4800" type="application/vnd.observable.javascript">
    time_spent_hours = Object.entries(
      time_spans.reduce((sums, span) => {
        sums[span.notebook] =
          (sums[span.notebook] || 0) +
          (span.end.getTime() - span.start.getTime()) / 1000 / 60 / 60;
        return sums;
      }, {})
    ).map(([notebook, time_spent_hours]) => ({
      notebook,
      time_spent_hours
    }))
  </script>
  <script id="4806" type="module">

  </script>
  <script id="4867" type="text/markdown">
    ## Effective Human-in-the-loop Collaboration with LLMs

    The main hypothesis driving this work, is that human experts and LLMs are good at different things, and to make the expert better we need a way for the two to effectively collaborate. For instance, LLMs are not good at producing correct programs, strategising solution execution or aesthetics. However, they are good at boiler-plate, have a large pool of general knowledge, are fast at switching gears and can adapt quickly in-context. A human expert is very often faster at an LLM at debugging, but an LLM is faster at generating a reasonable approach to a program.

    [Roboco-op](https://observablehq.com/@tomlarkworthy/robocoop) tries to reconcile these different strengths by using a computational notebook as the collaboration medium. Notebooks have the advantage of dividing a large program into smaller chunks that can be iterated on independently. This is perfect for an LLM to try something out and a human to improve upon it. LLM programming mistakes are quickly identified by the computational medium itself and the human can choose whether to fix it themselves, or ask the LLM to fix it. For minor syntax mistakes, the human can edit the cell, for major approach mistakes, a re-prompt with added context might be quicker. A human expert is in control of the overall evolution of the program.

    Critical for LLMs performance is the context.  [Roboco-op](https://observablehq.com/@tomlarkworthy/robocoop) uses the notebook cells to generate the context. This means, human corrected cells are the truth. And the human is able to prune context simply by removing cells. This also implies forking a notebook forks the context. During development we used forks to delimitate major phases in development, and deleted all irrelevant cells before moving to the next phase. For instance, part I spends a significant proportion of the notebook dedicated to ideating and designing an Entity Component System, however, in part II, all that design work had been deleted because we now had a working and used ECS system and so the early ideas ware no longer helping the LLM writing code.

  </script>
  <script id="5050" type="text/markdown">
    ### Cell modifications over time

    In the plot below we visualize the cell node_id, which increments as cells are added, against time. We see that new cells are added over time, and cells are often deleted after a fork, which demonstrates context cleanup.

    We see a huge number of cells deleted for part VIIb, when the whole game was removed so we could concentrate in development of a specific filter. We also see a major set of deletions going into part II, when the design work was removed. We also see that notebook III nodes with a low node_id were modified. This was back-porting some roboco-op bugfixes. The first notebook in the series, part I, was forked from the roboco-op blank slate notebook, and thus only nodes with an id greater than 2200 were project specific.
  </script>
  <script id="4940" type="application/vnd.observable.javascript">
    filtered_events = events
      .filter((d) => ["modify_node", "remove_node"].includes(d.type))
      .map((d) => ({ ...d, type: d.is_new ? "new_node" : d.type }))
  </script>
  <script id="4962" type="application/vnd.observable.javascript">
    Plot.plot({
      x: {
        type: "time",
        domain: ["2023-11-12", "2023-12-04"]
      },
      symbol: { legend: true },
      marks: [
        Plot.dot(filtered_events, {
          x: "date",
          y: "node_id",
          stroke: "type",
          symbol: "type",
          tip: true
        }),
        Plot.rectY(time_spans, {
          x1: (d) => new Date(d.date).getTime() - 60 * 60 * 8 * 1000,
          x2: (d) => new Date(d.date).getTime() + 60 * 60 * 8 * 1000,
          y1: "min_node_id",
          y2: "max_node_id",
          stroke: "notebook",
          tip: true
        })
      ]
    })
  </script>
  <script id="4929" type="text/markdown">

    Direct manipulation of the LLM context through normal notebook operations is a major workflow improvement. You can scrub development scaffolding noise and keep the context small with high signal-to-noise ratio. Because LLMs also learn in-context, I found the LLM climbed levels of abstraction as the project went on.

    In Part II, our prompts were quite technical and low level, for example, our early [physics system](https://observablehq.com/d/8571aa583512f2a4#PhysicsSystem) was

    ```
    "Write a PhysicsSystem that extends deps.resolve("BaseSystem") with a tick function
    that moves everyone\'s position: [number, number] based on velocity,
    and alters velocity based on forces (and resets force)"
    ``` 


    But through in-context learning, by part IV we could prompt in high level game development language, for example the [bullet intersection system](https://observablehq.com/d/fbab829d5bcdd7e2#PlayerBulletHitSystem) was:-

    ```
    "Add a system for checking when a player bullet overlaps an enemy ship the ship should be destroyed."
    ```

    Because working code becomes part of the context, the LLM evolves to fit the working idioms of the project. Because a human is fixing code as the project evolves, so its context is filled with working examples and thus its ability to one-shot working code increases over time. 

  </script>
  <script id="5078" type="text/markdown">
    ## Human vs. LLM work

    As the workflow supports human editing, how much did the LLM do vs. the human?
  </script>
  <script id="5359" type="text/markdown">
    ### Number of edits per named cell

    Typically the LLM first generates a cell, and a human edits it. We can get a ballpark figure for how much human editing is needed was needed by looking at the number of edits to each named cell.

    Some cells were never edited after initial generation (edits: 1), but some cells cells, like `crtWarpDisplacementMap_v4` were iterated heavily (141 edits).
  </script>
  <script id="5157" type="application/vnd.observable.javascript">
    named_cell_work = filtered_events.filter((d) => d.node_name !== undefined)
  </script>
  <script id="5153" type="module">

  </script>
  <script id="5549" type="text/markdown">
    ## Where the LLM was not so good
  </script>
  <script id="5364" type="text/markdown">
    ### The `crtWarpDisplacementMap_v4` saga

    The most edited cell was [`crtWarpDisplacementMap_v4`](https://observablehq.com/@tomlarkworthy/make-a-game-part-viib-filter-sidequest#crtWarpDisplacementMap_v5) which represents the cell that the LLM was least helpful with.

  </script>
  <script id="3985" type="application/vnd.observable.javascript">
    viewof crtWarpAdjustment = {
      ({
        prompt:
          "So the CRT display backdrop is barrel warped, and a bit trapazoidal. We need another filter to apply a similar distortion. Create a UI for adjusting barrel warp and trapazoid parameters",
        time: 1701199826611,
        comment:
          "Create a UI for adjusting CRT display barrel warp and trapezoid parameters"
      });

      const crtWarpSettings = view`<div>
        <h2>CRT Warp Adjustment</h2>
        ${[
          "barrel_warp",
          Inputs.range([-1024, 1024], {
            value: 1024,
            step: 0.01,
            label: "Barrel Warp"
          })
        ]}
        ${[
          "trapezoid_warp",
          Inputs.range([-1, 1], {
            value: 0,
            step: 0.01,
            label: "Trapezoid Warp"
          })
        ]}
        ${[
          "warp_scale",
          Inputs.range([0, 100], {
            value: 2,
            step: 0.01,
            label: "Scale"
          })
        ]}
        ${[
          "displacement_size",
          Inputs.range([0, 1024], {
            value: 16,
            step: 0.01,
            label: "Size"
          })
        ]}
      </div>`;

      return crtWarpSettings;
    }
  </script>
  <script id="3991" type="application/vnd.observable.javascript">
    CRTWarpFilterSystem = {
      ({
        prompt:
          "Now create a component that uses crtWarpAdjustment settings to create/replace an appropriate filter into the view SVG defs",
        time: 1701199921023,
        comment: "Create a component to generate CRT warp filter using settings"
      });

      const defs = game_view.querySelector("defs") || htl.svg`<defs>`;

      const crtWarpFilter = deps.resolve("crtWarpFilter")(crtWarpAdjustment);

      // Replace or append the new filter to the defs
      const existingFilter = defs.querySelector(`#crt-warp`);
      if (existingFilter) {
        existingFilter.replaceWith(crtWarpFilter);
      } else {
        defs.appendChild(crtWarpFilter);
      }

      if (!game_view.querySelector("defs")) {
        game_view.prepend(defs);
      }
    }
  </script>
  <script id="4064" type="application/vnd.observable.javascript">
    html`<h4>crtWarpDisplacementMap</h4><img src=${deps.resolve(
      "crtWarpDisplacementMap"
    )}>`
  </script>
  <script id="4095" type="application/vnd.observable.javascript">
    warpImageTest = {
      ({
        prompt:
          "I can;t tell if the warp image generator works, can you draw a checkboard with SVG with the filter applied to test it",
        time: 1701293709944,
        comment:
          "Create a checkerboard SVG with CRT warp filter applied to test the warp image generator"
      });

      const warpFilter = deps.resolve("crtWarpFilter")(0, 0); // Applying moderate barrel warp for test
      const warpMapImage = deps.resolve("crtWarpDisplacementMap");

      const checkerboard = htl.svg`<svg width="200" height="200" viewBox="-1 -1 2 2">
        <defs>
          <pattern id="checkerboard" patternUnits="userSpaceOnUse" width="0.2" height="0.2">
            <rect width="0.1" height="0.1" />
            <rect x="0.1" y="0.1" width="0.1" height="0.1" fill="black" />
          </pattern>
          ${warpFilter}
        </defs>
        <rect x="-1" y="-1" width="1" height="1" fill="red" filter="url(#crt-warp)" />
        <rect x="-1" y="-1" width="2" height="2" fill="url(#checkerboard)" filter="url(#crt-warp)" />
      </svg>`;

      return checkerboard;
    }
  </script>
  <script id="4091" type="application/vnd.observable.javascript">
    crtWarpAdjustmentGenerator_v3 = ({
      prompt:
        "OK make a new crtWarpAdjustmentGenerator that uses the displacement map",
      time: 1701292141453,
      comment: "Generate CRT warp adjustment filter using the displacement map"
    } &&
      deps.register(
        "crtWarpFilter",
        function crtWarpAdjustmentGenerator(barrel_warp, trapezoid_warp) {
          const warpMapImage = deps.resolve("crtWarpDisplacementMap");
          const filter = htl.svg`<filter id="crt-warp" x="0" y="0" width="1" height="1"  color-interpolation-filters="sRGB">
        <feImage href="${warpMapImage}" result="warpMap" />
        <feDisplacementMap in="SourceGraphic" in2="warpMap" scale="${crtWarpAdjustment.warp_scale}" xChannelSelector="R" yChannelSelector="G" />
      </filter>`;
          return filter;
        },
        3
      ))
  </script>
  <script id="4235" type="application/vnd.observable.javascript" pinned="">
    crtWarpDisplacementMap_v5 = {
      ({
        prompt:
          "Maybe barrel distortion is not the right term. I want the corners pulled in. So displacements far from the center should be deflected towards the center",
        time: 1701296188546,
        comment:
          "Generate displacement map for CRT warp effect with corners pulled towards the center"
      });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = canvas.height = crtWarpAdjustment.displacement_size; // Use a power of 2 for better texture performance

      // Draw the displacement map
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const warpEffect = crtWarpAdjustment.barrel_warp;
      for (let index = 0; index < data.length; index += 4) {
        const x = (index / 4) % canvas.width;
        const y = index / 4 / canvas.width;
        const dy = y / (canvas.height * 1.0) - 0.5;
        let dx = x / (canvas.width * 1.0) - 0.5;

        const distance2 = dx * dx + dy * dy;
        data[index] = 127.5 + dx * distance2 * distance2 * warpEffect; // Red channel for X displacement
        data[index + 1] = 127.5 + dy * distance2 * distance2 * warpEffect; // Green channel for Y displacement
        data[index + 2] = 127; // Blue channel not used
        data[index + 3] = 127; // Alpha channel
      }
      ctx.putImageData(imageData, 0, 0);

      // Convert canvas to an image blob
      const warp = await new Promise((resolve) => {
        canvas.toBlob((blob) => {
          resolve(URL.createObjectURL(blob));
        });
      });

      deps.register("crtWarpDisplacementMap", warp, 4);

      return warp;
    }
  </script>
  <script id="6020" type="text/markdown">


    The purpose of this cell and its supporting cells was to figure out non-linear distortion of the image plane to fit the game view into a warped CRT backdrop.

    The LLM was totally unable to solve this task. Getting stuck on this task was the motivation for forking part VIIb. The LLM kept making a common beginner mistakes with image manipulation. It made the classic mistake of generating a displacement map by first iterating the source pixels, calculating a displacement and then writing those values into the destination image. The major problem with this strategy is the the destination image will have areas with no values, as there is no reason every source pixel will map to every destination pixel.

    The correct approach is to iterate the destination pixels, calculate the *reverse* displacement, and sample from the source image. It took me quite a while to figure out what the problem was, and ultimately I coded the core algorithm myself. 

    The LLM was quite helpful in setting up the environment for success though. It built the scaffolding used to solve the task. For example, the preview, checkerboard pattern and reactive UI to fiddle with artistic parameters, *were* coded by the LLM.
  </script>
  <script id="5410" type="text/markdown">
    ### Other heavily iterated nodes

    #### Art
    `ship_template_v3`, `enemy_ship_template_v4`, `neonGlowFilterGenerator` also were hand edited a lot. The templates are SVG files, where it was simpler for me to edit the coordinates that go through LLM prompting. Ultimately that kind of work is a bad fit for coding anyway, you should create art assets in an art program, not in code.
    features to it manually. While I edited these cells a lot, it was mostly trivial parameter tweaks.
  </script>
  <script id="3218" type="application/vnd.observable.javascript" pinned="">
    viewof enemy_ship_template_v4 = {
      ({
        prompt:
          "OK I like the latest ship, can we make the center elipse spin around 360 with an SVG animation. Do not add or remove controls, or change values, other than than add spin speed UI",
        time: 1700598322777,
        comment:
          "Add spin speed UI and implement SVG animation for the center ellipse of the enemy ship"
      });
      const enemyShipSettings = view`<div>
        <h2>Enemy Ship Settings</h2>
        ${["scale", Inputs.range([0.05, 5], { value: 0.75, label: "Scale" })]}
        ${["width", Inputs.range([0.1, 2], { value: 0.5, label: "Width" })]}
        ${["height", Inputs.range([0.05, 1], { value: 0.1, label: "Height" })]}
        ${["color", Inputs.color({ value: "#000000", label: "Color" })]}
        ${[
          "stroke_width",
          Inputs.range([0, 0.05], { value: 0.018, label: "Stroke width" })
        ]}
        ${[
          "stroke_color",
          Inputs.color({ value: "#46ff2e", label: "Stroke color" })
        ]}
        ${[
          "center_ellipse_width",
          Inputs.range([0, 1], { value: 0.15, label: "Center ellipse width" })
        ]}
        ${[
          "center_ellipse_height",
          Inputs.range([0, 1], { value: 0.2, label: "Center ellipse height" })
        ]}
        ${[
          "spin_speed",
          Inputs.range([0, 10000], {
            value: 400,
            step: 100,
            label: "Spin speed (ms for full rotation)"
          })
        ]}
      </div>`;

      const updateEnemyShipTemplate = () => {
        const settings = enemyShipSettings.value;
        const centerEllipse = htl.svg`<ellipse cx="0" cy="0" stroke="${
          settings.stroke_color
        }" stroke-width="${settings.stroke_width * settings.scale}" rx="${
          (settings.center_ellipse_width / 2) * settings.scale
        }" ry="${(settings.center_ellipse_height * settings.scale) / 2}" fill="${
          settings.color
        }">
          <animateTransform attributeName="transform" type="rotate" from="0 0 0" to="360 0 0" dur="${
            settings.spin_speed
          }ms" repeatCount="indefinite"/>
        </ellipse>`;
        const enemyShip = htl.svg`<ellipse cx="0" cy="0" rx="${
          (settings.width / 2) * settings.scale
        }" ry="${(settings.height / 2) * settings.scale}" stroke="${
          settings.stroke_color
        }" stroke-width="${settings.stroke_width * settings.scale}" />
          ${centerEllipse}`;
        assets.set("enemyShip", enemyShip);
        return enemyShip;
      };

      // Preview enemy ship template
      const preview = htl.svg`<svg width="100" height="100" viewBox="-0.4 -0.4 .8 .8" style="background: black;">${updateEnemyShipTemplate()}</svg>`;

      enemyShipSettings.addEventListener("input", () => {
        updateEnemyShipTemplate();
        preview.replaceChild(assets.get("enemyShip"), preview.firstChild);
      });

      return htl.html`${enemyShipSettings}${preview}`;
    }
  </script>
  <script id="6077" type="text/markdown">

    #### Game Controls

    `PlayerControl_vX` were the keyboard controls for the game. These sources were easier to iterate by hand as it requires fast feedback to converge on a solution, and it is easier to try things out and refine, than to try to explain the subjective input device experience to the LLM. LLMs don't really understand the link between the controls and the experience of the game. It did code the UI.

  </script>
  <script id="6260" type="application/vnd.observable.javascript" pinned="">
    viewof PlayerControl_v6 = {
      ({
        prompt:
          "Can we make a new version of keyboard controls that includes a UI for changing the values",
        time: 1700398068677,
        comment: "New version of PlayerControl with UI for changing control values"
      });

      const controlSettings = view`<div>
        <h2>Player Control Settings</h2>
        ${[
          "rotation_speed",
          Inputs.range([0.01, 0.1], {
            value: 0.03,
            step: 0.01,
            label: "Adjust rotation speed"
          })
        ]}
        ${[
          "thrust",
          Inputs.range([0.0001, 0.001], {
            value: 0.0004,
            step: 0.00005,
            label: "Adjust thrust"
          })
        ]}
        ${[
          "bullet_speed",
          Inputs.range([0, 1], {
            value: 0.02,
            step: 0.00005,
            label: "Bullet speed"
          })
        ]}
        ${[
          "bullet_ttl",
          Inputs.range([0, 500], {
            value: 80,
            step: 1,
            label: "Bullet ttl"
          })
        ]}
      </div>`;

      class PlayerControl extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          this.controlSettings = controlSettings.value;
          const player = entities.get("player");
          if (!player) return;
          if (keysPressed["ArrowLeft"]) {
            player.velocity[2] = -this.controlSettings.rotation_speed;
          }
          if (keysPressed["ArrowRight"]) {
            player.velocity[2] = this.controlSettings.rotation_speed;
          }
          if (!keysPressed["ArrowRight"] && !keysPressed["ArrowLeft"]) {
            player.velocity[2] = 0;
          }
          if (keysPressed["ArrowUp"]) {
            const rotation = player.position[2];
            player.velocity[0] += Math.cos(rotation) * this.controlSettings.thrust;
            player.velocity[1] += Math.sin(rotation) * this.controlSettings.thrust;
          }
          if (keysPressed["ArrowDown"]) {
            const rotation = player.position[2];
            player.velocity[0] -= Math.cos(rotation) * this.controlSettings.thrust;
            player.velocity[1] -= Math.sin(rotation) * this.controlSettings.thrust;
          }

          if (keysPressed[" "]) {
            keysPressed[" "] = false;
            const rotation = player.position[2];
            const bulletVelocity = [
              Math.cos(rotation) * this.controlSettings.bullet_speed +
                player.velocity[0],
              Math.sin(rotation) * this.controlSettings.bullet_speed +
                player.velocity[1],
              0
            ];
            const projectile = {
              id: `p${Date.now()}`,
              template: "projectile",
              position: [...player.position],
              velocity: bulletVelocity,
              ttl: this.controlSettings.bullet_ttl
            };
            entities.set(projectile.id, projectile);
          }
        }
      }

      deps.register("PlayerControl", new PlayerControl(), 6);

      return controlSettings;
    }
  </script>
  <script id="6227" type="text/markdown">


    #### Coupled Components - Renderer System

    The LLM was actually quite adept with developing the rendering system, the part that iterates all the entities and syncs the representation to an SVG DOM node. However, this component is coupled to many features of the game, and thus often needed to be upgraded to accommodate new features. I found re-prompting the LLM would often forget important changes between iteration, so a new Rendering System would often be faulty with the same set of bugs as were fixed in the prior version. So in the end I converged towards adding features manually.
  </script>
  <script id="3127" type="application/vnd.observable.javascript" pinned="">
    RendererSystem_v5 = {
      ({
        prompt:
          "Our render system should use the generator and generator args  if available",
        time: 1700507770128,
        comment: "Update RendererSystem to use generator function if available"
      });

      class RendererSystem extends deps.resolve("BaseSystem") {
        constructor(...args) {
          super(...args);
          this.game_view = deps.resolve("game_view");
          this.assetVersions = new Map();
          this.boulderGenerator = deps.resolve("boulder_generator");
          this.boulderGeneratorArgs = deps.resolve("boulder_generator_args");
        }

        tick() {
          const assets = deps.resolve("Assets");
          const unfiltered = this.game_view.querySelector(`#unfiltered`);
          const root = this.game_view.querySelector(`#game-root`);
          for (let [id, entity] of entities) {
            if (!entity.position) return;

            // Set attributes or create transform if needed
            let transform = this.game_view.querySelector(`g[id=${id}]`);
            let generator = deps.resolve(entity.generator);
            let template = assets.get(entity.template);
            if (
              !transform ||
              transform.generator !== generator ||
              transform.template !== template
            ) {
              let svgElement;
              if (generator && entity.generator_args) {
                // Use generator function if available
                svgElement = generator(...entity.generator_args);
              } else if (template) {
                svgElement = template.cloneNode(true);
              }
              transform = transform || htl.svg`<g id=${id}></g>`;
              transform.textContent = "";
              transform.appendChild(svgElement);
              transform.template = template;
              transform.generator = generator;

              if (entity.unfiltered) {
                unfiltered.appendChild(transform);
              } else {
                root.appendChild(transform);
              }
            }

            // Sync transform to entity's position and rotation
            transform.setAttribute(
              "transform",
              `translate(${entity.position[0]} ${entity.position[1]}) rotate(${
                (entity.position[2] * 180) / Math.PI
              })`
            );
          }
        }
      }

      deps.register("RendererSystem", new RendererSystem(), 5);
    }
  </script>
  <script id="5492" type="text/markdown">
    ### Most cell did not require much iteration

    Plotting a histogram of number of edits we see many cells were never edited, or edited only a few times, but there is a long tail.
  </script>
  <script id="5148" type="application/vnd.observable.javascript">
    edits = [
      ...d3
        .rollup(
          filtered_events,
          (d) => d.length,
          (d) => d.node_name
        )
        .entries()
    ]
      .map(([cell, edits]) => ({ cell, edits }))
      .sort((a, b) => a.edits - b.edits)
  </script>
  <script id="5464" type="application/vnd.observable.javascript">
    Plot.plot({
      marks: [
        Plot.rectY(
          edits,
          Plot.binX(
            { y: "count" },
            {
              x: "edits",
              tip: true,
              thresholds: [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 25, 30,
                35, 40, 100, 200
              ]
            }
          )
        ),
        Plot.ruleY([0])
      ]
    })
  </script>
  <script id="5505" type="text/markdown">
    ### The `GameOverSystem` component

    A good example of a cell the LLM aced in a single prompt was the GameOverSystem that was introduced in part IV and survived to the end of the process. It is a non-trivial quantity of code that was generated from a high-level prompt

  </script>
  <script id="3167" type="application/vnd.observable.javascript" pinned="">
    GameOverSystem = {
      ({
        prompt:
          "Add a system that when lives is 0, the top score is recorded and the player ship is removed",
        time: 1700511760135,
        comment:
          "Create a system to handle game over, record top score, and remove player ship"
      });

      class GameOverSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          if (gameState.lives <= 0) {
            gameState.state = "Game Over";

            // Record top score
            const topScore = localStorage.getItem("topScore") || 0;
            if (gameState.score > topScore) {
              localStorage.setItem("topScore", gameState.score);
            }

            // Remove player ship
            entities.delete("player");
            const playerElement = game_view.querySelector("#player");
            if (playerElement) playerElement.remove();
          }
        }
      }

      deps.register("GameOverSystem", new GameOverSystem(), 1);
    }
  </script>
  <script id="5516" type="text/markdown">
    ### keysPressed

    Another fairly solid piece of code the LLM wrote was the `keysPressed` adapter, which converts between the DOM style, event-driven, push approach, to a pollable register that is favoured in game development.

    ~~~js
    keysPressed = {
      ({
        prompt:
          "Write a cell that listens to the keyboard and records which keys are up or down and swallows Array events to prevent scrolling",
        time: 1699995151091,
        comment:
          "Cell to record key up/down states and prevent scrolling with arrow keys"
      });
      const keysPressed = {};

      function keydownListener(event) {
        if (event.key.startsWith("Arrow")) event.preventDefault(); // Prevent scrolling with arrow keys
        keysPressed[event.key] = true;
      }

      function keyupListener(event) {
        if (event.key.startsWith("Arrow")) event.preventDefault(); // Prevent scrolling with arrow keys
        keysPressed[event.key] = false;
      }

      window.addEventListener("keydown", keydownListener);
      window.addEventListener("keyup", keyupListener);

      // Cleanup listeners when cell is re-evaluated or notebook is closed
      invalidation.then(() => {
        window.removeEventListener("keydown", keydownListener);
        window.removeEventListener("keyup", keyupListener);
      });

      return keysPressed;
    }
    ~~~

    The `keysPressed` has several interesting features. The LLM has learnt through in-context learning that it should deregister listeners. Resource cleanup is needed due to a resource leak side effect of the notebook execution environment when the cell recomputes. It was not taught to do this in the system prompt, it has learnt the technique from earlier examples within the notebook. It's using the `invalidation` promise of the [Observable runtime](https://observablehq.com/@observablehq/invalidation), which is something you would not find in vanilla Javascript projects. Furthermore it's commented its use of this unique feature.

    This cell demonstrates how the LLMs replicates code styles present in its context window. This is consequential, as it enables transfer learning of code skills just by copy and pasting cells across notebook. [Roboco-op](https://observablehq.com/@tomlarkworthy/robocoop) has a [dedicated notebook](https://observablehq.com/@tomlarkworthy/robocoop-skills?collection=@tomlarkworthy/robocoop) for cells meant for copy and pasting skill into notebooks to specialise the LLM helper quickly.


  </script>
  <script id="5564" type="text/markdown">
    ### Skill cells: `markdown_skill`, `bindableUISkill`

    The notebook used two reusable skill calls from [skills notebook](https://observablehq.com/@tomlarkworthy/robocoop-skills?collection=@tomlarkworthy/robocoop). `markdown_skill` gives the LLM the ability to write advanced markdown, and the `bindableUISkill` gives it the ability to write reactive UIs.

    Using a `markdown` cell is a great way to have a semi-structured dialog with the LLM. You can ask for a markdown cell containing a plan for instance. This was used extensively in the ideation phase of part I.

    After getting the basics of the game working initially in `part II`, it became obvious that to get the aesthetic feel of various systems right artistic scale would require tweaking parameters. Tweaking parameters in code did not feel great, so instead, I started using the LLM to generate systems with reactive UIs attached. The `bindableUISkill` gave it those powers in part III, and is a technique I expect to be useful in future projects.

    One limitation of the observable platform is UI changes are forgotten after a page refresh. So for the notebook to remember a settings you need to update the initial value in the code. Many of the notebook edits are trivial parameter materialisation after manually tweaking a UI setting.

  </script>
  <script id="6274" type="text/markdown">
    ## Good Design Decisions 

    The LLM and I made some important decisions at the beginning of the project that I think were critical for the overall success. I also made a few big mistakes that damaged the project which I will talk about afterwards.







  </script>
  <script id="6298" type="text/markdown">


    ### Use of an Entity Component System

    My first question to the LLM was

    _"I want to build a really fast high quality game using html, but incrementally in the notebook, so we need to build each system independently. Do you have a good architecture suggestion. It should be a one pager, with neon graphics like geomtry wars, maybe exploiting the simplicity of SVG, but somehow with shaders?"_

    It responded with:

    _"Building a fast, high-quality game with HTML and SVG can be achieved using a component-based architecture where each system of the game is developed independently. Here's an architectural suggestion: ..."
    _

    Its actual concrete architecture was not really used, but we did go with an Entity Component System. That worked out *really* well with the notebook environment because we could add systems over time.
  </script>
  <script id="6301" type="text/markdown">

    ### Incremental Dependancy Injection

    I realised ECS was not enough to break down the project enough for collaboration with an LLM. With an LLM you expect to write sequential revisions of each functional component. However, Observable notebooks don't support multiple implementations under a single name. So I again asked the LLM for help on development of a *incremental dependancy injection* system. This piece of architecture was too hard to explain and in the early stages, and the LLM didn't have much Observable runtime competency, so ultimately I coded this critical piece of supporting code myself.

    You will see throughout the work names like `renderSystem_v1`, and within the code registrations with `deps` under the name `renderSystem` with a version `1`. Whenever a reference is required, you use `deps.resolve("renderSystem")` and it will return the value of the highest registered version number under that name. Its a dependancy injection system that supports multiple versions of a dependancy in the runtime at the same time, that resolves to the highest version present.

    The LLM was very good at pickup up the resolution system and running with it. It very quickly learnt to increment the version suffix in variable names when generating a new version and wiring that into the dependancy system correctly. LLMs excel at these higher order source code boilerplate. It is the kind of ceremony I would find annoying if I were coding it manually, but because the LLM does it, it was actually a really neat and enabled rapid iteration without losing context of previous attempts.

    This form of dependancy injection is something I would like to improve upon and build out into a reusable skill in the future. Its the kind of extra support needed to enable better workflows with LLMs
  </script>
  <script id="6388" type="text/markdown">
    ## Structuring Code to Support LLM Help

    New constraints on maintainability occur when the code base needs to be updatable by an LLM. I found it was bad practice to have a cell implement more than than functional one task, because that caused re-promping difficulties. As the project went on I converged towards an ultra-decoupled design.  

    For instance, near the beginning of the project I created a [`GameLoop`](https://observablehq.com/d/fbab829d5bcdd7e2#GameLoop_v4) component that was responsible for bullets hitting boulders, and for boulders splitting and for incrementing the score. In normal development workflow I might add features to this game loop over time, but getting the LLM to reproduce the existing features and add a new feature was error prone. The effect gets worse as the cell gets more features, so it's clearly a scalability bottleneck.

    So later on in the project I switched strategy on how I add features. Features like [enemies spawning](https://observablehq.com/d/ef7ccf2e0ed653d1#EnemyShipSystem_v2), [enemies shooting lazers](https://observablehq.com/d/ef7ccf2e0ed653d1#EnemyLazerSystem) and [enemy lazers hitting the player](https://observablehq.com/d/ef7ccf2e0ed653d1#PlayerLazerEnemyCollisionSystem) were written as independent systems which could be iterated on individually.

    The combination of Entity-Component-System and Iterative Dependancy Injection were important to decouple the  program, and this helped getting the most value out of the LLM collaboration. 

    I do not expect that ECS is the only approach though. Any architecture that supports decoupling might be viable. There are several that might work: event buses, rule systems _etc_. Understand that (roboco-op at least), is not good at updating the code within functions. So you really should aim to decompose a program into individual, very small, independently iterative functions. Generally this is good software engineering practice, but the LLM collaboration really forces us to take it to an extreme degree.

    The Observable notebook environment supports this style of decoupled development well. I think traditional software development will struggle with this, as tests are usually separate to functions and usually there is a lot of config to setup before parts of code can be executed. Applying LLMs effectively to professional coding will require a rethink of how projects are structured and executed. 


  </script>
  <script id="6313" type="text/markdown">
    ## Bad Project Decisions

    By Part V I realised our game system contained a ton of code repetition. I asked the LLM

    _"There is a lot of repetition in our code base. Let's write plan to refactor it and extract common functionality. Describe what we want to extract and how each cell should be modified in markdown"_

    It responded with what superficially appeared to be a good game-plan for refactoring out some of the common functionality. We started by generating the new routines, and then started refactoring existing components. However, I quickly realised the abstractions it had suggested were not actually general purpose enough to fit all the projects use-cases, and also they were quite buggy. 

    The right thing would have probably been to rollback, but I had also added some good new features so I did not want to lose work. So In the end I just stopped midway through a refactor. This poisoned the context window with a bad strategy for UI generation, which never recovered. From that point onwards I had to manually bug fix all attempts at UI generation. 

    There several lessons here
    - LLMs are not very good at refactoring.
    - Keeping your context full of only one way of doing things is a good idea
    - Code repetition is not actually such a big problem when most of your code is generated anyway.
    - Its hard to get the LLM to change course once project idioms are established.

    Currently I would consider a refactor a very risky thing to do. There might be a better workflow, but currently roboco-op only allows a single cell to be changed at a time, and the LLM has very little feedback into what gets broken. We saw it struggle with coupled components before. Code quality is critical to maintain so that the LLM continues on a good trajectory, thisis is a headwind for velocity.

    Refactoring is a difficult thing for humans to do as well. In human driven development we use unit test suites to pivot our codebase. I could imagine trying some variant of test driven development might help, but it's just a hunch.


  </script>
  <script id="6326" type="text/markdown">
    ## The cost

    I started the project with GPT-4, but then GPT-4-turbo came out with a bigger context windows and reduced costs so I switched to that. Still, the costs of a large context windows started to add up as the project got bigger (particularly for a hobby project) and I had to start consciously thinking about costs every time I pressed the prompt button. The total cost was under $100, and compared to programmer time, it was a total bargain, but this was still quite a small project in total line count so a real project would probably be at least 10x in cost.

    ![image@1.png](${await FileAttachment("image@1.png").url()})

    I think it would be useful if Roboco-op displaced the token cost for each cell so cost could be optimised better, and have tools for temporarily masking cells from the context window. I think the approach has good potential but there are signs that costs and complexity will become a future scaling bottleneck if not addressed.
  </script>
  <script id="6340" type="text/markdown">
    ## Closing Thoughts

    You can download an standalone export of the final project [here](https://api.observablehq.com/d/5cc90faa3b651500@4411.tgz?v=3). The final notebook had 2500 lines of code. Given it took 27 hours (4 days), thats about 600 lines of code a day. This is well above average. Whilst I can occasionally beat that, my subjective experience was that this was mentally easier than going full belt.

    Some of the harder problems I had to step in and code up (and this is where most time was spent), I am pretty sure the LLM took a lot of cognitive burden from me, so I only had to exert serious mental energy sporadically. I think there is big potential for LLMs to help with serious work along side subject matter experts. The way it adapts to a novel programming paradigm like Observable, and pickup cues from manual demonstration means they are quite flexible. By copying reusable skills from other notebooks, you can mix up specialists on demand.

    This work showed me LLMs can help expert programmer work faster if the expert can correct them quickly in-band. LLMs can climb levels of abstraction into domain jargon once project idioms are established. But controlling context is critical and technical debt poisons the context. Good code quality is even more important when collaborating with an LLM, and they will resist code layout changes which make refactoring dangerous and difficult.

    [Roboco-op](https://observablehq.com/@tomlarkworthy/robocoop-skills?collection=@tomlarkworthy/robocoop) hints we are not extracting the full value of LLMs on coding tasks yet, we need additional tools to help support iterative development at runtime like incremental dependancy injection, and something to help with refactoring. These are lessons I will fold back into [roboco-op](https://observablehq.com/@tomlarkworthy/robocoop-skills?collection=@tomlarkworthy/robocoop).

  </script>
  <script id="6363" type="text/markdown">
    ---
  </script>
  <script id="6365" type="text/markdown">
    ## Research Tools
  </script>
  <script id="6367" type="text/markdown">
    #### History search

    This is a search over the entire series notebook edit history
  </script>
  <script id="5511" type="module" pinned="">

  </script>
  <script id="6369" type="text/markdown">
    #### Calculations
  </script>
  <script id="4513" type="application/vnd.observable.javascript">
    data = [
      {
        title: "part I",
        link: "https://observablehq.com/d/b497b79c94d3fbd1",
        history: await FileAttachment("partI.json").json()
      },
      {
        title: "part II",
        link: "https://observablehq.com/d/8571aa583512f2a4",
        history: await FileAttachment("partII.json").json()
      },
      {
        title: "part III",
        link: "https://observablehq.com/d/1ec7e3f612d70414",
        history: await FileAttachment("partIII.json").json()
      },
      {
        title: "part IV",
        link: "https://observablehq.com/d/fbab829d5bcdd7e2",
        history: await FileAttachment("partIV.json").json()
      },
      {
        title: "part V",
        link: "https://observablehq.com/d/025ff03d865684e9",
        history: await FileAttachment("partV.json").json()
      },
      {
        title: "part VI",
        link: "https://observablehq.com/d/ef7ccf2e0ed653d1",
        history: await FileAttachment("partVI.json").json()
      },
      {
        title: "part VII",
        link: "https://observablehq.com/d/49b1dd226a242821",
        history: await FileAttachment("partVII.json").json()
      },
      {
        title: "part VIIb",
        link: "https://observablehq.com/@tomlarkworthy/make-a-game-part-viib-filter-sidequest",
        history: await FileAttachment("partVIIb.json").json()
      },
      {
        title: "part VIII",
        link: "https://observablehq.com/d/5cc90faa3b651500",
        history: await FileAttachment("partVIII.json").json()
      }
    ]
  </script>
  <script id="4692" type="application/vnd.observable.javascript">
    enrich_time = (time, prefix = "") => ({
      [`${prefix}time`]: new Date(time),
      [`${prefix}date`]: `2023-${new Date(time).getMonth() + 1}-${new Date(time)
        .getDate()
        .toString()
        .padStart(2, "0")}`,
      [`${prefix}minute`]:
        new Date(time).getHours() + new Date(time).getMinutes() / 60
    })
  </script>
  <script id="4468" type="application/vnd.observable.javascript">
    isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
  </script>
  <script id="6374" type="text/markdown">
    ---
  </script>
  <script id="6376" type="text/markdown">
    ## Game Implementation

    These cells implement the game. I moved some of them into the article, you can see the prompt that generated them in the cell code (burger menu on left)
  </script>
  <script id="2849" type="application/vnd.observable.javascript">
    import { view } from "@tomlarkworthy/view"
  </script>
  <script id="3436" type="text/markdown">
    ### State
  </script>
  <script id="2298" type="application/vnd.observable.javascript">
    viewof deps = {
      ({
        prompt:
          'Create a DI impelmentation that makes use of Observable resolution.\n\nThe named service should end up bound to an implementation with \n\n"mySystem = deps.resolve("mySystem")"\n\ndifferent implementations are added with\n\n"deps.register("mySystem", <value>, 1)"\n\nwith a monotonic version counter.\n\nthe deps implementation should keep all versions, so we can dynamically switch implementations, e.g. for a/b testing, but by default things should resolve to the highest number.\n\nbecause when deps changes it should dispatch and event, callers will try to reregister. So it should sniff where the call is coming from for deduplication with caller_id and time',
        time: 1699900881324,
        comment: "Create a viewof cell for Dependency Injection container v2"
      });

      const game_view = Inputs.input();

      class DIContainer {
        constructor() {
          this.dependencies = new Map();
        }

        register(name, factory, version = 0) {
          const caller = caller_id();
          let versions = this.dependencies.get(name);
          if (!versions) {
            versions = {};
            this.dependencies.set(name, versions);
          }

          if (
            !versions[version] ||
            versions[version].trigger_time < Date.now() - 1000
          ) {
            game_view.dispatchEvent(new Event("input"));
          }

          versions[version] = { factory, caller, trigger_time: Date.now() };
          return factory;
        }

        resolve(name) {
          const versions = this.dependencies.get(name);
          if (!versions) return null;
          const maxVersion = Math.max(...Object.keys(versions));
          return versions[maxVersion]?.factory || null;
        }
      }

      game_view.value = new DIContainer();
      return game_view;
    }
  </script>
  <script id="2219" type="application/vnd.observable.javascript">
    entities = ({
      prompt: "Create the entity state as a map of objects",
      time: 1699829601388,
      comment: "Initialize an empty Map to hold the entity state"
    } && new Map())
  </script>
  <script id="2757" type="application/vnd.observable.javascript">
    gameState = {
      ({
        prompt:
          'Add a cell for the game state, should contain lives 3, a score 0 and the state "Running"',
        time: 1700002625261,
        comment:
          "Cell to store game state including lives, score, and current state"
      });

      const gameState = { lives: 3, score: 0, state: "Game Over" };
      return gameState;
    }
  </script>
  <script id="2693" type="application/vnd.observable.javascript">
    keysPressed = {
      ({
        prompt:
          "Write a cell that listens to the keyboard and records which keys are up or down and swallows Array events to prevent scrolling",
        time: 1699995151091,
        comment:
          "Cell to record key up/down states and prevent scrolling with arrow keys"
      });
      const keysPressed = {};

      function keydownListener(event) {
        if (event.key.startsWith("Arrow")) event.preventDefault(); // Prevent scrolling with arrow keys
        keysPressed[event.key] = true;
      }

      function keyupListener(event) {
        if (event.key.startsWith("Arrow")) event.preventDefault(); // Prevent scrolling with arrow keys
        keysPressed[event.key] = false;
      }

      window.addEventListener("keydown", keydownListener);
      window.addEventListener("keyup", keyupListener);

      // Cleanup listeners when cell is re-evaluated or notebook is closed
      invalidation.then(() => {
        window.removeEventListener("keydown", keydownListener);
        window.removeEventListener("keyup", keyupListener);
      });

      return keysPressed;
    }
  </script>
  <script id="3431" type="text/markdown">
    ### Refactored Routines
  </script>
  <script id="3419" type="application/vnd.observable.javascript">
    collisionDetection_v1 = {
      ({
        prompt: "Write the common collision routine and register as a dependancy",
        time: 1700899553837,
        comment: "Common collision detection routine"
      });

      function collisionDetection(entityA, entityB, collisionRadius = 0) {
        const dx = entityA.position[0] - entityB.position[0];
        const dy = entityA.position[1] - entityB.position[1];
        const distance = Math.sqrt(dx * dx + dy * dy);
        return (
          distance < (entityA.radius || 0) + (entityB.radius || 0) + collisionRadius
        );
      }

      deps.register("collisionDetection", collisionDetection, 1);
    }
  </script>
  <script id="3422" type="application/vnd.observable.javascript">
    spawnEntity_v1 = {
      ({
        prompt: "Write the common entity spawning routine as a dependancy",
        time: 1700899657356,
        comment: "Common entity spawning routine"
      });
      let count = 0;
      function spawnEntity(
        entityTemplate,
        position,
        velocity,
        additionalProps = {}
      ) {
        const newEntity = {
          id: `s${count++}`,
          template: entityTemplate,
          position: position,
          velocity: velocity,
          ...additionalProps
        };
        entities.set(newEntity.id, newEntity);
        return newEntity;
      }

      deps.register("spawnEntity", spawnEntity, 1);
    }
  </script>
  <script id="3425" type="application/vnd.observable.javascript">
    randomizeVelocity_v1 = {
      ({
        prompt:
          "Write the common randomized velocity adjustment routine as a dependancy",
        time: 1700899715036,
        comment: "Common randomized velocity adjustment routine"
      });

      function randomizeVelocity(entity, magnitude, axis = null) {
        const adjust = () => (Math.random() - 0.5) * magnitude;
        if (axis === "x" || axis === null) entity.velocity[0] += adjust();
        if (axis === "y" || axis === null) entity.velocity[1] += adjust();
      }

      deps.register("randomizeVelocity", randomizeVelocity, 1);
    }
  </script>
  <script id="3428" type="application/vnd.observable.javascript">
    removeEntity_v1 = {
      ({
        prompt: "Write the entity removal routine as a dependancy",
        time: 1700899801821,
        comment: "Entity removal routine"
      });

      function removeEntity(entityId) {
        entities.delete(entityId);
        const element = game_view.querySelector(`#${entityId}`);
        if (element) element.remove();
      }

      deps.register("removeEntity", removeEntity, 1);
    }
  </script>
  <script id="3445" type="application/vnd.observable.javascript">
    generateAsset_v1 = {
      ({
        prompt:
          "Write the routine for asset generation, remember we want to use deps instead of assets going forward",
        time: 1700900207335,
        comment: "Routine for asset generation using deps"
      });

      function generateAsset(name, generatorFunction, ...args) {
        const asset = generatorFunction(...args);
        deps.register(name, asset, 1);
      }

      deps.register("generateAsset", generateAsset, 1);
    }
  </script>
  <script id="3448" type="text/markdown">
    ### Update Game
  </script>
  <script id="3503" type="application/vnd.observable.javascript">
    viewof BulletBolouder_v6 = {
      ({
        prompt: "Refactor the game loop remembering it was a UI",
        time: 1700902042331,
        comment: "Refactor GameLoop with UI according to the refactoring plan"
      });

      const explosionSettings = deps.resolve("generateUIPanel")({
        score_per_hit: {
          type: "range",
          label: "Score per Hit",
          options: { min: 5, max: 50, value: 10, step: 5 },
          callback: (e) => (globalThis.scorePerHit = e.target.value)
        },
        collision_radius: {
          type: "range",
          label: "Collision Radius",
          options: { min: 0, max: 1, value: 0.01 },
          callback: (e) => (globalThis.collisionRadius = e.target.value)
        },
        fragment_count: {
          type: "range",
          label: "Fragment Count",
          options: { min: 2, max: 10, value: 3, step: 1 },
          callback: (e) => (globalThis.fragmentCount = e.target.value)
        },
        fragment_size: {
          type: "range",
          label: "Fragment Size",
          options: { min: 0, max: 1, value: 0.06 },
          callback: (e) => (globalThis.fragmentSize = e.target.value)
        },
        fragment_velocity: {
          type: "range",
          label: "Fragment Velocity",
          options: { min: 0, max: 0.01, value: 0.001 },
          callback: (e) => (globalThis.fragmentVelocity = e.target.value)
        }
      });

      class GameLoop extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          const projectiles = Array.from(entities.values()).filter(
            (e) => e.template === "projectile"
          );
          const boulders = Array.from(entities.values()).filter(
            (e) => e.generator === "generateBoulder"
          );

          projectiles.forEach((projectile) => {
            boulders.forEach((boulder) => {
              if (
                deps.resolve("collisionDetection")(
                  projectile,
                  boulder,
                  boulder.radius
                )
              ) {
                gameState.score += globalThis.scorePerHit;
                deps.resolve("removeEntity")(projectile.id);
                deps.resolve("removeEntity")(boulder.id);
                if (boulder.radius > globalThis.fragmentSize) {
                  this.createFragments(
                    boulder,
                    globalThis.fragmentCount,
                    boulder.radius / 2
                  );
                }
              }
            });
          });
        }

        createFragments(boulder, count, size) {
          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const velocity = [
              Math.cos(angle) * globalThis.fragmentVelocity,
              Math.sin(angle) * globalThis.fragmentVelocity,
              0
            ];
            deps.resolve("spawnEntity")(
              undefined,
              [...boulder.position],
              velocity,
              {
                radius: size,
                generator: "generateBoulder",
                generator_args: [size]
              }
            );
          }
        }
      }

      deps.register("GameLoop", new GameLoop(), 6);

      return explosionSettings;
    }
  </script>
  <script id="3510" type="application/vnd.observable.javascript">
    viewof PlayerBoulderCollisionSystem = {
      ({
        prompt:
          "I think we should split the game loop into independant systems. Create the player collides with bolder as  an independent system with a UI",
        time: 1700902504309,
        comment: "Create independent system for player colliding with boulder"
      });

      class PlayerBoulderCollisionSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          const player = entities.get("player");
          if (!player) return;

          const boulders = Array.from(entities.values()).filter(
            (e) => e.generator === "generateBoulder"
          );

          boulders.forEach((boulder) => {
            if (
              deps.resolve("collisionDetection")(player, boulder, boulder.radius)
            ) {
              gameState.lives -= 1;
            }
          });
        }
      }

      deps.register(
        "PlayerBoulderCollisionSystem",
        new PlayerBoulderCollisionSystem(),
        1
      );
    }
  </script>
  <script id="2507" type="application/vnd.observable.javascript">
    assets = deps.resolve("Assets")
  </script>
  <script id="2267" type="application/vnd.observable.javascript">
    caller_id = ({
      prompt:
        "Write a function called caller_id that will identifying the source code location by reading a stack trace and hashing it",
      time: 1699860967160,
      comment: "Function for identifying the source code location"
    } &&
      function caller_id() {
        const err = new Error();
        const stack = err.stack.split("\n");
        const sourceLocation = stack[2];
        let hash = 0;
        for (let i = 0; i < sourceLocation.length; i++) {
          const char = sourceLocation.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
      })
  </script>
  <script id="2306" type="application/vnd.observable.javascript">
    deps.register("BaseSystem", class {}, 1)
  </script>
  <script id="2411" type="application/vnd.observable.javascript">
    ticker_v1 = {
      ({
        prompt:
          "Tick all systems by iterating the deps and calling the tick function if it exists",
        time: 1699907020513,
        comment:
          "Ticker function v1 that resolves dependencies and calls tick on each system"
      });
      let cancel = false;
      function tick() {
        if (isSafari) return;
        if (cancel) return;
        const names = Array.from(deps.dependencies.keys());
        names.forEach((name) => {
          const system = deps.resolve(name);
          if (system && typeof system.tick === "function") {
            try {
              system.tick();
            } catch (e) {
              console.error(e);
            }
          }
        });
        requestAnimationFrame(tick);
      }
      tick();
      // Clear loop if cell recomputes
      invalidation.then(() => (cancel = true));
    }
  </script>
  <script id="2504" type="application/vnd.observable.javascript">
    assets_v1 = ({
      prompt:
        "At the moment all entities are circles. Lets add a Assets dependancy that will hold a str -> any map",
      time: 1699948455733,
      comment: "Register Assets dependency holding a map from string to any"
    } && deps.register("Assets", new Map(), 1))
  </script>
  <script id="2527" type="application/vnd.observable.javascript">
    player_entity = {
      ({
        prompt: "create an entity called player at the origin",
        time: 1699948785452,
        comment: "Create a player entity at the origin"
      });

      const player = {
        id: "player",
        template: "ship",
        position: [0, 0, 0],
        velocity: [0, 0, 0],
        force: [0, 0, 0]
      };

      // Add player entity to entities map
      entities.set(player.id, player);
      return player;
    }
  </script>
  <script id="2559" type="application/vnd.observable.javascript">
    PhysicsSystem_v2 = {
      ({
        prompt:
          "We don't have rotation as a concept! update position etc. in the physics system to be arrays of 3, where the last element is rotation/rotational velocity, torque",
        time: 1699989339201,
        comment:
          "Update PhysicsSystem to include rotation in position, velocity, and force"
      });
      class PhysicsSystem extends deps.resolve("BaseSystem") {
        constructor(...args) {
          super(...args);
        }

        tick() {
          entities.forEach((entity) => {
            if (entity.position && entity.velocity) {
              entity.position[0] += entity.velocity[0];
              entity.position[1] += entity.velocity[1];
              entity.position[2] += entity.velocity[2]; // Update rotation
            }

            if (entity.velocity && entity.force) {
              entity.velocity[0] += entity.force[0];
              entity.velocity[1] += entity.force[1];
              entity.velocity[2] += entity.force[2]; // Update rotational velocity
              // Reset force and torque
              entity.force = [0, 0, 0];
            }
          });
        }
      }

      // Register updated PhysicsSystem under 'PhysicsSystem' with version 2
      return deps.register("PhysicsSystem", new PhysicsSystem(), 2);
    }
  </script>
  <script id="2649" type="application/vnd.observable.javascript">
    WorldWrap = {
      ({
        prompt:
          "the bullets should world wrap too. So lets take all the wrapping logic into its own system called WorldWrap. We should also decrement the ttl and remove the element if ttl < 0",
        time: 1699993637444,
        comment: "Create WorldWrap system for wrapping entities and managing ttl"
      });
      class WorldWrap extends deps.resolve("BaseSystem") {
        constructor(...args) {
          super(...args);
        }

        tick() {
          entities.forEach((entity, id) => {
            // Wrap entities around the edges
            for (let i = 0; i < 2; i++) {
              if (entity.position[i] < -1) entity.position[i] = 1;
              if (entity.position[i] > 1) entity.position[i] = -1;
            }
            // Decrement ttl for entities with ttl and remove if ttl < 0
            if (entity.ttl !== undefined) {
              entity.ttl -= 1;
              if (entity.ttl < 0) {
                entities.delete(id);
                const element = game_view.querySelector(`#${id}`);
                if (element) element.remove();
              }
            }
          });
        }
      }

      // Register WorldWrap system with version 1
      return deps.register("WorldWrap", new WorldWrap(), 1);
    }
  </script>
  <script id="2624" type="application/vnd.observable.javascript">
    projectile_asset = {
      ({
        prompt: "create projectile asset as an SVG line",
        time: 1699992605095,
        comment: "Create a projectile asset as an SVG line"
      });
      // Create an SVG line to represent a projectile
      const projectile = htl.svg`<line x1="0" y1="0" x2="0.05" y2="0" style="stroke:rgb(255,0,0);stroke-width:0.01" />`;
      assets.set("projectile", projectile);
      return htl.svg`<svg id="projectile" width="10" height="10" viewBox="-0.05 -0.05 0.1 0.1">
        ${projectile}
      </svg>`;
    }
  </script>
  <script id="2731" type="application/vnd.observable.javascript">
    boulder_template = {
      ({
        prompt:
          "now we need some astroids to collide into, create a jagged bolder templates",
        time: 1700001722754,
        comment: "Create jagged boulder SVG template"
      });

      // Create a jagged boulder template using a random polygon
      const points = Array.from({ length: 8 }, () => {
        const angle = Math.random() * 2 * Math.PI;
        const radius = 0.1 + Math.random() * 0.05; // radius between 0.1 and 0.15
        return `${Math.cos(angle) * radius},${Math.sin(angle) * radius}`;
      }).join(" ");

      const boulder = htl.svg`<polygon points="${points}" style="fill:grey;stroke:black;stroke-width:0.005" />`;
      assets.set("boulder", boulder);
      return htl.svg`<svg width="50" height="50" viewBox="-1 -1 2 2">
        ${boulder.cloneNode(true)}
      </svg>`;
    }
  </script>
  <script id="2743" type="application/vnd.observable.javascript">
    small_boulder_template = {
      ({
        prompt: "We need a template for smaller boulders",
        time: 1700002006174,
        comment: "Create template for smaller boulders"
      });

      // Create a smaller jagged boulder template using a random polygon
      const points = Array.from({ length: 8 }, () => {
        const angle = Math.random() * 2 * Math.PI;
        const radius = 0.025 + Math.random() * 0.00125;
        return `${Math.cos(angle) * radius},${Math.sin(angle) * radius}`;
      }).join(" ");

      const smallBoulder = htl.svg`<polygon points="${points}" style="fill:grey;stroke:black;stroke-width:0.005" />`;
      assets.set("smallBoulder", smallBoulder);
      return htl.svg`<svg id="smallBoulder" width="30" height="30" viewBox="-0.1 -0.1 0.2 0.2" style="filter: ">
        ${smallBoulder}
      </svg>`;
    }
  </script>
  <script id="2956" type="application/vnd.observable.javascript">
    viewof ship_template_v3 = {
      ({
        prompt:
          "Let make a new ship shape. I want a simple V shape, but expose the parameters like color, length and width as a UI",
        time: 1700411623034,
        comment:
          "Create a new ship shape with parameters for color, length, and width exposed in a UI"
      });
      const shipSettings = view`<div>
        <h2>Ship Settings</h2>
        ${["color", Inputs.color({ value: "#f88fff", label: "Ship color" })]}
        ${["length", Inputs.range([0, 2], { value: 0.2, label: "Ship length" })]}
        ${["width", Inputs.range([0, 1], { value: 0.11, label: "Ship width" })]}
        ${["stroke", Inputs.range([0, 1], { value: 0.018, label: "stroke width" })]}
        ${["offset", Inputs.range([0, 0.2], { value: 0.06, label: "offset" })]}
      </div>`;

      const updateShipTemplate = () => {
        const settings = shipSettings.value;

        const points = `${-settings.length / 2 + settings.offset},${
          settings.width / 2
        } ${settings.offset},0 ${-settings.length / 2 + settings.offset},${
          -settings.width / 2
        }`;
        const ship = htl.svg`<polyline
          fill="none"
          stroke-linecap="round"
          style=${{
            stroke: settings.color,
            "stroke-width": settings.stroke
          }}
          points="${points}" />`;

        assets.set("ship", ship);
      };
      // Update ship when settings change
      shipSettings.addEventListener("input", updateShipTemplate);
      updateShipTemplate(); // Initialize shape

      return shipSettings;
    }
  </script>
  <script id="3042" type="application/vnd.observable.javascript">
    viewof score_template = {
      ({
        prompt:
          "Lets create a template for the score (and SVG text node). Include a UI to control its parameters",
        time: 1700416227959,
        comment:
          "Create a score template with SVG text node and a UI to control its parameters"
      });

      const scoreSettings = view`<div>
        <h2>Score Settings</h2>
        ${[
          "color",
          Inputs.color({
            value: "#f0dd0a",
            label: "Score color"
          })
        ]}
        ${[
          "font_size",
          Inputs.range([0, 1], {
            value: 0.1,
            label: "Font size"
          })
        ]}
        ${[
          "x_position",
          Inputs.range([-1, 1], {
            value: -0.9,
            label: "X position"
          })
        ]}
      </div>`;

      const updateScoreTemplate = () => {
        const settings = scoreSettings.value;
        const score = htl.svg`<text x="${settings.x_position}" y="0.95" dy="-0.35em" fill="${settings.color}" font-size="${settings.font_size}px" text-anchor="start" font-family="'Press Start 2P', cursive">
          <tspan id="score-value">0</tspan>
        </text>`;
        assets.set("score", score);
      };
      // Update score when settings change
      scoreSettings.addEventListener("input", updateScoreTemplate);
      updateScoreTemplate(); // Initialize score

      return scoreSettings;
    }
  </script>
  <script id="3051" type="application/vnd.observable.javascript">
    viewof lives_template = {
      ({
        prompt:
          "Create a template for the lives (and SVG text node). Include a UI to control its parameters",
        time: 1700416541894,
        comment:
          "Create a template for lives with SVG text node and a UI to control its parameters"
      });

      const livesSettings = view`<div>
        <h2>Lives Settings</h2>
        ${[
          "color",
          Inputs.color({
            value: "#ff1f1f",
            label: "Lives color"
          })
        ]}
        ${[
          "font_size",
          Inputs.range([0, 1], {
            value: 0.1,
            label: "Font size"
          })
        ]}
        ${[
          "x_position",
          Inputs.range([-1, 1], {
            value: 0.91,
            step: 0.01,
            label: "X position"
          })
        ]}
      </div>`;

      const updateLivesTemplate = () => {
        const settings = livesSettings.value;
        const lives = htl.svg`<text x="${settings.x_position}" y="0.95" dy="-0.35em" fill="${settings.color}" font-size="${settings.font_size}px" text-anchor="end" font-family="'Press Start 2P', cursive">
          <tspan id="lives-value">3</tspan>
        </text>`;
        assets.set("lives", lives);
      };
      // Update lives when settings change
      livesSettings.addEventListener("input", updateLivesTemplate);
      updateLivesTemplate(); // Initialize lives

      return livesSettings;
    }
  </script>
  <script id="3068" type="application/vnd.observable.javascript">
    HUDSystem = {
      ({
        prompt: "We need a system to update the score and lives each tick.",
        time: 1700416874329,
        comment: "Create a system to update the HUD (score and lives) each tick"
      });

      class HUDSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          const scoreElement = game_view.querySelector("#score-value");
          if (scoreElement) scoreElement.textContent = gameState.score;

          const livesElement = game_view.querySelector("#lives-value");
          if (livesElement) livesElement.textContent = gameState.lives;
        }
      }

      deps.register("HUDSystem", new HUDSystem(), 1);
    }
  </script>
  <script id="3108" type="application/vnd.observable.javascript">
    viewof boulder_generator_v1 = {
      ({
        prompt:
          "I do not like our current approach to the bolders. Lets replace them with a generator function instead of a template. Also lets make them more round. So make them out of 12 radial segments where the angle is a little noisey and the radius is a little noisey. The generator should have a target size so we can use this one generator for the little and big boulders. The template parameters should be configurable with a UI, which includes previewing the template and clicking a button to regenerate another.",
        time: 1700506696129,
        comment:
          "Create a boulder generator function with UI settings and a preview"
      });

      const boulderSettings = view`<div>
        <h2>Boulder Generator Settings</h2>
        ${[
          "target_size",
          Inputs.range([0, 1], { value: 0.2, label: "Target size" })
        ]}
        ${[
          "segments",
          Inputs.range([3, 20], { value: 12, step: 1, label: "Segments" })
        ]}
        ${[
          "angle_noise",
          Inputs.range([0, 5], { value: 0.3, label: "Angle noise" })
        ]}
        ${[
          "radius_noise",
          Inputs.range([0, 5], { value: 0.1, label: "Radius noise" })
        ]}
        ${[
          "stroke",
          Inputs.range([0, 0.3], { value: 0.01, label: "stroke width" })
        ]}
        ${[
          "color",
          Inputs.color({
            value: "#1fb4ff",
            label: "color"
          })
        ]}
        ${[
          "regenerate",
          htl.html`<button style="margin-top: 10px;">Regenerate</button>`
        ]}
      </div>`;

      const generateBoulder = (target_size) => {
        const settings = boulderSettings.value;
        const angleStep = (Math.PI * 2) / settings.segments;
        const points = Array.from({ length: settings.segments }, (_, index) => {
          const angle =
            index * angleStep + (Math.random() - 0.5) * settings.angle_noise;
          const radius =
            target_size + (Math.random() - 0.5) * settings.radius_noise;
          return `${Math.cos(angle) * radius},${Math.sin(angle) * radius}`;
        }).join(" ");
        return htl.svg`<polygon points="${points}" style="fill:none;stroke:${settings.color};stroke-width:${settings.stroke}" />`;
      };

      // Preview and regenerate boulder on button click
      const preview = htl.svg`<svg width="100" height="100" viewBox="-0.5 -0.5 1 1">${generateBoulder(
        boulderSettings.value.target_size
      )}</svg>`;
      const regen = () => {
        const newBoulder = generateBoulder(boulderSettings.value.target_size);
        preview.replaceChild(newBoulder, preview.firstChild);
      };
      boulderSettings.querySelector("button").onclick = regen;
      boulderSettings.addEventListener("input", regen);
      deps.register("generateBoulder", generateBoulder, 1);

      return htl.html`${boulderSettings}${preview}`;
    }
  </script>
  <script id="3163" type="application/vnd.observable.javascript">
    CleanupSystem = {
      ({
        prompt:
          "Add a system to remove transforms that are not attached to an entities in the view",
        time: 1700511337309,
        comment:
          "Create a system to remove transforms that are not attached to an entities in the view"
      });

      class CleanupSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.game_view = deps.resolve("game_view");
        }

        tick() {
          const transforms = this.game_view.querySelectorAll("#game-root g[id]");
          transforms.forEach((transform) => {
            const id = transform.getAttribute("id");
            if (!entities.has(id)) {
              transform.remove();
            }
          });
        }
      }

      deps.register("CleanupSystem", new CleanupSystem(), 1);
    }
  </script>
  <script id="3165" type="application/vnd.observable.javascript">
    BoulderGenerationSystem = {
      ({
        prompt:
          "Add a system that generates new boulders when all are gone. Incrementing the level in gamestate and generating a number of boulders equal to the level count + 2",
        time: 1700511473544,
        comment: "Create a system to generate new boulders when all are gone"
      });

      class BoulderGenerationSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.boulderGenerator = deps.resolve("generateBoulder");
          this.boulderSize = 0.2; // Default boulder size
        }

        tick() {
          const boulders = Array.from(entities.values()).filter(
            (e) => e.generator === "generateBoulder"
          );
          if (boulders.length === 0 && gameState.state === "Running") {
            gameState.level = (gameState.level || 0) + 1;
            this.generateBoulders(gameState.level + 2);
          }
        }

        generateBoulders(count) {
          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const velocity = [
              Math.cos(angle) * 0.0001,
              Math.sin(angle) * 0.0001,
              0
            ];
            const boulder = {
              id: `boulder${Date.now()}${i}`,
              generator: "generateBoulder",
              generator_args: [this.boulderSize],
              position: [Math.random() * 2 - 1, Math.random() * 2 - 1, 0],
              velocity: velocity,
              radius: this.boulderSize
            };
            entities.set(boulder.id, boulder);
          }
        }
      }

      deps.register("BoulderGenerationSystem", new BoulderGenerationSystem(), 1);
    }
  </script>
  <script id="3169" type="application/vnd.observable.javascript">
    LifeLostSystem = {
      ({
        prompt:
          "Add a system that when a life is lost, the player is teleported to a blank area of the screen",
        time: 1700511874407,
        comment:
          "Create a system to teleport player to a clear area when a life is lost"
      });

      class LifeLostSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          const player = entities.get("player");
          if (!player) return;
          if (gameState.lives < this.previous_lives) {
            player.position = this.findClearArea();
            player.velocity = [0, 0, 0];
          }
          this.previous_lives = gameState.lives;
        }

        isAreaClear(position) {
          return !Array.from(entities.values()).some((entity) => {
            if (entity.generator !== "generateBoulder") return false;
            const dx = position[0] - entity.position[0];
            const dy = position[1] - entity.position[1];
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < entity.radius + 0.2; // Consider a 0.1 buffer zone
          });
        }

        findClearArea() {
          for (let i = 0; i < 100; i++) {
            // Limit search iterations
            const position = [Math.random() * 2 - 1, Math.random() * 2 - 1, 0];
            if (this.isAreaClear(position)) {
              return position;
            }
          }
          return [0, 0, 0]; // Fallback to center
        }
      }

      deps.register("LifeLostSystem", new LifeLostSystem(), 1);
    }
  </script>
  <script id="3224" type="application/vnd.observable.javascript">
    EnemyShipSystem = {
      ({
        prompt:
          "randomly with low probability, if the game is running, add an enemy ship on the left or right side, with a fixed x velocity  towards the center. Every tick, with low probability adjust any ships y velocities, so the ships tend to zig zag across the screen. Destroy the enemy ship when it reaches the other side.",
        time: 1700598762370,
        comment:
          "Create a system to manage enemy ship spawning, movement, and destruction"
      });

      viewof enemy_ship_template_v4;

      class EnemyShipSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.xVelocity = 0.002; // Fixed x velocity towards the center
        }

        tick() {
          const gameRunning = gameState.state === "Running";
          if (gameRunning && Math.random() < 0.01) {
            // Spawn an enemy ship with low probability
            this.spawnEnemyShip();
          }

          for (let [id, ship] of entities.entries()) {
            if (ship.template !== "enemyShip") continue;
            if (Math.random() < 0.1) {
              // Adjust y velocity with low probability
              ship.velocity[1] += (Math.random() - 0.5) * 0.001;
            }

            if (Math.abs(ship.position[0]) > 0.95) {
              // Destroy enemy ship when it reaches the other side
              entities.delete(ship.id);
            }
          }
        }

        spawnEnemyShip() {
          const side = Math.random() < 0.5 ? -0.9 : 0.9; // Randomly choose left or right side
          const enemyShip = {
            template: "enemyShip",
            position: [side, Math.random() * 2 - 1, 0],
            velocity: [this.xVelocity * -side, 0, 0] // Move towards center
          };
          entities.set(`enemy${Date.now()}`, enemyShip);
        }
      }

      deps.register("EnemyShipSystem", new EnemyShipSystem(), 1);
    }
  </script>
  <script id="3283" type="application/vnd.observable.javascript">
    viewof EnemyShipSystem_v2 = {
      ({
        prompt:
          "Add a UI to the enemy spawning system, e.g. spawn rate, x velocity, y adjust probability, y velocity adjust magnitude etc. Keep the logic identical",
        time: 1700685553019,
        comment:
          "Add UI for the enemy ship spawning system and keep the logic identical"
      });

      const enemyShipSpawningSettings = view`<div>
        <h2>Enemy Ship Spawning Settings</h2>
        ${[
          "spawn_probability",
          Inputs.range([0, 0.02], {
            value: 0.001,
            step: 0.001,
            label: "Spawn probability per tick"
          })
        ]}
        ${[
          "x_velocity",
          Inputs.range([0, 0.01], {
            value: 0.002,
            step: 0.0001,
            label: "X velocity towards center"
          })
        ]}
        ${[
          "y_adjust_probability",
          Inputs.range([0, 0.2], {
            value: 0.1,
            step: 0.01,
            label: "Y velocity adjust probability per tick"
          })
        ]}
        ${[
          "y_velocity_adjust",
          Inputs.range([0, 0.002], {
            value: 0.001,
            step: 0.0001,
            label: "Y velocity adjust magnitude"
          })
        ]}
      </div>`;

      class EnemyShipSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.spawningSettings = enemyShipSpawningSettings.value;
        }

        tick() {
          const gameRunning = gameState.state === "Running";
          if (
            gameRunning &&
            Math.random() < this.spawningSettings.spawn_probability
          ) {
            // Spawn an enemy ship with low probability
            this.spawnEnemyShip();
          }

          for (let [id, ship] of entities.entries()) {
            if (ship.template !== "enemyShip") continue;
            if (Math.random() < this.spawningSettings.y_adjust_probability) {
              // Adjust y velocity with low probability
              ship.velocity[1] +=
                (Math.random() - 0.5) * this.spawningSettings.y_velocity_adjust;
            }
            if (ship.position && Math.abs(ship.position[0]) > 0.95) {
              // Destroy enemy ship when it reaches the other side
              entities.delete(id);
            }
          }
        }

        spawnEnemyShip() {
          const side = Math.random() < 0.5 ? -0.9 : 0.9; // Randomly choose left or right side
          const enemyShip = {
            id: `enemy${Date.now()}`,
            template: "enemyShip",
            position: [side, Math.random() * 2 - 1, 0],
            velocity: [this.spawningSettings.x_velocity * -side, 0, 0] // Move towards center
          };
          entities.set(enemyShip.id, enemyShip);
        }
      }

      deps.register("EnemyShipSystem", new EnemyShipSystem(), 2);

      return enemyShipSpawningSettings;
    }
  </script>
  <script id="3606" type="application/vnd.observable.javascript">
    viewof PlayerLazerEnemyCollisionSystem = {
      ({
        prompt:
          "Add a system for checking if the players lazer overlaps the enemy and removes it and increments the score. Add a UI for critical parameters.",
        time: 1700995837938,
        comment:
          "Create a system to handle collisions between player's lazer and enemy ships"
      });

      const lazerEnemyCollisionSettings = deps.resolve("generateUIPanel")({
        score_per_hit: {
          type: "range",
          label: "Score per Hit",
          options: { min: 0, max: 100, value: 10, step: 1 },
          callback: (e) => (globalThis.scorePerHit = e.target.value)
        },
        bullet_ship_radius: {
          type: "range",
          label: "bullet_ship_radius",
          options: { min: 0, max: 1, value: 0.06, step: 0.001 },
          callback: (e) => (globalThis.bullet_ship_radius = e.target.value)
        }
      });

      class PlayerLazerEnemyCollisionSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          const lazers = Array.from(entities.values()).filter(
            (e) => e.template === "projectile"
          );
          const enemyShips = Array.from(entities.values()).filter(
            (e) => e.template === "enemyShip"
          );

          lazers.forEach((lazer) => {
            enemyShips.forEach((enemy) => {
              if (
                deps.resolve("collisionDetection")(
                  lazer,
                  enemy,
                  globalThis.bullet_ship_radius
                )
              ) {
                gameState.score += globalThis.scorePerHit;
                deps.resolve("removeEntity")(lazer.id);
                deps.resolve("removeEntity")(enemy.id);
              }
            });
          });
        }
      }

      deps.register(
        "PlayerLazerEnemyCollisionSystem",
        new PlayerLazerEnemyCollisionSystem(),
        1
      );

      return lazerEnemyCollisionSettings;
    }
  </script>
  <script id="3459" type="application/vnd.observable.javascript" pinned="">
    deps.resolve("generateUIPanel")
  </script>
  <script id="3324" type="application/vnd.observable.javascript">
    viewof EnemyLazerSystem = {
      ({
        prompt:
          "Add a system with UI that spawns enemy lazers from enemy ships randomly with some probability",
        time: 1700725096036,
        comment:
          "Add system with UI that spawns enemy lazers from enemy ships randomly"
      });

      const enemyLazerSettings = view`<div>
        <h2>Enemy Lazer Settings</h2>
        ${[
          "lazer_probability",
          Inputs.range([0, 1], {
            value: 0.1,
            step: 0.001,
            label: "Lazer spawn probability per tick"
          })
        ]}
        ${[
          "lazer_speed",
          Inputs.range([0, 0.01], {
            value: 0.005,
            step: 0.001,
            label: "Lazer speed"
          })
        ]}
        ${[
          "lazer_ttl",
          Inputs.range([0, 300], {
            value: 100,
            step: 10,
            label: "Lazer time-to-live"
          })
        ]}
      </div>`;

      class EnemyLazerSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.lazerSettings = enemyLazerSettings.value;
        }

        tick() {
          const enemyShips = Array.from(entities.values()).filter(
            (e) => e.template === "enemyShip"
          );
          enemyShips.forEach((ship) => {
            if (Math.random() < this.lazerSettings.lazer_probability) {
              this.spawnLazer(ship);
            }
          });
        }

        spawnLazer(ship) {
          const angle = Math.random() * Math.PI * 2;
          const lazer = {
            id: `lazer${Date.now()}`,
            template: "enemyLazer",
            position: [ship.position[0], ship.position[1], angle],
            velocity: [
              Math.cos(angle) * this.lazerSettings.lazer_speed,
              Math.sin(angle) * this.lazerSettings.lazer_speed,
              0
            ],
            ttl: this.lazerSettings.lazer_ttl
          };
          entities.set(lazer.id, lazer);
        }
      }

      deps.register("EnemyLazerSystem", new EnemyLazerSystem(), 1);

      return enemyLazerSettings;
    }
  </script>
  <script id="3354" type="application/vnd.observable.javascript">
    viewof enemyLazer_template = {
      ({
        prompt:
          "create an enemyLazer template, add a UI for its visual parameters ",
        time: 1700850741421,
        comment: "Create enemyLazer template with UI for visual parameters"
      });

      const enemyLazerSettings = view`<div>
        <h2>Enemy Lazer Template</h2>
        ${[
          "length",
          Inputs.range([0.01, 0.2], {
            value: 0.1,
            label: "Lazer length"
          })
        ]}
        ${[
          "width",
          Inputs.range([0.001, 0.01], {
            value: 0.003,
            label: "Lazer width"
          })
        ]}
        ${[
          "color",
          Inputs.color({
            value: "#1eff00",
            label: "Lazer color"
          })
        ]}
      </div>`;

      const updateEnemyLazerTemplate = () => {
        const settings = enemyLazerSettings.value;
        const enemyLazer = htl.svg`<line x1="0" y1="0" x2="${settings.length}" y2="0" style="stroke:${settings.color};stroke-width:${settings.width}" />`;
        assets.set("enemyLazer", enemyLazer);
      };

      // Update lazer template when settings change
      enemyLazerSettings.addEventListener("input", updateEnemyLazerTemplate);
      updateEnemyLazerTemplate(); // Initialize template

      return enemyLazerSettings;
    }
  </script>
  <script id="3875" type="application/vnd.observable.javascript">
    generateNeonGlowFilter_v6 = {
      ({
        prompt:
          "No the v5 leads to a background color. We should not need to supply a color in the filter. The color should be derived from bluring the source image.\n",
        time: 1701026953278,
        comment:
          "Generate a neon glow filter that derives color by blurring the source graphic"
      });

      const generateNeonGlowFilter = (id, blur, color, intensity) => {
        const filter = htl.svg`<filter id="${id}" x="-100%" y="-100%" width="300%" height="300%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="${blur}" result="blurred"/>
          <feFlood flood-color="${color}" result="flood"/>
          <feComposite in2="SourceGraphic" in="flood" operator="atop" result="colored"/>
          <feGaussianBlur in="colored" stdDeviation="0.001" result="detail"/>


          <feColorMatrix type="matrix" in="blurred" result="intensified"
            values="${intensity} 0 0 0 0
                    0 ${intensity} 0 0 0
                    0 0 ${intensity} 0 0
                    0 0 0 1 0" />

          <feMerge>
            <feMergeNode in="intensified" />
            <feMergeNode in="detail"/>
          </feMerge>
        </filter>`;

        return filter;
      };

      deps.register("neonGlowFilterGenerator", generateNeonGlowFilter, 6);
    }
  </script>
  <script id="3654" type="application/vnd.observable.javascript">
    viewof generateNeonGlowFilterPreview = {
      ({
        prompt:
          "Lets create a neon glow filter generator that takes various arguments, and a UI for previewing the effect on a boulder as a sample",
        time: 1700997430208,
        comment:
          "Create a neon glow filter generator with a UI for previewing the effect on a boulder"
      });

      const neonGlowSettings = view`<div>
        <h2>Neon Glow Filter Settings</h2>
        ${[
          "blur",
          Inputs.range([0, 1], {
            value: 0.012,
            step: 0.001,
            label: "Blur amount"
          })
        ]}
        ${[
          "color",
          Inputs.color({
            value: "#ffffff",
            label: "Glow color"
          })
        ]}
        ${[
          "intensity",
          Inputs.range([0, 100], {
            value: 2,
            step: 0.1,
            label: "Glow intensity"
          })
        ]}
      </div>`;

      const generateNeonGlowFilter = deps.resolve("neonGlowFilterGenerator");

      const previewNeonGlowFilter = () => {
        const settings = neonGlowSettings.value;
        const filterId = "neon-glow-preview";
        const filter = generateNeonGlowFilter(
          filterId,
          settings.blur,
          settings.color,
          settings.intensity
        );
        const boulder = deps.resolve("generateBoulder")(0.2);

        const preview = htl.svg`<svg id="neon-filter-preview" width="100" height="100" viewBox="-0.5 -0.5 1 1">
          <defs>
            ${filter}
          </defs>
          <rect x="-1" y="-1" width="2" height="2" style="fill: black;"/>
          ${boulder.cloneNode(true)}
        </svg>`;
        preview
          .querySelector("polygon")
          .setAttribute("filter", `url(#neon-glow-preview)`);

        return preview;
      };

      // Update preview on input
      neonGlowSettings.addEventListener("input", () => {
        const previewUpdate = previewNeonGlowFilter();
        document.body
          .querySelector("#neon-filter-preview")
          .replaceWith(previewUpdate);
      });

      const initialPreview = previewNeonGlowFilter();

      return view`${["...", neonGlowSettings]}${initialPreview}`;
    }
  </script>
  <script id="3767" type="application/vnd.observable.javascript">
    generateNeonGlowFilterPreview
  </script>
  <script id="3763" type="application/vnd.observable.javascript">
    NeonFilterApplicationSystem = {
      ({
        prompt: "Update the filter when generateNeonGlowFilterPreview changes",
        time: 1701013247736,
        comment: "Create a system to apply neon filter to SVG view"
      });

      const neonGlowFilterGenerator = deps.resolve("neonGlowFilterGenerator");
      const settings = generateNeonGlowFilterPreview;
      const neonFilter = neonGlowFilterGenerator(
        "neon-filter",
        settings.blur,
        settings.color,
        settings.intensity
      );

      // Attach the filter to the defs of the game view if not already there
      const defs = game_view.querySelector("defs") || htl.svg`<defs>`;
      const existingFilter = defs.querySelector(`#neon-filter`);
      if (existingFilter) existingFilter.remove();
      defs.appendChild(neonFilter);
      game_view.insertBefore(defs, game_view.firstChild);

      // Apply the filter to all elements in the game view

      for (const el of game_view.querySelectorAll("#game-root")) {
        el.setAttribute("filter", `url(#neon-filter)`);
      }
    }
  </script>
  <script id="3825" type="application/vnd.observable.javascript" pinned="">
    entities
  </script>
  <script id="2994" type="application/vnd.observable.javascript">
    viewof startGameButton_v2 = ({
      prompt:
        "That game button freezes everything. Lets' make the button massive too using a cool retro system font.\nyou will need to manually add the player and astroids.",
      time: 1700413206526,
      comment:
        "Create a bigger start game button with retro font and manually add player and asteroids"
    } &&
      view`<div style="text-align: center; margin-top: 20px;">
      <button id="startGameButton", style="
          padding: 10px 20px;
          font-size: 2em;
          background-color: #333;
          color: white;
          border: none;
          cursor: pointer;
          font-family: 'Press Start 2P', cursive;
        "
        onclick=${() => {
          game_view.querySelector("#game-root").textContent = ""; // reset view
          // Reset game state
          gameState.lives = 3;
          gameState.score = 0;
          gameState.level = 0;
          gameState.state = "Running";

          // Clear all entities
          entities.clear();

          entities.set("score", {
            id: "score",
            position: [0, 0, 0],
            velocity: [0, 0, 0],
            force: [0, 0, 0],
            template: "score"
          });

          entities.set("lives", {
            id: "lives",
            position: [0, 0, 0],
            velocity: [0, 0, 0],
            force: [0, 0, 0],
            template: "lives"
          });

          // Add player entity
          entities.set("player", {
            id: "player",
            template: "ship",
            position: [0, 0, 0],
            velocity: [0, 0, 0],
            force: [0, 0, 0]
          });

          // Add initial boulders
          for (let i = 0; i < 2; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const velocity = [
              Math.cos(angle) * 0.0001,
              Math.sin(angle) * 0.0001,
              0
            ];
            const boulder = {
              id: `boulder${i}`,
              generator: "generateBoulder",
              generator_args: [0.2],
              radius: 0.2,
              position: [Math.random() * 2 - 1, Math.random() * 2 - 1, 0],
              velocity: velocity
            };
            entities.set(boulder.id, boulder);
          }
          document.activeElement.blur();
        }}
      >Start Game</button>
    </div>`)
  </script>
  <script id="3402" type="application/vnd.observable.javascript">
    PlayerHitByLazerSystem = {
      ({
        prompt: "Add a system if the player hits an enemy bullet they lose a life",
        time: 1700853269313,
        comment:
          "Add a system to detect player collisions with enemy lazers and decrease lives"
      });

      class PlayerHitByLazerSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.collisionRadius = 0.02; // Radius for detecting collisions
        }

        tick() {
          const player = entities.get("player");
          if (!player) return; // No player to hit
          const lazers = Array.from(entities.values()).filter(
            (e) => e.template === "enemyLazer"
          );

          lazers.forEach((lazer) => {
            const dx = player.position[0] - lazer.position[0];
            const dy = player.position[1] - lazer.position[1];
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < this.collisionRadius) {
              // Player hit by lazer
              gameState.lives -= 1;
              entities.delete(lazer.id); // Remove the lazer that hit the player
            }
          });
        }
      }

      deps.register("PlayerHitByLazerSystem", new PlayerHitByLazerSystem(), 1);
    }
  </script>
  <script id="2803" type="application/vnd.observable.javascript">
    game_view = deps.resolve("game_view")
  </script>
  <script id="3914" type="application/vnd.observable.javascript">
    backdrop = FileAttachment("image (5).png").image()
  </script>
  <script id="3926" type="application/vnd.observable.javascript">
    generateUIPanel_v2 = {
      ({
        prompt: "Rewrite the UI panel using a bindable view",
        time: 1700899857021,
        comment: "UI panel generator routine"
      });

      function generateUIPanel(settings) {
        return view`${[
          "...",
          Object.entries(settings).map(([key, value]) => {
            const wrapper = document.createElement("div");
            const args =
              value.type === "range"
                ? [[value.options.min, value.options.max], value.options]
                : [value.options];

            const input = Inputs[value.type](...args);
            input.addEventListener("input", value.callback);
            input.dispatchEvent(new Event("input"));
            return [key, input];
          })
        ]}`;
      }

      deps.register("generateUIPanel", generateUIPanel, 2);
    }
  </script>
  <script id="3940" type="application/vnd.observable.javascript">
    viewof positionView = {
      ({
        prompt:
          "write a UI for x,y,width,height in -1 to +1 range called positionView",
        time: 1701104257534,
        comment: "Create a UI for x, y, width, and height in the -1 to +1 range"
      });

      const positionSettings = {
        x: Inputs.range([-1, 1], { value: -0.42, step: 0.01, label: "X position" }),
        y: Inputs.range([-1, 1], { value: -0.59, step: 0.01, label: "Y position" }),
        width: Inputs.range([-1, 1], { value: -0.17, step: 0.01, label: "Width" }),
        height: Inputs.range([-1, 1], { value: 0.03, step: 0.01, label: "Height" })
      };

      const positionView = view`<div>
        <h2>Position View</h2>
        ${["...", positionSettings]}
      </div>`;

      return positionView;
    }
  </script>
  <script id="3943" type="application/vnd.observable.javascript">
    viewof positionStartButton = {
      ({
        prompt:
          "write a UI for x,y,width,height in -1 to +1 range called positionStartButton",
        time: 1701104319993,
        comment: "Create a UI for x, y, width, and height in the -1 to +1 range"
      });

      const positionSettings = {
        x: Inputs.range([-1, 1], { value: 0, step: 0.01, label: "X position" }),
        y: Inputs.range([-1, 1], { value: 0, step: 0.01, label: "Y position" }),
        width: Inputs.range([-1, 1], { value: 1, step: 0.01, label: "Width" }),
        height: Inputs.range([-1, 1], { value: 1, step: 0.01, label: "Height" })
      };

      const positionView = view`<div>
        <h2>Position and Size (start button)</h2>
        ${["...", positionSettings]}
      </div>`;

      return positionView;
    }
  </script>
  <script id="3957" type="application/vnd.observable.javascript" pinned="">
    positionView
  </script>
  <script id="3971" type="application/vnd.observable.javascript">
    game_view_v3 = {
      ({
        prompt:
          "create a new game_view that does fill the content area instead of having a specified height and width",
        time: 1701105057172,
        comment: "Create a new game_view that fills the content area"
      });

      const game_view = htl.html`<svg
        style="width: 100%; height: 100%; filter: url(#crt-warp)"
        preserveAspectRatio="none"
        viewBox="-1 -1 2 2">
        <g id="unfiltered"></g>
        <g id="game-root"></g>
      </svg>`;

      deps.register("game_view", game_view, 3);
    }
  </script>
  <script id="4231" type="text/markdown">
    ### Sidequest Filtering

    iterating on the filter on its own
    https://observablehq.com/d/7b8e4503e0cabb68
  </script>
  <script id="4273" type="text/markdown">
    ### Audio
  </script>
  <script id="4287" type="application/vnd.observable.javascript">
    audio = ({
      explode: htl.html`<audio src=${await FileAttachment(
        "pop2-84862.mp3"
      ).url()}>`,
      shot: htl.html`<audio src=${await FileAttachment(
        "laser-gun-shot-sound-future-sci-fi-lazer-wobble-chakongaudio-174883.mp3"
      ).url()}>`,
      alarm: htl.html`<audio src=${await FileAttachment(
        "sci-fi-alarm-106436.mp3"
      ).url()}>`
    })
  </script>
  <script id="4285" type="application/vnd.observable.javascript">
    viewof selectedSound = {
      ({
        prompt:
          "Make a cell to play a selected sound effect on click. The options are in a dictionary called audio",
        time: 1701614196127,
        comment: "Create a cell to play selected sound effects on click"
      });

      const audioOptions = Object.keys(audio).map((key) => {
        return htl.html`<option value="${key}">${key}</option>`;
      });

      const selectSound = htl.html`<select>${audioOptions}</select>`;
      const playButton = htl.html`<button>Play</button>`;

      playButton.onclick = () => {
        const selectedSound = selectSound.value;
        const soundEffect = audio[selectedSound];
        if (soundEffect) soundEffect.play();
      };

      const player = view`<div>${["...", selectSound]}${playButton}</div>`;

      return player;
    }
  </script>
  <script id="4299" type="application/vnd.observable.javascript">
    import { sample, audioContext } from "@tomlarkworthy/audio-inputs"
  </script>
  <script id="4343" type="application/vnd.observable.javascript">
    viewof shot = sample({
      loop: false,
      gain: 0.4,
      speed: 1.4,
      start: 0.06,
      end: 0.33,
      audioContext: audioContext,
      arrayBuffer: await FileAttachment(
        "laser-gun-shot-sound-future-sci-fi-lazer-wobble-chakongaudio-174883.mp3"
      ).arrayBuffer()
    })
  </script>
  <script id="4352" type="application/vnd.observable.javascript">
    viewof alarm = sample({
      loop: true,
      gain: 0.6,
      speed: 2.6,
      audioContext: audioContext,
      arrayBuffer: await FileAttachment("sci-fi-alarm-106436.mp3").arrayBuffer()
    })
  </script>
  <script id="4359" type="application/vnd.observable.javascript">
    viewof explode = sample({
      loop: false,
      gain: 0.6,
      speed: 1,
      start: 0.31,
      end: 0.52,
      audioContext: audioContext,
      arrayBuffer: await FileAttachment("pop2-84862.mp3").arrayBuffer()
    })
  </script>
  <script id="4079" type="text/markdown">
    Sound Effects from <a href="https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=106436">Pixabay</a>
  </script>
  <script id="4365" type="application/vnd.observable.javascript" pinned="">
    explode
  </script>
  <script id="4347" type="application/vnd.observable.javascript" pinned="">
    explode
  </script>
  <script id="4381" type="application/vnd.observable.javascript">
    EnemyAlarmSystem = {
      ({
        prompt:
          'I used an external system to bring audio UIs into the game. We need a system that execute  "viewof alarm.play()" when an enemy is first on screen, and "viewof alarm.stop()" when there are none.',
        time: 1701616694301,
        comment:
          "Create a system to play an alarm when the first enemy appears on screen and stop it when there are none"
      });

      let alarmPlaying = false;

      class EnemyAlarmSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          const enemiesOnScreen = Array.from(entities.values()).some(
            (e) => e.template === "enemyShip"
          );

          if (enemiesOnScreen && !alarmPlaying) {
            viewof alarm.play();
            alarmPlaying = true;
          } else if (!enemiesOnScreen && alarmPlaying) {
            viewof alarm.stop();
            alarmPlaying = false;
          }
        }
      }

      deps.register("EnemyAlarmSystem", new EnemyAlarmSystem(), 1);
    }
  </script>
  <script id="4388" type="application/vnd.observable.javascript">
    LazerShotSoundSystem = {
      ({
        prompt:
          ' We need a system that executes "viewof shot.play()" when an player shoots a lazer',
        time: 1701616815136,
        comment:
          "Create a system to play a shot sound when the player fires a lazer"
      });

      class LazerShotSoundSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.lastShotTime = 0;
        }

        tick() {
          const now = Date.now();
          const player = entities.get("player");
          if (player && keysPressed[" "] && now - this.lastShotTime > 250) {
            // Throttle sound effect to not overlap too quickly
            viewof shot.play();
            this.lastShotTime = now;
          }
        }
      }

      deps.register("LazerShotSoundSystem", new LazerShotSoundSystem(), 1);
    }
  </script>
  <script id="4392" type="application/vnd.observable.javascript">
    LazerShotSoundSystem_v2 = {
      ({
        prompt:
          "LazerShotSoundSystem doesn't work because the keyboard control clears the keyPressed state. It needs to detect the existence of a new lazer object instead (and track which it knows about) ",
        time: 1701617015743,
        comment:
          "Update LazerShotSoundSystem to play sound based on new lazer object existence"
      });

      class LazerShotSoundSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.knownLazers = new Set();
        }

        tick() {
          const lazers = Array.from(entities.values()).filter(
            (e) => e.template === "projectile"
          );

          for (const lazer of lazers) {
            if (!this.knownLazers.has(lazer.id)) {
              // Play sound for new lazer
              viewof shot.play();
              this.knownLazers.add(lazer.id);
            }
          }

          // Remove known lazers that are no longer present
          this.knownLazers.forEach((id) => {
            if (!entities.has(id)) {
              this.knownLazers.delete(id);
            }
          });
        }
      }

      deps.register("LazerShotSoundSystem", new LazerShotSoundSystem(), 2);
    }
  </script>
  <script id="4396" type="application/vnd.observable.javascript">
    BoulderExplodeSoundSystem = {
      ({
        prompt:
          'We need to execut "viewof explode.stop()" everytime a boulder is destroyed, again by detecting the entity dissapears',
        time: 1701617142205,
        comment:
          "Create a system to play an explosion sound when a boulder is destroyed"
      });

      class BoulderExplodeSoundSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
          this.knownBoulders = new Set();
        }

        tick() {
          const boulders = Array.from(entities.values()).filter(
            (e) => e.generator === "generateBoulder"
          );

          // Check for destroyed boulders
          this.knownBoulders.forEach((id) => {
            if (!entities.has(id)) {
              viewof explode.play();
              this.knownBoulders.delete(id);
            }
          });

          // Update known boulders
          boulders.forEach((boulder) => {
            this.knownBoulders.add(boulder.id);
          });
        }
      }

      deps.register(
        "BoulderExplodeSoundSystem",
        new BoulderExplodeSoundSystem(),
        1
      );
    }
  </script>
  <script id="4401" type="application/vnd.observable.javascript" pinned="">
    RestartGameOnSpaceSystem = {
      ({
        prompt:
          "When the game is over, clicking space should restart the game. You can acheive this by dispactching a click to the start game button. Make a system for it",
        time: 1701617460949,
        comment:
          "Create a system to restart the game when space is pressed during Game Over state"
      });

      class RestartGameOnSpaceSystem extends deps.resolve("BaseSystem") {
        constructor() {
          super();
        }

        tick() {
          if (gameState.state === "Game Over" && keysPressed[" "]) {
            debugger;
            // Space key pressed during Game Over state
            keysPressed[" "] = false; // Prevent repeated restarts
            const startButton = document.querySelector("#startGameButton");
            if (startButton) {
              startButton.click();
            }
          }
        }
      }

      deps.register("RestartGameOnSpaceSystem", new RestartGameOnSpaceSystem(), 1);
    }
  </script>
  <script id="4459" type="application/vnd.observable.javascript" pinned="">
    MobileShootOnTapSystem = {
      ({
        prompt:
          "Mobile users should be able to at least know the game works. If the user taps the view we should fake a space being pressed to shoot",
        time: 1701619598675,
        comment:
          "System to simulate spacebar press for mobile users when they tap the game view"
      });

      game_view.addEventListener("touchstart", (event) => {
        event.preventDefault();
        keysPressed[" "] = true;
      });
    }
  </script>
  <script id="6384" type="text/markdown">
    ---
  </script>
  <script id="6386" type="text/markdown">
    #### Robocoop interface

    This is the prompting interface of roboco-op
  </script>
  <script id="81" type="application/vnd.observable.javascript">
    viewof prompt
  </script>
  <script id="1014" type="application/vnd.observable.javascript">
    Inputs.button("copy code", {
      reduce: () => {
        navigator.clipboard.writeText(suggestion);
      }
    })
  </script>
  <script id="105" type="application/vnd.observable.javascript">
    viewof suggestion
  </script>
  <script id="1463" type="text/markdown">
    ## Current Chat context
  </script>
  <script id="1252" type="application/vnd.observable.javascript">
    viewof context_viz
  </script>
  <script id="1470" type="text/markdown">
    tick the cells to include in the next prompt
  </script>
  <script id="1473" type="application/vnd.observable.javascript">
    viewof feedback_cells_selector
  </script>
  <script id="1542" type="application/vnd.observable.javascript">
    feedback_prompt
  </script>
  <script id="1692" type="text/markdown">
    ### AI Settings
  </script>
  <script id="29" type="application/vnd.observable.javascript">
    viewof OPENAI_API_KEY
  </script>
  <script id="2061" type="application/vnd.observable.javascript">
    viewof api_endpoint
  </script>
  <script id="2163" type="application/vnd.observable.javascript">
    viewof settings
  </script>
  <script id="2193" type="text/markdown">
    ---
  </script>
  <script id="4083" type="application/vnd.observable.javascript" pinned="">
    source["crtWarpDisplacementMap"]
  </script>
  <script id="2114" type="application/vnd.observable.javascript">
    import {
      source,
      code,
      ask,
      excludes,
      cells,
      update_context,
      on_prompt,
      api_call_response,
      mutable context,
      viewof prompt,
      viewof suggestion,
      viewof settings,
      viewof OPENAI_API_KEY,
      viewof api_endpoint,
      feedback_prompt,
      viewof feedback_cells_selector,
      viewof context_viz
    } from "@tomlarkworthy/robocoop"
  </script>
  <script id="2179" type="application/vnd.observable.javascript">
    workers = {
      update_context;
      on_prompt;
      return api_call_response;
    }
  </script>
</notebook>
