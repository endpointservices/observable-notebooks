<!doctype html>
<notebook theme="air">
  <title>BLOG: Firestore's Technical Advantages</title>
  <script id="414" type="application/vnd.observable.javascript" pinned="">
    title = html`<div id="blogtitle" class=content>${
    md`# BLOG: Firestore's Technical Advantages
    `}`
  </script>
  <script id="561" type="application/vnd.observable.javascript">
    md`Live ${metadata.url}`
  </script>
  <script id="524" type="application/vnd.observable.javascript" pinned="">
    metadata = ({
      description:
        "Don't underestimate Firestore, for many situations, its the world #1",
      notebook:
        'https://observablehq.com/@tomlarkworthy/blog-netlify-deployment-manager',
      tags: ["article", "firebase"],
      image:
        "https://storage.googleapis.com/o_tomlarkworthy_toms/public/blogs/firestore.png",
      get title() {
        return document.getElementById("blogtitle").innerText.replace("BLOG: ", "");
      },
      content: content.outerHTML,
      get target() {
        return `/blogs/${string_to_slug(this.title)}.html`;
      },
      twitterCreator: "@tomlarkworthy",
      get url() {
        return 'https://tomlarkworthy.endpointservices.net' + this.target;
      }
    })
  </script>
  <script id="504" type="application/vnd.observable.javascript">
    viewof settings = deployStaticFile({
      ...metadata,
      app_id: 'b6a918d2-9cda-4fde-b2ec-add91b22ea02',
      source: preview.href
    })
  </script>
  <script id="8" type="application/vnd.observable.javascript">
    preview = deploy("preview", (req, res) => {
      res.header("Access-Control-Allow-Origin", "*"); 
      return res.send(page)
    })
  </script>
  <script id="960" type="application/vnd.observable.javascript">
    md`# Social image

    ![](${metadata.image})`
  </script>
  <script id="0" type="application/vnd.observable.javascript">
    content = html`<div class=content>${md`

    ![](https://storage.googleapis.com/o_tomlarkworthy_toms/public/blogs/firestore.png)

    I have read some pretty poor articles bashing Firestore recently. Generally they completely miss the features set or cargo cult Postgres SQL. This article attempt to highlight the features of Firestore that you won't see with a Postgres solution (note I love Postgres), highlighting several area's where Firestore is the world #1.

    ## Clientside first

    It's designed for a direct connection to a mobile/webapp. This means it has a number of features that are unmatched in the market.

    ### Latency compensation

    Firestore maintains a local cache, so local writes and observable immediately. Greatly simplifying controller design. It even broadcasts writes to adjacent tabs in the browser for 0 latency across browser tabs. *You ain't got time to implement that!*

    ### Offline persistence

    The cache is backed by persistent storage, so your app works offline without much work. This is a huge feature that is difficult to get right and essential for a good mobile experience.

    ### Authorisation rules

    The database has a layer of security rules which are very flexible and can depend on values in the database. 

    ### Causal Consistency

    Client SDKs observe their own writes first, and remote writes sometime later. Firestore guarantees that remote writes preserve their order. This is better than eventual consistency, its causal consistency and the best you can manage in a distributed setting.
    The fact write order is preserved makes the system very intuitive, but many Firestore competitors do not guarantee this property which leads to weird bugs and second guessing.

    ### 1M concurrent clients

    Its not so easy to support 1M **concurrent** connections, that's serious engineering work.


    ## Spanner Backed

    Firestore somewhat outclasses Postgres on underlying database technology too, being based on Google Spanner. Firestore is the most affordable way to access a Google Spanner based database.

    ### 99.999% SLA

    Yes. You probably can't find a more reliable cross region database.

    ### Multi-region yet strong consistency

    Writes are replicated across multiple regions. This is one of the reasons why it is so reliable, it is resistant to single data centre losses. It can achieve this AND still be strongly consistent. It is simply not possible to configure Postgres to be multi region and be strongly consistent. This is really what Spanner brings to the table.

    ### Transactions

    Firestore can do atomic writes across documents, without _caveats_, without _sharding_. Very few distributed databases can achieve this in a multi-region setting. 

    ### array-contains-any joins

    I have read that noSQL databases do not support joins at all. This is true for many NoSQL solutions, but not the full truth in Firestore's case. It is true query expressivity is lower than SQL.

    However, thanks to the "array-contains-any" query you can retrieve a set of documents matching a set of ids in a single query. This is far more efficient than having to retrieve documents on the other side of a join one at a time. Thus a SQL with 3 joins can usually be performed with 3 queries in Firestore with the appropriate indexes. Though, to be fair Postgres has the upper hand here.

    ### Scalability

    Firestore is true serverless with essentially unbounded scalability thanks to its Spanner backend. It also scales to zero so you only pay for what you use, unlike Postgres which has a fixed provisioning cost and an associated performance ceiling.

    ## Conclusion

    Postgres is a great default choice for a startup. However, if your product is used on mobile or across the globe, you might find Firestore a better match due to its state-of-the-art backend and client SDKs.

    *Disclaimer: I used to work on the Firebase databases*




    `}`
  </script>
  <script id="590" type="application/vnd.observable.javascript">
    page = `<!doctype html>
    <html class="has-navbar-fixed-top">
      <head>
        ${articleHeader(metadata).outerHTML}
      </head>
      <body>
        ${topbar.outerHTML}
        <div class="columns">
          ${sidebar.outerHTML}
          <div class="column is-half">
            ${html`<div class="content"><h1>${metadata.title}`.outerHTML}
            ${content.outerHTML}
          </div>
        </div>
        ${articleFooter(metadata).outerHTML}
      </body>
    </html>`
  </script>
  <script id="938" type="application/vnd.observable.javascript">
    function string_to_slug (str) {
        str = str.replace(/^\s+|\s+$/g, ''); // trim
        str = str.toLowerCase();

        // remove accents, swap ñ for n, etc
        var from = "àáãäâèéëêìíïîòóöôùúüûñç·/_,:;";
        var to   = "aaaaaeeeeiiiioooouuuunc------";

        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }

        str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars
            .replace(/\s+/g, '-') // collapse whitespace and replace by -
            .replace(/-+/g, '-'); // collapse dashes

        return str;
    }
  </script>
  <script id="408" type="application/vnd.observable.javascript">
    import {deployStaticFile} from '@tomlarkworthy/netlify-deploy'
  </script>
  <script id="242" type="application/vnd.observable.javascript">
    import {sidebar, topbar, articleHeader, articleFooter, deploy, html, svg} from '@tomlarkworthy/blog-navigation'
  </script>
  <script id="384" type="application/vnd.observable.javascript">
    import {icon} from "@chitacan/rss"
  </script>
  <script id="1003" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="1021" type="application/vnd.observable.javascript" pinned="">
    footer
  </script>
</notebook>
