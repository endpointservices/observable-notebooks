<!doctype html>
<notebook theme="air">
  <title>Fast 1D Circular Barcode Matching</title>
  <script id="0" type="text/markdown">
    # Fast 1D Circular Barcode Matching
    ## with the Möbius transform


    The aim of this notebook is to prototype a way of quickly detecting the center and tilt of a circular barcode passing through a scan line. This will be a building block of a localization algorithm.

    Part II of a long quest to create a cheap high speed optical localization system. Part I is [here](https://observablehq.com/@tomlarkworthy/circular-barcode-simulator).
  </script>
  <script id="4" type="application/vnd.observable.javascript">
    import {
      viewof scanY,
      canvas,
      pixelBuffer,
      renders,
      scanline,
      overlay,
      template
    } from "@tomlarkworthy/circular-barcode-simulator"
  </script>
  <script id="638" type="text/markdown">
    ### Final Matched Barchode projection
    It works! If the scanline passed through the centre of a circular barcode, this matches the pattern.
  </script>
  <script id="632" type="application/vnd.observable.javascript">
    Plot.plot({
      width,
      height: 100,
      y: { axis: false },
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.tickX(autoFitProjectedTemplate, {
          x: (d) => d.x
        })
      ]
    })
  </script>
  <script id="364" type="application/vnd.observable.javascript">
    viewof scanY
  </script>
  <script id="661" type="text/html">
    <div style="scale: 0.955">
      ${canvas}
    </div>
  </script>
  <script id="655" type="text/markdown">
    ## Implementation
  </script>
  <script id="517" type="text/markdown">
    #### Pixel intensity through scan line
  </script>
  <script id="114" type="application/vnd.observable.javascript">
    viewof scanLinePlot = Plot.plot({
      width,
      marks: [Plot.tickX(scanLineBuffer, { x: (d, i) => i, stroke: (d) => d })]
    })
  </script>
  <script id="102" type="application/vnd.observable.javascript">
    scanLineBuffer = new Uint8Array(scanline.map((p) => p.v))
  </script>
  <script id="122" type="application/vnd.observable.javascript">
    scanEdges = edges1D(scanLineBuffer, 20)
  </script>
  <script id="423" type="text/markdown">
    #### (manual) Find three known edges
  </script>
  <script id="327" type="text/markdown">
    Click the leftmost side of the circular pattern, the rightmost side and then the right of the middle as the three rings to fit mobius to
  </script>
  <script id="165" type="application/vnd.observable.javascript">
    viewof leftmost = Plot.plot({
      width,
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.tickX(scanEdges, { x: (d) => d.x, stroke: (d) => d.s, tip: true }),
        Plot.dot(scanEdges, Plot.pointer({ x: (d) => d.x }))
      ]
    })
  </script>
  <script id="259" type="application/vnd.observable.javascript">
    viewof rightmost = Plot.plot({
      width,
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.tickX(scanEdges, { x: (d) => d.x, stroke: (d) => d.s, tip: true }),
        Plot.dot(scanEdges, Plot.pointer({ x: (d) => d.x }))
      ]
    })
  </script>
  <script id="261" type="application/vnd.observable.javascript">
    viewof middle_right = Plot.plot({
      width,
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.tickX(scanEdges, { x: (d) => d.x, stroke: (d) => d.s, tip: true }),
        Plot.dot(scanEdges, Plot.pointer({ x: (d) => d.x }))
      ]
    })
  </script>
  <script id="421" type="text/markdown">
    #### Initial Mobius Fit to 3 anchors
  </script>
  <script id="352" type="text/markdown">
    Predicted template positions given pqrs fit to anchors.
  </script>
  <script id="302" type="application/vnd.observable.javascript">
    Plot.plot({
      width,
      height: 100,
      y: { axis: false },
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.tickX(template_projection, {
          x: (d) => d.x
        })
      ]
    })
  </script>
  <script id="465" type="text/markdown">
    ##### Residuals on initial template fit
  </script>
  <script id="452" type="application/vnd.observable.javascript">
    Plot.plot({
      width,
      height: 100,
      color: {
        domain: [0, 1]
      },
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.ruleX(initialAlignment.pairs, {
          x: (d) => d.xt,
          y: (d) => (d.cost == 20 ? 0 : d.cost),
          stroke: (d) => (d.cost == 20 ? 0 : d.cost)
        })
      ]
    })
  </script>
  <script id="414" type="text/markdown">
    ### Least squares Möbius fit to template match
  </script>
  <script id="429" type="application/vnd.observable.javascript">
    Plot.plot({
      width,
      height: 100,
      y: { axis: false },
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.tickX(mobiusLSFit.fittedProjection, {
          x: (d) => d.x
        })
      ]
    })
  </script>
  <script id="485" type="text/markdown">
    ##### Residuals on LS template fit: kRMSE ${mobiusLSFit.kRMSE}
  </script>
  <script id="473" type="application/vnd.observable.javascript">
    Plot.plot({
      width,
      height: 100,
      color: {
        domain: [0, 1]
      },
      x: {
        domain: [0, width]
      },
      marks: [
        Plot.ruleX(residualsLS, {
          x: (d) => d.x,
          y: (d) => (d.cost == 20 ? 0 : d.cost),
          stroke: (d) => (d.cost == 20 ? 0 : d.cost)
        })
      ]
    })
  </script>
  <script id="512" type="text/markdown">
    # Code
  </script>
  <script id="345" type="text/markdown">
    ### fit a Möbius transform to three points
  </script>
  <script id="125" type="application/vnd.observable.javascript">
    function fitMobius(pairs) {
      if (pairs.length < 3) throw new Error("need >=3 pairs");
      const a = pairs[0],
        b = pairs[1],
        c = pairs[2];
      // guard degeneracies
      if (a.x === b.x || a.x === c.x || b.x === c.x)
        throw new Error("x must be distinct");
      if (b.k === a.k || b.k === c.k) throw new Error("k must satisfy B≠A and B≠C");

      const A = a.k,
        B = b.k,
        C = c.k;
      const alpha = (B - C) / (B - A);

      // M(z) = CR(z; a.x,b.x,c.x) = ((b-c)z - (b-c)a) / ((b-a)z - (b-a)c)
      const m11 = b.x - c.x;
      const m12 = -a.x * (b.x - c.x);
      const m21 = b.x - a.x;
      const m22 = -c.x * (b.x - a.x);

      // L(w) = (C w - alpha A) / (w - alpha)  maps {0,1,∞} -> {A,B,C}
      const l11 = C,
        l12 = -alpha * A,
        l21 = 1,
        l22 = -alpha;

      // Composition T = L ∘ M  ⇒  [p q; r s] = L · M  (up to scale)
      let p = l11 * m11 + l12 * m21;
      let q = l11 * m12 + l12 * m22;
      let r = l21 * m11 + l22 * m21;
      let s = l21 * m12 + l22 * m22;

      // normalize scale
      if (Math.abs(s) > 1e-12) {
        p /= s;
        q /= s;
        r /= s;
        s = 1;
      } else {
        const norm = Math.hypot(p, q, r, s) || 1;
        p /= norm;
        q /= norm;
        r /= norm;
        s /= norm;
      }
      return { p, q, r, s };
    }
  </script>
  <script id="254" type="application/vnd.observable.javascript">
    pqrs = fitMobius([
      { ...leftmost, k: -27 },
      { ...middle_right, k: 5 },
      { ...rightmost, k: 27 }
    ])
  </script>
  <script id="442" type="text/markdown">
    ### Predict template edges given fit
  </script>
  <script id="332" type="application/vnd.observable.javascript">
    template_edges = binaryToEdges(template)
  </script>
  <script id="286" type="application/vnd.observable.javascript">
    function xFromK(pqrs, k) {
      const denom = k * pqrs.r - pqrs.p;
      if (Math.abs(denom) < 1e-12) return NaN; // parallel / undefined
      return (pqrs.q - k * pqrs.s) / denom;
    }
  </script>
  <script id="290" type="application/vnd.observable.javascript">
    template_projection = template_edges.map((k) => ({ k, x: xFromK(pqrs, k) }))
  </script>
  <script id="411" type="text/markdown">
    ### Obtain closest matching edges to initial Möbius estimate
  </script>
  <script id="386" type="application/vnd.observable.javascript">
    dpAlign = function dpAlign(template, scan, opts = {}) {
      // Needleman-Wunsch style dynamic programming alignment for 1D positions.
      // template: array of numbers or objects with .x and optional .s (polarity)
      // scan:     array of numbers or objects with .x and optional .s (polarity)
      // opts:
      //   gapPenalty (number) default 20
      //   polarityPenalty (number) default 50
      //   matchCost (fn) optional custom cost fn (xt, xs) -> number; defaults to abs difference
      //   matchThreshold (number) if provided, matches with cost > threshold are discouraged (treated normally by DP)
      const {
        gapPenalty = 20,
        polarityPenalty = 50,
        matchCost = (a, b) => Math.abs(a - b),
        matchThreshold = Infinity
      } = opts;

      const N = template.length,
        M = scan.length;
      // helpers to extract x and polarity
      const getX = (v) =>
        typeof v === "number" ? v : v && ("x" in v ? v.x : v.x === 0 ? 0 : v);
      const getS = (v) =>
        typeof v === "number"
          ? v
          : v && "s" in v
          ? v.s
          : v && "sign" in v
          ? v.sign
          : 0;

      // DP matrices: use flat arrays for speed
      const rows = N + 1,
        cols = M + 1;
      const D = new Float64Array(rows * cols); // cost matrix
      const PTR = new Int8Array(rows * cols); // 0 = diag, 1 = up (delete template / gap in scan), 2 = left (insert / gap in template)

      const idx = (i, j) => i * cols + j;

      // initialize
      for (let i = 1; i <= N; i++) {
        D[idx(i, 0)] = i * gapPenalty;
        PTR[idx(i, 0)] = 1; // from up
      }
      for (let j = 1; j <= M; j++) {
        D[idx(0, j)] = j * gapPenalty;
        PTR[idx(0, j)] = 2; // from left
      }

      // fill
      for (let i = 1; i <= N; i++) {
        const xt = getX(template[i - 1]);
        const st = getS(template[i - 1]);
        for (let j = 1; j <= M; j++) {
          const xs = getX(scan[j - 1]);
          const ss = getS(scan[j - 1]);
          let mcost = matchCost(xt, xs);
          // polarity penalty (if either side has a defined sign and they differ)
          if (st && ss && Math.sign(st) !== Math.sign(ss)) mcost += polarityPenalty;
          // match threshold can be used by caller to interpret results (we don't hard forbid >threshold here)
          const diag = D[idx(i - 1, j - 1)] + mcost;
          const up = D[idx(i - 1, j)] + gapPenalty; // skip template[i-1]
          const left = D[idx(i, j - 1)] + gapPenalty; // skip scan[j-1]
          // choose minimum (prefer diag on ties, then up)
          let best = diag,
            ptr = 0;
          if (up < best || (up === best && ptr !== 0 && ptr !== 1)) {
            best = up;
            ptr = 1;
          }
          if (left < best) {
            best = left;
            ptr = 2;
          }
          D[idx(i, j)] = best;
          PTR[idx(i, j)] = ptr;
        }
      }

      // backtrace
      let i = N,
        j = M;
      const pairs = []; // aligned pairs (ti, sj, cost)
      while (i > 0 || j > 0) {
        const p = PTR[idx(i, j)];
        if (p === 0) {
          // diagonal => match template[i-1] with scan[j-1]
          const xt = getX(template[i - 1]),
            xs = getX(scan[j - 1]);
          let c = matchCost(xt, xs);
          const st = getS(template[i - 1]),
            ss = getS(scan[j - 1]);
          if (st && ss && Math.sign(st) !== Math.sign(ss)) c += polarityPenalty;
          pairs.push({ ti: i - 1, sj: j - 1, cost: c, xt, xs, st, ss });
          i--;
          j--;
        } else if (p === 1) {
          // up => gap in scan (template element skipped)
          pairs.push({
            ti: i - 1,
            sj: null,
            cost: gapPenalty,
            xt: getX(template[i - 1]),
            xs: null,
            st: getS(template[i - 1]),
            ss: null
          });
          i--;
        } else {
          // left => gap in template (scan element skipped)
          pairs.push({
            ti: null,
            sj: j - 1,
            cost: gapPenalty,
            xt: null,
            xs: getX(scan[j - 1]),
            st: null,
            ss: getS(scan[j - 1])
          });
          j--;
        }
      }
      pairs.reverse();

      // Build template->scan mapping (one-to-one or null). If multiple matches to same scan occur (shouldn't for NW),
      // prefer the diagonal matches.
      const templateToScan = new Array(N).fill(null);
      const scanToTemplate = new Array(M).fill(null);
      for (const p of pairs) {
        if (p.ti != null && p.sj != null) {
          templateToScan[p.ti] = p.sj;
          scanToTemplate[p.sj] = p.ti;
        }
      }

      return {
        score: D[idx(N, M)],
        pairs,
        templateToScan,
        scanToTemplate,
        // expose DP dimensions so caller can inspect if desired
        N,
        M
      };
    }
  </script>
  <script id="388" type="application/vnd.observable.javascript">
    initialAlignment = dpAlign(
      template_projection.map((t) => t.x),
      scanEdges.map((s) => s.x)
    )
  </script>
  <script id="418" type="text/markdown">
    ### Least squares mobius fit to paired edges
  </script>
  <script id="354" type="application/vnd.observable.javascript">
    function fitMobiusLS(pairs) {
      const N = pairs.length;
      if (N < 3) throw new Error("need >=3 points");

      // Build A as N×4 array
      const A = new Array(N);
      for (let i = 0; i < N; i++) {
        const { x, k } = pairs[i];
        A[i] = [x, 1, -k * x, -k];
      }

      // SVD: A = U Σ Vᵀ
      const { v } = SVD(A);

      // v is 4×4; columns are right singular vectors
      // The column corresponding to the smallest singular value is the nullspace vector
      const smallestColIndex = 3; // svd-js returns singular values in descending order
      let p = v[0][smallestColIndex];
      let q = v[1][smallestColIndex];
      let r = v[2][smallestColIndex];
      let s = v[3][smallestColIndex];

      // normalize so s = 1
      if (Math.abs(s) > 1e-12) {
        p /= s;
        q /= s;
        r /= s;
        s = 1;
      }

      return { p, q, r, s };
    }
  </script>
  <script id="406" type="application/vnd.observable.javascript">
    mobiusLSFit = {
      const matches = initialAlignment.pairs.filter(
        (p) => p.ti != null && p.sj != null
      );
      const pairs = matches.map((p) => ({
        x: scanEdges[p.sj].x,
        k: template_projection[p.ti].k
      }));
      if (pairs.length < 3) throw new Error("need >=3 matched pairs for mobiusLS");
      const mobiusLS = fitMobiusLS(pairs);
      // compute residuals in k-space (mapped k from x) and attach diagnostics
      const { p, q, r, s } = mobiusLS;
      const kErrs = pairs.map(({ x, k }) => {
        const khat = (p * x + q) / (r * x + s);
        return khat - k;
      });
      const kRMSE = Math.sqrt(kErrs.reduce((a, b) => a + b * b, 0) / kErrs.length);
      const fittedProjection = template_projection.map((t) => ({
        k: t.k,
        x: xFromK(mobiusLS, t.k)
      }));
      mobiusLS.kRMSE = kRMSE;
      mobiusLS.pairsUsed = pairs.length;
      mobiusLS.fittedProjection = fittedProjection;
      return mobiusLS;
    }
  </script>
  <script id="476" type="application/vnd.observable.javascript">
    function calculatLSResiduals(fitted) {
      const N = fitted.length;
      const map = initialAlignment.templateToScan || [];
      const out = new Array(N);
      for (let i = 0; i < N; i++) {
        const tplX = template_projection[i].x;
        const predX = fitted[i] ? fitted[i].x : NaN;
        const sj = map[i];
        if (sj != null) {
          const actualX = scanEdges[sj].x;
          out[i] = {
            x: tplX,
            cost: Math.abs(predX - actualX),
            matched: true,
            predictedX: predX,
            actualX
          };
        } else {
          out[i] = {
            x: tplX,
            cost: 20,
            matched: false,
            predictedX: predX,
            actualX: null
          };
        }
      }
      return out;
    }
  </script>
  <script id="495" type="application/vnd.observable.javascript">
    residualsLS = calculatLSResiduals(mobiusLSFit.fittedProjection)
  </script>
  <script id="520" type="text/markdown">
    ## Auto fit anchors
  </script>
  <script id="571" type="application/vnd.observable.javascript" pinned="">
    computeAnchorCandidatesFast = function computeAnchorCandidatesFast(
      template_edges,
      scanEdges,
      opts = {}
    ) {
      const kSorted = template_edges.slice().sort((a, b) => a - b);
      if (kSorted.length < 4) throw new Error("need >=4 template edges");
      const kMin = kSorted[0],
        kMax = kSorted[kSorted.length - 1],
        kLeftInner = kSorted[1],
        kRightInner = kSorted[kSorted.length - 2];
      const sLen = scanEdges.length;
      if (sLen < 4) return [];
      const innerExpected = kSorted.length - 2;
      const minBetween = Math.max(2, opts.minBetween ?? innerExpected - 1);
      const maxBetween = Math.min(sLen - 2, opts.maxBetween ?? innerExpected + 1);
      const topK = opts.topK ?? 10;
      const scanX = scanEdges.map((e) => (typeof e === "number" ? e : e.x));
      const candidates = [];
      for (let i = 0; i < sLen - 1; i++) {
        const jMin = i + 1 + minBetween;
        const jMax = Math.min(sLen - 1, i + 1 + maxBetween);
        if (jMin >= sLen) continue;
        for (let j = jMin; j <= jMax; j++) {
          if (i + 1 >= j) continue;
          const pairs4 = [
            { x: scanX[i], k: kMin },
            { x: scanX[i + 1], k: kLeftInner },
            { x: scanX[j - 1], k: kRightInner },
            { x: scanX[j], k: kMax }
          ];
          let mob;
          try {
            mob = fitMobiusLS(pairs4);
            if (
              !(
                isFinite(mob.p) &&
                isFinite(mob.q) &&
                isFinite(mob.r) &&
                isFinite(mob.s)
              )
            )
              continue;
          } catch {
            continue;
          }
          const kErrs = new Array(pairs4.length);
          let bad = false;
          for (let t = 0; t < pairs4.length; t++) {
            const x = pairs4[t].x,
              k = pairs4[t].k;
            const den = mob.r * x + mob.s;
            if (Math.abs(den) < 1e-12) {
              bad = true;
              kErrs[t] = Infinity;
            } else {
              const khat = (mob.p * x + mob.q) / den;
              kErrs[t] = khat - k;
            }
          }
          const finiteErrs = kErrs.filter((v) => isFinite(v));
          const kRMSE = finiteErrs.length
            ? Math.sqrt(
                finiteErrs.reduce((a, b) => a + b * b, 0) / finiteErrs.length
              )
            : Infinity;
          candidates.push({
            startIndex: i,
            endIndex: j,
            pairs4,
            mobiusInitial: mob,
            kRMSE
          });
        }
      }
      candidates.sort((a, b) => {
        const ka = a.kRMSE === undefined ? Infinity : a.kRMSE;
        const kb = b.kRMSE === undefined ? Infinity : b.kRMSE;
        return ka - kb;
      });
      return candidates.slice(0, topK);
    }
  </script>
  <script id="575" type="application/vnd.observable.javascript" pinned="">
    anchorCandidatesFast = computeAnchorCandidatesFast(template_edges, scanEdges, {
      topK: 20
    })
  </script>
  <script id="608" type="application/vnd.observable.javascript">
    function refineAnchorCandidates(
      candidates,
      template_edges,
      scanEdges,
      opts = {}
    ) {
      const topK = opts.topK ?? candidates.length;
      if (!Array.isArray(candidates) || candidates.length === 0) return [];
      const kSorted = template_edges.slice().sort((a, b) => a - b);
      const scanX = scanEdges.map((e) => (typeof e === "number" ? e : e.x));
      const dpOpts = {
        gapPenalty: opts.gapPenalty ?? 20,
        polarityPenalty: opts.polarityPenalty ?? 0,
        matchCost: (a, b) => Math.abs(a - b),
        matchThreshold: Infinity
      };
      const out = [];
      for (const cand of candidates) {
        const mobInit = cand.mobiusInitial ?? cand.mobius;
        if (!mobInit) continue;
        const proj = kSorted.map((k) => {
          const x = xFromK(mobInit, k);
          return x;
        });
        const alignment = dpAlign(proj, scanX, dpOpts);
        const map = alignment.templateToScan || [];
        const matchedPairs = [];
        for (let t = 0; t < kSorted.length; t++) {
          const sIdx = map[t];
          if (sIdx != null) matchedPairs.push({ x: scanX[sIdx], k: kSorted[t] });
        }
        if (matchedPairs.length < 3) continue;
        let mobRefined;
        try {
          mobRefined = fitMobiusLS(matchedPairs);
        } catch {
          continue;
        }
        const { p, q, r, s } = mobRefined;
        const kErrs = [];
        const xErrs = [];
        for (let t = 0; t < kSorted.length; t++) {
          const sIdx = map[t];
          if (sIdx == null) continue;
          const x = scanX[sIdx];
          const kTrue = kSorted[t];
          const den = r * x + s;
          if (!isFinite(den) || Math.abs(den) < 1e-12) continue;
          const khat = (p * x + q) / den;
          kErrs.push(khat - kTrue);
          const predX = xFromK(mobRefined, kTrue);
          if (isFinite(predX)) xErrs.push(predX - x);
        }
        if (kErrs.length === 0) continue;
        const kRMSE = Math.sqrt(
          kErrs.reduce((a, b) => a + b * b, 0) / kErrs.length
        );
        const xRMSE = xErrs.length
          ? Math.sqrt(xErrs.reduce((a, b) => a + b * b, 0) / xErrs.length)
          : Infinity;
        out.push({
          startIndex: cand.startIndex,
          endIndex: cand.endIndex,
          pairs4: cand.pairs4,
          mobiusInitial: cand.mobiusInitial,
          mobiusRefined: mobRefined,
          kRMSE_full: kRMSE,
          xRMSE_full: xRMSE,
          pairsUsed: matchedPairs.length
        });
      }
      out.sort(
        (a, b) => a.kRMSE_full - b.kRMSE_full || a.xRMSE_full - b.xRMSE_full
      );
      return out.slice(0, topK);
    }
  </script>
  <script id="612" type="application/vnd.observable.javascript">
    autoFit = refineAnchorCandidates(
      anchorCandidatesFast,
      template_edges,
      scanEdges,
      {
        topK: 1
      }
    )[0]
  </script>
  <script id="620" type="application/vnd.observable.javascript">
    autoFitProjectedTemplate = {
      const mob =
        autoFit &&
        (autoFit.mobiusRefined ?? autoFit.mobiusInitial ?? autoFit.mobius);
      if (!mob) return [];
      return template_edges.map((k) => ({ k, x: xFromK(mob, k) }));
    }
  </script>
  <script id="622" type="application/vnd.observable.javascript">
    autoFitResiduals = {
      const projectedTemplate = autoFitProjectedTemplate;
      if (!projectedTemplate || projectedTemplate.length === 0) return [];
      const tplX = projectedTemplate.map((t) => t.x);
      const scanX = scanEdges.map((e) => (typeof e === "number" ? e : e.x));
      const alignment = dpAlign(tplX, scanX);
      const map = alignment.templateToScan || [];
      const out = new Array(projectedTemplate.length);
      for (let i = 0; i < projectedTemplate.length; i++) {
        const pred = projectedTemplate[i].x;
        const sj = map[i];
        if (sj != null) {
          const actual = scanX[sj];
          out[i] = {
            k: projectedTemplate[i].k,
            predictedX: pred,
            actualX: actual,
            cost: Math.abs(pred - actual),
            matched: true,
            sj
          };
        } else {
          out[i] = {
            k: projectedTemplate[i].k,
            predictedX: pred,
            actualX: null,
            cost: 20,
            matched: false,
            sj: null
          };
        }
      }
      return out;
    }
  </script>
  <script id="678" type="text/markdown">
    ## End to end function
  </script>
  <script id="683" type="application/vnd.observable.javascript" pinned="">
    autoFitScanline = function autoFitScanline(scanLine, template, opts = {}) {
      if (!scanLine.length) throw new Error("scanLine must be an array");
      if (!Array.isArray(template))
        throw new Error(
          "template must be an array (either binary mask or template k-values)"
        );
      const edgeThr = opts.edgeThreshold ?? 6;
      const topK = opts.topK ?? 10;
      const topKRefine = opts.topKRefine ?? 5;
      const minBetween = opts.minBetween;
      const maxBetween = opts.maxBetween;
      const gapPenalty = opts.gapPenalty;
      const polarityPenalty = opts.polarityPenalty;
      let template_edges;
      if (opts.templateIsBinary === true) {
        template_edges = binaryToEdges(template);
      } else {
        const allZerosOnes = template.every((v) => v === 0 || v === 1);
        if (allZerosOnes) template_edges = binaryToEdges(template);
        else template_edges = template.slice();
      }
      const scanEdges = edges1D(scanLine, edgeThr);
      if (!scanEdges || scanEdges.length < 3)
        return {
          success: false,
          reason: "not_enough_scan_edges",
          scanEdges,
          template_edges
        };
      const candidates = computeAnchorCandidatesFast(template_edges, scanEdges, {
        topK,
        minBetween,
        maxBetween
      });
      const refined = refineAnchorCandidates(
        candidates,
        template_edges,
        scanEdges,
        {
          topK: topKRefine,
          gapPenalty,
          polarityPenalty
        }
      );
      const chosen =
        refined && refined.length
          ? refined[0]
          : candidates && candidates.length
          ? candidates[0]
          : null;
      const mob = chosen
        ? chosen.mobiusRefined ?? chosen.mobiusInitial ?? chosen.mobius
        : null;
      const projectedTemplate = mob
        ? template_edges.map((k) => ({ k, x: xFromK(mob, k) }))
        : [];
      const tplX = projectedTemplate.map((t) => t.x);
      const scanX = scanEdges.map((e) => (typeof e === "number" ? e : e.x));
      const alignment = dpAlign(tplX, scanX);
      const map = alignment.templateToScan || [];
      const residuals = projectedTemplate.map((t, i) => {
        const sj = map[i];
        if (sj != null) {
          const actual = scanX[sj];
          return {
            k: t.k,
            predictedX: t.x,
            actualX: actual,
            cost: Math.abs(t.x - actual),
            matched: true,
            sj
          };
        } else {
          return {
            k: t.k,
            predictedX: t.x,
            actualX: null,
            cost: 20,
            matched: false,
            sj: null
          };
        }
      });
      return {
        success: true,
        template_edges,
        scanEdges,
        candidates,
        refined,
        chosen,
        mobius: mob,
        projectedTemplate,
        alignment,
        residuals
      };
    }
  </script>
  <script id="685" type="application/vnd.observable.javascript" pinned="">
    autoFitScanline(scanLineBuffer, template)
  </script>
  <script id="561" type="text/markdown">
    ---
  </script>
  <script id="335" type="application/vnd.observable.javascript">
    function binaryToEdges(arr) {
      const edges = [];
      const n = arr.length;

      // transitions
      for (let i = 1; i < n; i++) {
        if (arr[i] !== arr[i - 1]) edges.push(i);
      }

      return edges.map((i) => i - arr.length / 2);
    }
  </script>
  <script id="71" type="application/vnd.observable.javascript">
    grey = {
      renders;
      return rgbaToGray(pixelBuffer);
    }
  </script>
  <script id="41" type="application/vnd.observable.javascript">
    edges = {
      renders;
      return canny(grey, width);
    }
  </script>
  <script id="133" type="application/vnd.observable.javascript">
    test_fitMobius = {
      // Ground truth params
      const p = 0.5,
        q = 2,
        r = 0.05,
        s = 1;

      // Make 4 points from the model
      const pts = [0, 10, 20, 30].map((x) => ({ x, k: (p * x + q) / (r * x + s) }));

      return fitMobius(pts);
    }
  </script>
  <script id="127" type="application/vnd.observable.javascript">
    function solve3(A, b) {
      const [a, b1, c, d, e, f, g, h, i] = [
        A[0][0],
        A[0][1],
        A[0][2],
        A[1][0],
        A[1][1],
        A[1][2],
        A[2][0],
        A[2][1],
        A[2][2]
      ];
      const D = a * (e * i - f * h) - b1 * (d * i - f * g) + c * (d * h - e * g);
      if (Math.abs(D) < 1e-8) return [0, 0, 0];
      const dx =
        (b[0] * (e * i - f * h) -
          b1 * (b[1] * i - f * b[2]) +
          c * (b[1] * h - e * b[2])) /
        D;
      const dy =
        (a * (b[1] * i - f * b[2]) -
          b[0] * (d * i - f * g) +
          c * (d * b[2] - b[1] * g)) /
        D;
      const dz =
        (a * (e * b[2] - b[1] * h) -
          b1 * (d * b[2] - b[1] * g) +
          b[0] * (d * h - e * g)) /
        D;
      return [dx, dy, dz];
    }
  </script>
  <script id="78" type="application/vnd.observable.javascript">
    function sampleLine(gray, w, cx, cy, theta, len) {
      const h = (gray.length / w) | 0;
      const dx = Math.cos(theta),
        dy = Math.sin(theta);
      const half = (len / 2) | 0;
      const out = new Float32Array(len);
      for (let t = -half, j = 0; j < len; t++, j++) {
        const xf = cx + t * dx,
          yf = cy + t * dy;
        const x0 = Math.floor(xf),
          y0 = Math.floor(yf);
        if (x0 < 0 || x0 >= w - 1 || y0 < 0 || y0 >= h - 1) {
          out[j] = 0;
          continue;
        }
        const a = xf - x0,
          b = yf - y0;
        const i = y0 * w + x0;
        const p00 = gray[i],
          p10 = gray[i + 1],
          p01 = gray[i + w],
          p11 = gray[i + w + 1];
        out[j] =
          (1 - a) * (1 - b) * p00 +
          a * (1 - b) * p10 +
          (1 - a) * b * p01 +
          a * b * p11;
      }
      return out;
    }
  </script>
  <script id="53" type="application/vnd.observable.javascript">
    function rgbaToGray(rgba) {
      if (rgba.length % 4 !== 0) throw new Error("RGBA length not multiple of 4");
      const gray = new Uint8Array(rgba.length / 4);
      for (let i = 0, j = 0; i < rgba.length; i += 4, j++) {
        const r = rgba[i],
          g = rgba[i + 1],
          b = rgba[i + 2];
        gray[j] = (0.299 * r + 0.587 * g + 0.114 * b) | 0;
      }
      return gray;
    }
  </script>
  <script id="39" type="application/vnd.observable.javascript">
    function canny(src, w, opts = {}) {
      const { sigma = 1.0, low = 20, high = 60 } = opts;
      if (!Number.isInteger(w) || w <= 0)
        throw new Error("w must be positive integer");
      const h = (src.length / w) | 0;
      if (w * h !== src.length) throw new Error("buffer length not divisible by w");

      // 1) Gaussian blur, separable
      const k = gaussianKernel1D(sigma);
      const tmp = new Float32Array(w * h);
      const blur = new Float32Array(w * h);

      // horizontal
      for (let y = 0; y < h; y++) {
        const base = y * w;
        for (let x = 0; x < w; x++) {
          let acc = 0;
          for (let i = -k.half; i <= k.half; i++) {
            const xx = clamp(x + i, 0, w - 1);
            acc += k.data[i + k.half] * src[base + xx];
          }
          tmp[base + x] = acc;
        }
      }
      // vertical
      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          let acc = 0;
          for (let i = -k.half; i <= k.half; i++) {
            const yy = clamp(y + i, 0, h - 1);
            acc += k.data[i + k.half] * tmp[yy * w + x];
          }
          blur[y * w + x] = acc;
        }
      }

      // 2) Sobel gradients
      const gx = new Float32Array(w * h);
      const gy = new Float32Array(w * h);
      for (let y = 0; y < h; y++) {
        const ym1 = Math.max(0, y - 1),
          yp1 = Math.min(h - 1, y + 1);
        for (let x = 0; x < w; x++) {
          const xm1 = Math.max(0, x - 1),
            xp1 = Math.min(w - 1, x + 1);
          const a = blur[ym1 * w + xm1],
            b = blur[ym1 * w + x],
            c = blur[ym1 * w + xp1];
          const d = blur[y * w + xm1],
            /* e = blur[y*w + x] */ f = blur[y * w + xp1];
          const g = blur[yp1 * w + xm1],
            hh = blur[yp1 * w + x],
            i = blur[yp1 * w + xp1];
          gx[y * w + x] = c + 2 * f + i - (a + 2 * d + g);
          gy[y * w + x] = g + 2 * hh + i - (a + 2 * b + c);
        }
      }

      // gradient magnitude (L2), scaled to 0..255 for thresholding
      const mag = new Float32Array(w * h);
      let maxMag = 0;
      for (let idx = 0; idx < mag.length; idx++) {
        const m = Math.hypot(gx[idx], gy[idx]);
        mag[idx] = m;
        if (m > maxMag) maxMag = m;
      }
      const scale = maxMag > 0 ? 255 / maxMag : 0;

      // 3) Non-maximum suppression along quantized directions (0,45,90,135)
      const thin = new Uint8Array(w * h); // holds scaled magnitude at local maxima
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = y * w + x;
          const gxx = gx[idx],
            gyy = gy[idx];
          const m = mag[idx] * scale;

          // direction sector
          const angle = Math.atan2(gyy, gxx) * (180 / Math.PI);
          const a = angle < 0 ? angle + 180 : angle;
          let n1 = 0,
            n2 = 0;
          if ((a >= 0 && a < 22.5) || (a >= 157.5 && a < 180)) {
            n1 = mag[idx - 1] * scale;
            n2 = mag[idx + 1] * scale; // horizontal
          } else if (a >= 22.5 && a < 67.5) {
            n1 = mag[idx - w - 1] * scale;
            n2 = mag[idx + w + 1] * scale; // 45°
          } else if (a >= 67.5 && a < 112.5) {
            n1 = mag[idx - w] * scale;
            n2 = mag[idx + w] * scale; // vertical
          } else {
            // 112.5..157.5
            n1 = mag[idx - w + 1] * scale;
            n2 = mag[idx + w - 1] * scale; // 135°
          }
          thin[idx] = m >= n1 && m >= n2 ? m | 0 : 0;
        }
      }

      // 4) Hysteresis thresholding via stack flood fill
      const STRONG = 255;
      const WEAK = 128;
      const out = new Uint8Array(w * h);
      const stack = new Int32Array(w * h);
      let sp = 0;

      for (let i = 0; i < thin.length; i++) {
        const v = thin[i];
        if (v >= high) {
          out[i] = STRONG;
          stack[sp++] = i;
        } else if (v >= low) {
          out[i] = WEAK;
        }
      }

      // promote weak connected to strong (8-connectivity)
      while (sp > 0) {
        const idx = stack[--sp];
        const y = (idx / w) | 0,
          x = idx % w;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const xx = x + dx,
              yy = y + dy;
            if (xx < 0 || xx >= w || yy < 0 || yy >= h) continue;
            const j = yy * w + xx;
            if (out[j] === WEAK) {
              out[j] = STRONG;
              stack[sp++] = j;
            }
          }
        }
      }

      // suppress remaining weak
      for (let i = 0; i < out.length; i++) out[i] = out[i] === STRONG ? 255 : 0;
      return out;
    }
  </script>
  <script id="111" type="application/vnd.observable.javascript">
    function edges1D(sig, thr = 6) {
      const n = sig.length;
      const d = new Float32Array(n);
      for (let i = 1; i < n; i++) d[i] = sig[i] - sig[i - 1];
      const idx = [];
      for (let i = 2; i < n - 2; i++) {
        const v = d[i];
        if (Math.abs(v) < thr) continue;
        if (
          (v > 0 && d[i] >= d[i - 1] && d[i] >= d[i + 1]) ||
          (v < 0 && d[i] <= d[i - 1] && d[i] <= d[i + 1])
        ) {
          idx.push({ x: i, s: Math.sign(v) });
        }
      }
      return idx;
    }
  </script>
  <script id="45" type="application/vnd.observable.javascript">
    function canvasFromGrayU8(gray, w) {
      if (!Number.isInteger(w) || w <= 0) throw new Error("w invalid");
      const h = (gray.length / w) | 0;
      if (w * h !== gray.length) throw new Error("buffer size mismatch");

      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext("2d");
      const img = ctx.createImageData(w, h);
      const dst = img.data; // RGBA

      for (let i = 0, j = 0; i < gray.length; i++, j += 4) {
        const v = gray[i];
        dst[j] = v;
        dst[j + 1] = v;
        dst[j + 2] = v;
        dst[j + 3] = 255;
      }
      ctx.putImageData(img, 0, 0);
      return canvas;
    }
  </script>
  <script id="36" type="application/vnd.observable.javascript">
    function gaussianKernel1D(sigma) {
      const s = Math.max(0.3, sigma);
      const half = Math.max(1, Math.round(s * 3));
      const size = 2 * half + 1;
      const data = new Float32Array(size);
      const a = 1 / (Math.sqrt(2 * Math.PI) * s);
      const twoSigma2 = 2 * s * s;
      let sum = 0;
      for (let i = -half; i <= half; i++) {
        const v = a * Math.exp(-(i * i) / twoSigma2);
        data[i + half] = v;
        sum += v;
      }
      for (let i = 0; i < size; i++) data[i] /= sum;
      return { data, half };
    }
  </script>
  <script id="382" type="application/vnd.observable.javascript">
    md`Here are several algorithms / strategies you can use to assign every template_edge to a subset of scan edges.  Which is best depends on constraints you want to enforce (ordering, polarity, one‑to‑one), the expected amount of outliers/missing edges, and how big the problem is.

    ...

    4) Dynamic programming (sequence alignment) — preserves order, allows gaps
    - If template edges must map in order to scan edges (monotone mapping) and you allow insertions/deletions, use DP (Needleman‑Wunsch style):
      cost(i,j) = min( cost(i-1,j-1) + match_cost(x_ti,x_sj),
                       cost(i-1,j) + gap_penalty,   // skip template
                       cost(i,j-1) + gap_penalty )  // skip scan
    - match_cost could be |x_ti - x_sj| (possibly squared, and include polarity mismatch penalty).
    - Complexity O(N*M) (N = #template edges, M = #scan edges).
    - Pros: optimal under the chosen cost, enforces monotonicity, handles missing edges.
    - Cons: quadratic; choose gap_penalty carefully.

    ...
    `
  </script>
  <script id="34" type="application/vnd.observable.javascript" pinned="">
    function clamp(v, lo, hi) {
      return v < lo ? lo : v > hi ? hi : v;
    }
  </script>
  <script id="91" type="application/vnd.observable.javascript">
    overlay
  </script>
  <script id="356" type="application/vnd.observable.javascript" pinned="">
    SVD = {
      return (await require("svd-js")).SVD;
    }
  </script>
  <script id="378" type="application/vnd.observable.javascript" pinned="">
    import { robocoop } from "@tomlarkworthy/robocoop-2"
  </script>
  <script id="380" type="application/vnd.observable.javascript" pinned="">
    robocoop
  </script>
</notebook>
