<!doctype html>
<notebook theme="air">
  <title>Reactive State Machine Development with XState, Stately.ai on Observablehq.com</title>
  <script id="483" type="text/markdown">
    # Reactive State Machine Development with [XState](https://xstate.js.org/docs/), [Stately.ai](https://stately.ai) on [Observablehq.com](https://observablehq.com)
  </script>
  <script id="0" type="text/markdown">
    State machines are a great computational formalism. They discretize state into verteces, and state transitions to edges on a graph. This is very minimal, which means state machines can often be exhaustively checked. State machines' restrained expressivity is exactly why they open the door to **formal methods** [[1](https://www.researchgate.net/publication/4353087_Symbolic_model_checking_of_hierarchical_UML_state_machines)] and are loved in the embedded/realtime/safety-critical system communities.

    From another direction, state machines are easy to understand. A running system is a vertex within a graph, and you can see where the system can go by looking at the outbound edges. Some developers advocate for their use in **low level UI handling**, translating low-level events, like key _mousedown_ events, into high-level concepts like selection dragging (e.g. in [TLDraw](https://github.com/tldraw/tldraw/blob/2567cedcd268c8e71045d45fb76388f96e7251f4/examples/core-example-advanced/src/state/machine.ts#L8)). In this context, the state machines vertices hold the gesture context, like whether they are currently in a drag-or-not.

    However, in practice, state machines are not very readable. A state machine's program is a list of translations that often have no natural linear ordering so they do not map particularly well to code. The intuitive representation of state machines is a state machine diagram *i.e.* a programmer's DataViz. 

    <figure>
        <img src="${await FileAttachment("image.png").url()}"
             alt="State machine diagram example">
        <figcaption>Diagram from [www.state-machine.com](https://www.state-machine.com) a company specializing in realtime embedded controllers programmed via the state machine paradigm</figcaption>
    </figure>

    There are many tools for drawing state machines. [Stately.ai](https://stately.ai) stands out because it can draw both the machine definition *and* a running machine. It is compatible with [xstate](https://xstate.js.org/docs/), the leading state machine implementation for JavaScript. Yet despite its power, I have always had problems because my program was *here*, my code was *there* and the visualizer was somewhere else entirely! Thus the context switching between code, program output, and visualization tool was too high to get make state machine development effective.

    <figure>
        <img src="${await FileAttachment("image@1.png").url()}"
             alt="State machine diagram example">
        <figcaption>An [xstate](xstate.js.org) machine visualization</figcaption>
    </figure>

    This changes now! [Stately.ai](https://stately.ai) can be embedded in an *iframe*. We can leverage Observable's reactive execution model to reattach a visual debugger on machine definition changes, giving us a reactive development workflow where the code, the program output, and the visual debugging tools are next to each other and they all auto-update on changes properly! Finally! a nice workflow for state machine development!

  </script>
  <script id="550" type="text/markdown">
    ### Import the dependancies
  </script>
  <script id="190" type="application/vnd.observable.javascript">
    import {
      createMachine,
      interpret,
      inspect,
      assign
    } from "@tomlarkworthy/xstate"
  </script>
  <script id="365" type="text/markdown">
    TODO
    - Better explanation for calculator input
    - Calculator machine is unreadable (trim machine, or fiddle with zoom levels)
    - Explain steps of bringing up a state machine

  </script>
  <script id="197" type="text/markdown">
    ### Realtime inspection

    See https://xstate.js.org/docs/packages/xstate-inspect/
  </script>
  <script id="203" type="application/vnd.observable.javascript" pinned="">
    setupInspect = {
      calculatorMachineDefinition;

      return inspect({
        iframe: () => stately,
        url: "https://stately.ai/viz/embed?mode=viz&inspect"
      });
    }
  </script>
  <script id="206" type="text/html">
    <iframe style="width: ${width}px; height: ${width * 0.7}px;"></iframe>
  </script>
  <script id="356" type="text/markdown">
    This is the calculator input, all keyboard events are consumed, and the calculator display is output.
  </script>
  <script id="278" type="application/vnd.observable.javascript">
    viewof dispay = {
      const ui = htl.html`<input>`;
      function onKey(evt) {
        mutable keydown = evt.key;
        evt.preventDefault();
      }
      ui.addEventListener("keydown", onKey);
      invalidation.then(() => ui.removeEventListener("keydown", onKey));
      return ui;
    }
  </script>
  <script id="338" type="application/vnd.observable.javascript" pinned="">
    state.value
  </script>
  <script id="295" type="application/vnd.observable.javascript">
    mutable keydown = undefined
  </script>
  <script id="305" type="application/vnd.observable.javascript" pinned="">
    sendToMachine = {
      const num = parseInt(keydown);
      if (Number.isInteger(num)) {
        calculatorMachine.send({
          type: "NUMBER",
          key: num
        });
      } else if (["/", "*", "+", "-", "x"].includes(keydown)) {
        calculatorMachine.send({
          type: "OPERATOR",
          operator: keydown === "*" ? "x" : keydown
        });
      } else if (keydown === ".") {
        calculatorMachine.send({
          type: "DECIMAL_POINT"
        });
      } else if (keydown === "Enter" || keydown === "=") {
        calculatorMachine.send({
          type: "EQUALS"
        });
      } else if (keydown === "Backspace") {
        calculatorMachine.send({
          type: "CLEAR_ENTRY"
        });
      }
    }
  </script>
  <script id="343" type="application/vnd.observable.javascript" pinned="">
    readFromMachine = {
      viewof dispay.value = state.context.display;
    }
  </script>
  <script id="310" type="application/vnd.observable.javascript" pinned="">
    state = Generators.observe((notify) => {
      calculatorMachine.onTransition((state) => notify(state));
    })
  </script>
  <script id="376" type="text/markdown">
    ---
  </script>
  <script id="384" type="application/vnd.observable.javascript" pinned="">
    logic = {
      const not = (fn) => (...args) => !fn(...args);
      const isZero = (context, event) => event?.key === 0;
      const isNotZero = not(isZero);
      const isMinus = (context, event) => event?.operator === "-";
      const isNotMinus = not(isMinus);
      const divideByZero = (context, event) => {
        debugger;
        return;
        (!context?.operand2 || context?.operand2 === "0.") &&
          context?.operator === "/";
      };

      const notDivideByZero = not(divideByZero);
      function doMath(operand1, operand2, operator) {
        switch (operator) {
          case "+":
            return +operand1 + +operand2;
          case "-":
            return +operand1 - +operand2;
          case "/":
            return +operand1 / +operand2;
          case "x":
            return +operand1 * +operand2;
          default:
            return Infinity;
        }
      }

      return {
        not,
        isZero,
        isNotZero,
        isMinus,
        isNotMinus,
        divideByZero,
        notDivideByZero,
        doMath
      };
    }
  </script>
  <script id="133" type="application/vnd.observable.javascript" pinned="">
    calculatorMachineDefinition = createMachine(
      {
        id: "calcMachine",
        context: {
          display: "0.",
          operand1: undefined,
          operand2: undefined,
          operator: undefined
        },
        strict: true,
        initial: "start",
        on: {
          CLEAR_EVERYTHING: {
            target: ".start",
            actions: ["reset"]
          }
        },
        states: {
          start: {
            on: {
              NUMBER: [
                {
                  cond: "isZero",
                  target: "operand1.zero",
                  actions: ["defaultReadout"]
                },
                {
                  cond: "isNotZero",
                  target: "operand1.before_decimal_point",
                  actions: ["setReadoutNum"]
                }
              ],
              OPERATOR: {
                cond: "isMinus",
                target: "negative_number",
                actions: ["startNegativeNumber"]
              },
              DECIMAL_POINT: {
                target: "operand1.after_decimal_point",
                actions: ["defaultReadout"]
              }
            }
          },
          operand1: {
            on: {
              OPERATOR: {
                target: "operator_entered",
                actions: ["recordOperator"]
              },
              PERCENTAGE: {
                target: "result",
                actions: ["storeResultAsOperand2", "computePercentage"]
              },
              CLEAR_ENTRY: {
                target: "operand1",
                actions: ["defaultReadout"]
              }
            },
            initial: "zero",
            states: {
              zero: {
                on: {
                  NUMBER: {
                    target: "before_decimal_point",
                    actions: "setReadoutNum"
                  },
                  DECIMAL_POINT: "after_decimal_point"
                }
              },
              before_decimal_point: {
                on: {
                  NUMBER: {
                    target: "before_decimal_point",
                    actions: ["appendNumBeforeDecimal"]
                  },
                  DECIMAL_POINT: "after_decimal_point"
                }
              },
              after_decimal_point: {
                on: {
                  NUMBER: {
                    target: "after_decimal_point",
                    actions: ["appendNumAfterDecimal"]
                  }
                }
              }
            }
          },
          negative_number: {
            on: {
              NUMBER: [
                {
                  cond: "isZero",
                  target: "operand1.zero",
                  actions: ["defaultNegativeReadout"]
                },
                {
                  cond: "isNotZero",
                  target: "operand1.before_decimal_point",
                  actions: ["setNegativeReadoutNum"]
                }
              ],
              DECIMAL_POINT: {
                target: "operand1.after_decimal_point",
                actions: ["defaultNegativeReadout"]
              },
              CLEAR_ENTRY: {
                target: "start",
                actions: ["defaultReadout"]
              }
            }
          },
          operator_entered: {
            on: {
              OPERATOR: [
                {
                  cond: "isNotMinus",
                  target: "operator_entered",
                  actions: "setOperator"
                },
                {
                  cond: "isMinus",
                  target: "negative_number_2",
                  actions: ["startNegativeNumber"]
                }
              ],
              NUMBER: [
                {
                  cond: "isZero",
                  target: "operand2.zero",
                  actions: ["defaultReadout", "saveOperand2"]
                },
                {
                  cond: "isNotZero",
                  target: "operand2.before_decimal_point",
                  actions: ["setReadoutNum", "saveOperand2"]
                }
              ],
              DECIMAL_POINT: {
                target: "operand2.after_decimal_point",
                actions: ["defaultReadout"]
              }
            }
          },
          operand2: {
            on: {
              OPERATOR: [
                {
                  cond: "notDivideByZero",
                  target: "operator_entered",
                  actions: [
                    "storeResultAsOperand2",
                    "compute",
                    "storeResultAsOperand1",
                    "setOperator"
                  ]
                },
                {
                  target: "alert"
                }
              ],
              EQUALS: [
                {
                  cond: "notDivideByZero",
                  target: "result",
                  actions: ["storeResultAsOperand2", "compute"]
                },
                {
                  target: "alert"
                }
              ],
              CLEAR_ENTRY: {
                target: "operand2.zero",
                actions: ["defaultReadout"]
              }
            },
            initial: "zero",
            states: {
              zero: {
                on: {
                  NUMBER: {
                    target: "before_decimal_point",
                    actions: ["setReadoutNum"]
                  },
                  DECIMAL_POINT: "after_decimal_point"
                }
              },
              before_decimal_point: {
                on: {
                  NUMBER: {
                    target: "before_decimal_point",
                    actions: ["appendNumBeforeDecimal"]
                  },
                  DECIMAL_POINT: "after_decimal_point"
                }
              },
              after_decimal_point: {
                on: {
                  NUMBER: {
                    target: "after_decimal_point",
                    actions: "appendNumAfterDecimal"
                  }
                }
              }
            }
          },
          negative_number_2: {
            on: {
              NUMBER: [
                {
                  cond: "isZero",
                  target: "operand2.zero",
                  actions: ["defaultNegativeReadout"]
                },
                {
                  cond: "isNotZero",
                  target: "operand2.before_decimal_point",
                  actions: ["setNegativeReadoutNum"]
                }
              ],
              DECIMAL_POINT: {
                target: "operand2.after_decimal_point",
                actions: ["defaultNegativeReadout"]
              },
              CLEAR_ENTRY: {
                target: "operator_entered",
                actions: ["defaultReadout"]
              }
            }
          },
          result: {
            on: {
              NUMBER: [
                {
                  cond: "isZero",
                  target: "operand1",
                  actions: ["defaultReadout"]
                },
                {
                  cond: "isNotZero",
                  target: "operand1.before_decimal_point",
                  actions: ["setReadoutNum"]
                }
              ],
              PERCENTAGE: {
                target: "result",
                actions: ["storeResultAsOperand2", "computePercentage"]
              },
              OPERATOR: {
                target: "operator_entered",
                actions: ["storeResultAsOperand1", "recordOperator"]
              },
              CLEAR_ENTRY: {
                target: "start",
                actions: ["defaultReadout"]
              }
            }
          },
          alert: {
            invoke: {
              src: (context, event) => () => {
                // eslint-disable-next-line no-alert
                alert("Cannot divide by zero!");
                return Promise.resolve();
              },
              onDone: {
                target: "start",
                actions: ["reset"]
              }
            }
          }
        }
      },
      {
        guards: {
          isMinus: logic.isMinus,
          isNotMinus: logic.isNotMinus,
          isZero: logic.isZero,
          isNotZero: logic.isNotZero,
          notDivideByZero: logic.notDivideByZero
        },
        actions: {
          defaultReadout: assign({
            display: () => {
              console.log("defaultReadout");

              return "0.";
            }
          }),

          defaultNegativeReadout: assign({
            display: () => "-0."
          }),

          appendNumBeforeDecimal: assign({
            display: (context, event) => {
              // from '123.' => '1234.'
              return `${context.display.slice(0, -1)}${event.key}.`;
            }
          }),

          appendNumAfterDecimal: assign({
            display: (context, event) => {
              return `${context.display}${event.key}`;
            }
          }),

          setReadoutNum: assign({
            display: (context, event) => {
              return `${event.key}.`;
            }
          }),

          setNegativeReadoutNum: assign({
            display: (context, event) => `-${event.key}.`
          }),

          startNegativeNumber: assign({
            display: () => "-"
          }),

          recordOperator: assign({
            operand1: (context) => context.display,
            operator: (context, event) => event.operator
          }),

          setOperator: assign({
            operator: (context, event) => context.operator
          }),

          computePercentage: assign({
            display: (context, event) => (+context.display / 100).toString()
          }),

          compute: assign({
            display: (context, event) => {
              const result = logic.doMath(
                context.operand1,
                context.operand2,
                context.operator
              );

              console.log(
                `doing calculation ${context.operand1} ${context.operator} ${context.operand2} = ${result}`
              );

              return result.toString();
            }
          }),

          storeResultAsOperand1: assign({
            operand1: (context) => context.display
          }),

          storeResultAsOperand2: assign({
            operand2: (context) => context.display
          }),

          saveOperand2: assign({
            operand2: (context, event) => context.display
          }),

          reset: assign({
            display: () => "0.",
            operand1: (context, event) => undefined,
            operand2: () => undefined,
            operator: () => undefined
          })
        }
      }
    )
  </script>
  <script id="532" type="application/vnd.observable.javascript" pinned="">
    viewof rememberState = Inputs.toggle({
      label: "Remember state and context?",
      value: true
    })
  </script>
  <script id="140" type="application/vnd.observable.javascript" pinned="">
    calculatorMachine = {
      setupInspect;

      const machine = interpret(calculatorMachineDefinition, { devTools: true });
      invalidation.then(() => machine.stop());
      if (this && viewof rememberState.value) {
        machine.start(this.state.value);
        machine.withContext(this.machine.context);
      } else {
        machine.start();
      }

      return machine;
    }
  </script>
</notebook>
