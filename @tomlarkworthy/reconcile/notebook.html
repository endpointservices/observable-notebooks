<!doctype html>
<notebook theme="air">
  <title>Hypertext literal reconciliation (Native DOM Diffing)</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`
    # Hypertext literal reconciliation (Native DOM Diffing)

    I love the [hypertext literal](https://observablehq.com/@observablehq/htl). It is intuitive. However, naive application of it tends to invalidate state between renders leading to poor UX.

    React solved this problem with a [reconciliation](https://reactjs.org/docs/reconciliation.html) algorithm. However, React is very complicated and does not gel with Observable.

    This notebook is an idea to try and get a React-like reconciliation algorithm applied to the hypertext literal in an Observable native way. We exploit the \`this\` variable to retrevie the previous DOM state allowing us to diff from the previous cell UI state. 

    It in the experimental state so leave comments if on areas where it does not work and we can try to fix it.

    ~~~js
    import {reconcile, html} from '@tomlarkworthy/reconcile'
    ~~~
    `
  </script>
  <script id="105" type="application/vnd.observable.javascript">
    md`
    ## Demo of problem

    If we have some state defined elsehwere, say a list of messages:-

    `
  </script>
  <script id="41" type="application/vnd.observable.javascript">
    mutable msgs = ["How are you?", "I am great!, loving Observable"]
  </script>
  <script id="112" type="application/vnd.observable.javascript">
    md`
    We can create a very simple chat UI using the hypertext literal to change this external state. I love this construction as it can hold its own state and helper functions. 
    `
  </script>
  <script id="40" type="application/vnd.observable.javascript" pinned="">
    {
      async function sendMsg(evt) {
        if (evt.keyCode === 13) {
          console.log(msgs)
          mutable msgs = msgs.concat([evt.target.value]);
        }
      }
      return html`
        ${msgs.map(msg => html`<p>${msg}</p>`)}
        <input class="text" onkeydown=${sendMsg}></input>
        <button onclick=${() => mutable msgs = []}>clear</button>
      `;
    }
  </script>
  <script id="128" type="application/vnd.observable.javascript">
    md`
    This is very simple to understand, but there are some problems with the UX. After sending a message, the focus of the cursor is lost. This is because when the list changes, the HTML is rebuilt from scratch, and all DOM state is lost, including the focus. So its impossible to send lots of messages in a row, you keep having to click back into the text area!
    `
  </script>
  <script id="155" type="application/vnd.observable.javascript">
    md`
    ## Solution Attempt

    Create a custom \`reconcile\` function for DOM state diffing. Unlike React and Preact, we do not use a virtual DOM. Instead we compare the previous DOM state to the new hypertext literal HTML fragment. You can get the previous state of a cell with the keyword [\`this\`](https://talk.observablehq.com/t/get-the-previous-value-of-a-cell-when-its-edited-and-saved/792).

    To reuse the previous state and apply a diff we add 

             reconcile(this, <HTMLFragment>)

    where we previously jsut did

             <HTMLFragment>

    to the implementation. Reconcile changes DOM node at 'this' to look like <HTMLFragment> and returns it, if possible, otherwise it just returns the HTML target fragment. 

    Like (P)React reconciliation algorithm will look for the "key" attribute to guide matching.
    `
  </script>
  <script id="73" type="application/vnd.observable.javascript" pinned="">
    {
      function sendMsg(evt) {
        if (evt.keyCode === 13) {
          console.log(msgs)
          mutable msgs = msgs.concat([evt.target.value]);
        }
      }
      return reconcile(this, html`
        ${msgs.map(msg => html`<p>${msg}</p>`)}
        <input key="chat" class="text" onkeydown=${sendMsg}></input> <!-- Note key attribute added as well-->
        <button onclick=${() => mutable msgs = []}>clear</button> 
      `);
    }
  </script>
  <script id="443" type="application/vnd.observable.javascript">
    md`
    ## It works!
    Now state is not lost, the focus remains on the text component and the text feild is not cleared!
    `
  </script>
  <script id="474" type="application/vnd.observable.javascript">
    md`
    ### Implementation Notes

    - Like React we use an attribute "key" to guide element matching.

    - event handlers like onclick are implemented by hypertext literal as assignment to node properties (not HTML attributes), which is why existing DOM diffs won't work (they work at HTMLElement level).

    - If you move a child using insertBefore, focus is lost. For this implementation I try to avoid making these changes, but it means if the sort order changes you cannot avoid dettaching some children and they will lose focus.

    - If you try to reconcile with a live DOM element, you have to make sure the types match (e.g. DIV to DIV).
    `
  </script>
  <script id="221" type="application/vnd.observable.javascript" pinned="">
    function reconcile(current, target) {
      // Some differences cannot be reconciled in place, return the target
      if (!current || 
          !target || 
          current.nodeType != target.nodeType || 
          current.nodeName != target.nodeName ||
          current.namespaceURI != target.namespaceURI
         ) {
        if (current && target && current.nodeName != target.nodeName) {
          console.log("Cannot reconcile", current.nodeName, target.nodeName)
        }
        return target;
      }

      const hasChildren = current.firstChild || target.firstChild;
      const hasAttibutes = current.hasAttributes || target.hasAttributes

      if (current.nodeType === Node.TEXT_NODE) {
        current.nodeValue = target.nodeValue
      }
      if (hasAttibutes) {
        function indexAttributes(attributes) {
          const index = {}
          for(let i = attributes.length - 1; i >= 0; i--) {
            index[attributes[i].name] = attributes[i].value;
          }
          return index;
        }
        const currentAttributes = indexAttributes(current.attributes)
        const targetAttributes = indexAttributes(target.attributes)
        const unionAttributeNames = new Set([...Object.keys(currentAttributes),
                                             ...Object.keys(targetAttributes)]);

        for (let attributeName of unionAttributeNames) {
          if (targetAttributes[attributeName]) {
            if (targetAttributes[attributeName] !== currentAttributes[attributeName]) {
              current.setAttribute(attributeName, targetAttributes[attributeName])
            }
          } else {
            current.removeAttribute(attributeName);
          }
        }
      }

      for (let prop in target) {
        // Events like onkeydown need to be copied over
        if (prop.startsWith("on")) { 
          if (current[prop] !== target[prop]) {
            current[prop] = target[prop];
          } 
        }
      }

      // Index the children for reconciliation (if we have children)
      if (hasChildren) {
        function indexChildren(parent) {
          const indexChildren = {}
          // Collect children looking for key attribute
          let index = 0;
          for (let child = parent.firstChild; child; child = child.nextSibling) {
            const key = child.hasAttributes && child.getAttribute("key") ? 
                  child.getAttribute("key") : "$" + index;
            indexChildren[key] = {
              node: child,
              index
            };
            index++;
          }
          return indexChildren;
        }

        const currentChildren = indexChildren(current);
        const targetChildren = indexChildren(target);

        // Create a new set of children, indexed by position
        const newChildren = {}

        // Generate reconciliation children and their ordering
        const currentKeys = Object.keys(currentChildren);
        const targetKeys = Object.keys(targetChildren);
        const unionKeys = new Set([...currentKeys, ...targetKeys]);
        for (let key of unionKeys) {
          const currentChild = (currentChildren[key] || {}).node;
          const targetChild = (targetChildren[key] || {}).node;
          const reconciledChild = reconcile(currentChild, targetChild);
          if (currentChild && reconciledChild !== currentChild) {
            current.removeChild(currentChild);
          }
          if (reconciledChild) newChildren[targetChildren[key].index] = reconciledChild;
        }

        // Now we walk through the existing children,
        // trying to avoid moving them if they already in right place
        // This is fairly simple and probably does not scale to complex use cases
        let curser = current.firstChild;
        for (let i = 0; i < targetKeys.length; i++) {
          if (curser === null) {
            current.append(newChildren[i]);
          } else {
            if (curser === newChildren[i]) {
              // Child is already in right place, no structural change in DOM required
              curser = curser.nextSibling
            } else {
              // as we pruned unnecissary children already
              // if there is a mismatch it probably implies the target is bigger
              // If the element was in the current DOM it is moved
              // If the element was in the target DOM it is added
              current.insertBefore(newChildren[i], curser)
            }
          }
        }
      }
      return current
    }
  </script>
  <script id="565" type="application/vnd.observable.javascript">
    md `# Tests`
  </script>
  <script id="259" type="application/vnd.observable.javascript">
    attribteCreate = {
      const current = html.fragment`<div></div>`
      const target = html.fragment`<div foo="1"></div>`
      const reconciled = reconcile(current, target);
      return reconciled.firstElementChild.getAttribute("foo") == "1"
    }
  </script>
  <script id="498" type="application/vnd.observable.javascript">
    attributeRemoved = {
      const current = html.fragment`<div foo="1"></div>`
      const target = html.fragment`<div></div>`
      const reconciled = reconcile(current, target);
      return reconciled.firstElementChild.getAttribute("foo") === null
    }
  </script>
  <script id="508" type="application/vnd.observable.javascript">
    attribteUpdate = {
      const current = html.fragment`<div foo="2"></div>`
      const target = html.fragment`<div foo="1"></div>`
      const reconciled = reconcile(current, target);
      return reconciled.firstElementChild.getAttribute("foo") == "1"
    }
  </script>
  <script id="510" type="application/vnd.observable.javascript">
    attribtesCRUD = {
      const current = html.fragment`<div foo="2" bar="1"></div>`
      const target = html.fragment`<div bar="2" baz="3"></div>`
      const reconciled = reconcile(current, target);
      return reconciled.firstElementChild.getAttribute("foo") == null && 
        reconciled.firstElementChild.getAttribute("bar") == "2"
      reconciled.firstElementChild.getAttribute("baz") == "3"
    }
  </script>
  <script id="515" type="application/vnd.observable.javascript">
    childUpdateInPlace = {
      const current = html.fragment`<ul>
        <li id="t1"></li>
      </ul>`
      const target = html.fragment`<ul>
        <li id="t1">1</li>
      </ul>`
      const reconciled = reconcile(current, target);
      const beforeReconciliation = current.getElementById("t1")
      return reconciled.getElementById("t1") === beforeReconciliation &&
        reconciled.getElementById("t1").firstChild.wholeText === "1"
    }
  </script>
  <script id="529" type="application/vnd.observable.javascript">
    childAdded = {
      const current = html.fragment`<ul>
      </ul>`
      const target = html.fragment`<ul>
        <li id="t1">1</li>
      </ul>`
      const reconciled = reconcile(current, target);
      return reconciled.getElementById("t1").firstChild.wholeText === "1"
    }
  </script>
  <script id="533" type="application/vnd.observable.javascript">
    childRemoved = {
      const current = html.fragment`<ul>
        <li id="t1">1</li>
      </ul>`
      const target = html.fragment`<ul>
      </ul>`
      const reconciled = reconcile(current, target);
      return reconciled.getElementById("t1") == null
    }
  </script>
  <script id="537" type="application/vnd.observable.javascript">
    keyedChildUpdateInPlace = {
      const current = html.fragment`<ul>
        <li key="t1" id="t1"></li>
      </ul>`
      const target = html.fragment`<ul>
        <li id="t2"></li>
        <li key="t1" id="t1"></li>
      </ul>`
      const beforeReconciliation = current.getElementById("t1")
      const reconciled = reconcile(current, target);
      return reconciled.getElementById("t1") === beforeReconciliation
    }
  </script>
  <script id="609" type="application/vnd.observable.javascript">
    DOMUpdateInPlaceDOM = html`
    <div id="DOMUpdateInPlace"> 
    </div>
    `
  </script>
  <script id="583" type="application/vnd.observable.javascript">
    DOMUpdateInPlace = {
      DOMUpdateInPlaceDOM

      const current = document.getElementById("DOMUpdateInPlace")
      const target = html`<div id="DOMUpdateInPlace"><p>1</p></div>`
      const reconciled = reconcile(current, target);
      return current ===  reconciled
    }
  </script>
  <script id="657" type="application/vnd.observable.javascript" pinned="">
    NestedDOMUpdateInPlaceDOM = html`
    <div id="NestedDOMUpdateInPlace"><p>
        <b>raw</b>
    </p></div>`
  </script>
  <script id="662" type="application/vnd.observable.javascript">
    NestedDOMUpdateInPlace = {
      NestedDOMUpdateInPlaceDOM

      const current = document.getElementById("NestedDOMUpdateInPlace")
      const target = html`<div id="NestedDOMUpdateInPlace"><p>
        <b>new</b>
      </p></div>`
      reconcile(current, target);
      return current.textContent.includes("new")
    }
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    import {html} from "@observablehq/htl"
  </script>
</notebook>
