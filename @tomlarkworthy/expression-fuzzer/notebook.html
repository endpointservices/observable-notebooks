<!doctype html>
<notebook theme="air">
  <title>Writing a Simple Expression Fuzzer</title>
  <script id="0" type="text/markdown">
    # Writing a Simple Expression Fuzzer

    Deep in the [Linear Programming solver](https://observablehq.com/@tomlarkworthy/mip) is a symbolic rearranger which is a fairly buggy. It at least throws an exception when it goes wrong, so let's try and use fuzzing to find error cases
  </script>
  <script id="21" type="application/vnd.observable.javascript">
    md`## Seedable RNG

    When fuzzing it's nice to be able to reconstruct the failure case from a seed. So we want a deterministic sampler of an expression given some numeric seed.

    From [stack overflow, seeding RNG](https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript)
    Thanks [bryc](https://stackoverflow.com/users/815680/bryc)!
    `
  </script>
  <script id="24" type="application/vnd.observable.javascript" pinned="">
    function mulberry32(a) {
      return function () {
        var t = (a += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
  </script>
  <script id="42" type="text/markdown">
    ## Production Rules

    I think generating random expressions from production rules is quite intuitive, and some good rules for simple math can be found 
    https://softwareengineering.stackexchange.com/questions/195813/generating-random-math-expression

    It's a good start!
    ~~~
    E -> I
    E -> M '*' M
    E -> E '+' E
    M -> I
    M -> M '*' M
    M -> '(' E '+' E ')'
    ~~~

    Where E is an expression, I is in integer. We might encode this in JSON like:-

  </script>
  <script id="54" type="application/vnd.observable.javascript" pinned="">
    rules = ({
      E: [["I"], ["M", "*", "M"], ["E", "+", "E"]],
      M: [["I"], ["M", "*", "M"], ["(", "E", "+", "E", ")"]],
      I: [["-1"], ["1"], ["0"]]
    })

  </script>
  <script id="74" type="text/markdown">
    ## Deterministic Sampler

    So starting from a symbol (E) we apply the production rules until we terminate. If we go too deep we just quit. One method for control unbounded propagation is to weight the rules, for simplicity we just include redundant extra versions of the terminal rules.
  </script>
  <script id="160" type="application/vnd.observable.javascript" pinned="">
    weightedRules = ({
      E: [/* 2 extra I*/ ["I"], ["I"], ["I"], ["M", "*", "M"], ["E", "+", "E"]],
      M: [
        /* 2 extra I*/ ["I"],
        ["I"],
        ["I"],
        ["M", "*", "M"],
        ["(", "E", "+", "E", ")"]
      ],
      I: [["-2"], ["-1"], ["0"], ["1"], ["2"]]
    })
  </script>
  <script id="85" type="application/vnd.observable.javascript" pinned="">
    function sample(symbol, rules, rng, maxDepth = 20) {
      if (maxDepth == 0) throw new Error("max depth reached");
      const options = rules[symbol];
      if (!options) return symbol;
      const choice = options[Math.floor(rng() * options.length)];
      return choice.map((child) => sample(child, rules, rng, maxDepth - 1));
    }
  </script>
  <script id="87" type="application/vnd.observable.javascript" pinned="">
    sample("I", weightedRules, mulberry32(2))
  </script>
  <script id="110" type="application/vnd.observable.javascript" pinned="">
    sample("E", weightedRules, mulberry32(Math.random() * 10000))
  </script>
  <script id="133" type="text/markdown">
    ## In order traversal

    We convert the sampled production tree with an in-order traversal, concatenating the terminals.

  </script>
  <script id="182" type="application/vnd.observable.javascript" pinned="">
    function traverse(tree) {
      if (Array.isArray(tree)) return tree.map((child) => traverse(child)).join("");
      else return tree;
    }
  </script>
  <script id="190" type="application/vnd.observable.javascript">
    {
      while (true) {
        let s;
        try {
          s = traverse(
            sample("E", weightedRules, mulberry32(Math.random() * 10000))
          );
        } catch (err) {
          s = err.message;
        }
        console.log(s);

        yield Promises.delay(200, s);
      }
    }
  </script>
  <script id="221" type="application/vnd.observable.javascript">
    md`## Let Fuzz!

    So we generate a random integer for a seed, generate a expression, then see if our math parser can simplify it. If an exception is thrown, we stop the program and retreive the test case for bug fixing.

    For a linear programming problem, we want to avoid multiplying variables with variables (becuase thats a quadratic), so we introduce the concept of a variable carring production rules (suffix N), and prevent them from being multiplied by other variables.
    `
  </script>
  <script id="245" type="application/vnd.observable.javascript" pinned="">
    testRules = ({
      C: [["EN", "OP", "EN"]], // Conditional
      EN: [
        // Variable carrying expression cannot be multipled by other variables, so the expressions remain linear
        ["I"],
        ["V"],
        ["I"],
        ["V"],
        ["MN", "*", "M"],
        ["M", "*", "MN"],
        ["EN", "+", "EN"]
      ],
      E: [["I"], ["I"], ["I"], ["M", "*", "M"], ["E", "+", "E"]],
      MN: [
        ["I"],
        ["V"],
        ["I"],
        ["V"],
        ["M", "*", "M"],
        ["(", "EN", "+", "EN", ")"]
      ],
      M: [["I"], ["I"], ["I"], ["M", "*", "M"], ["(", "E", "+", "E", ")"]],
      V: [["x"], ["y"]],
      I: [["-2"], ["-1"], ["0"], ["1"], ["2"]],
      OP: [["<="], ["=="], [">="]]
    })
  </script>
  <script id="262" type="application/vnd.observable.javascript">
    Inputs.button("fast forward", {
      reduce: () => (mutable seed = mutable seed + 1)
    })
  </script>
  <script id="226" type="application/vnd.observable.javascript">
    mutable seed = Math.floor(Math.random() * 10000)
  </script>
  <script id="231" type="application/vnd.observable.javascript">
    expression = {
      const expr = traverse(sample("C", testRules, mulberry32(seed), 100));
      if (!expr.includes("x") && !expr.includes("y"))
        mutable seed = mutable seed + 1;
      return expr;
    }
  </script>
  <script id="236" type="application/vnd.observable.javascript" pinned="">
    result = extract_latest(expression)
  </script>
  <script id="306" type="application/vnd.observable.javascript" pinned="">
    {
      result;
      mutable seed = seed + 1;
    }
  </script>
  <script id="293" type="application/vnd.observable.javascript">
    import { extract as extract_latest } from "@tomlarkworthy/glpk-cannonicalization"
  </script>
  <script id="329" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="347" type="application/vnd.observable.javascript" pinned="">
    footer
  </script>
</notebook>
