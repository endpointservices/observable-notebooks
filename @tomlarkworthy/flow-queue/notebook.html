<!doctype html>
<notebook theme="air">
  <title>Convert cell computation to a Promise with cell flowQueue</title>
  <script id="0" type="text/markdown">
    # Convert cell computation to a Promise with cell *flowQueue*


    ~~~js
    import {flowQueue} from '@tomlarkworthy/flow-queue'
    ~~~

    ${await FileAttachment("flowQuery@1.svg").image({style: 'width:640px; max-width:100%'})}

    A flow queue releases values one-at-a-time onto a Dataflow graph, and collects a response before releasing the next. A *flowQueue* wraps Dataflow with a *promise*. It allows you to *unroll* a function body across dataflow cells, which is sometimes better for code layout and explanation. 

    The following video demonstrates its use during development of a webhook. Note a number of cells update as data passes through the system. 

    <video controls="controls" width="${Math.min(width, 640)}" height="400" loop name="Video Name">
      <source src="https://storage.googleapis.com/publicartifacts/blogimages/notebookwebhook.mov">
    </video>

    In other words, __*flowQueue* provides dataflow programming with a functional interface__. Consider the following

    ~~~js
    async doWork(arg) {
      const r1 = await step1(arg)
      const r2 = await step2(r1);
      return r2;
    }
    ~~~

    Using a *flowQueue* you can spread the asynchronous steps into different cells. To spread *doWork* across cells we first create a *flowQueue*, whose messages are *doWork*'s args.

    ~~~js
    viewof head = flowQueue()
    ~~~

    The refactored version of *doWork* will forward its *arg* to the *flowQueue* and returns the promise. (note: viewof)
    ~~~js
    doWork = (arg) => viewof head.send(arg)
    ~~~

    Now we unroll the body of *doWork* across several cells. Cell *r1* calls function *step1* and makes a dataflow dependency to *head* of the *flowQueue*. So when *head* updates, *r1* will too.
    ~~~js
    r1 = step1(head)
    ~~~

    The next step *r2* depends on the previous step.
    ~~~js
    r2 = step2(r1)
    ~~~

    To return a result, we call *resolve* to the *flowQueue*. This will resolve the *send* promise earlier, and allow the next  to run. (note: viewof)
    ~~~js
    {
      viewof head.resolve(r2)
    }
    ~~~

    ### Optimizations

    The *flowQueue* will unblock immediately when *resolve* is passed a *promise*.


    ### Errors

    Every *send* should lead to a call to *resolve*. If you call *resolve* an extra time it will throw an Error. If *resolve* is not called within *timeout_ms* (1000ms) the promise will reject. 


  </script>
  <script id="326" type="text/markdown">
    ## Changelog

    2022-05-16 API: resolve changed to *resolve*, as it ends up looking like a promise anyway
    2022-04-13 Bugfix: queue was not recovering after timeout properly.
  </script>
  <script id="36" type="application/vnd.observable.javascript" pinned="">
    flowQueue = ({ name, timeout_ms = 1000 } = {}) => {
      let runningResolve = undefined;
      let runningReject = undefined;
      const q = [];

      const ui = htl.html`<code>flowQueue()</code>`;

      const run = () => {
        const [head, resolve, reject] = q.shift();
        let timer;
        runningResolve = (val) => {
          clearTimeout(timer);
          return resolve(val);
        };
        runningReject = (err) => {
          clearTimeout(timer);
          return reject(err);
        };

        timer = setTimeout(
          () =>
            ui.reject(
              new Error(`Timeout (maybe increase timeout_ms?) ${name || ""}`)
            ),
          timeout_ms
        );

        ui.value = head;
        ui.dispatchEvent(new Event("input", { bubbles: true }));
      };

      ui.send = (task) =>
        new Promise((resolve, reject) => {
          q.push([task, resolve, reject]);
          if (runningResolve === undefined) run();
        });

      ui.reject = async (err) => {
        if (!runningReject) throw new Error(`No task executing! ${name || ""}`);
        const resolve = runningResolve;
        const reject = runningReject;
        runningResolve = undefined;
        runningReject = undefined;
        reject(err);
        if (q.length > 0) run();
      };

      ui.resolve = async (value) => {
        if (!runningResolve) throw new Error(`No task executing! ${name || ""}`);
        const resolve = runningResolve;
        const reject = runningReject;
        runningResolve = undefined;
        runningReject = undefined;
        if (q.length > 0) run();
        try {
          value = await value;
          resolve(value);
        } catch (err) {
          reject(err);
        }
      };

      ui.respond = ui.resolve; // old name

      return ui;
    }
  </script>
  <script id="155" type="text/markdown">
    ## Uses

    - Functional adapter, for interfacing with functional interfaces.
    - Testing, as you can write clear expected starting and ending criteria on a dataflow subgraph.
  </script>
  <script id="247" type="application/vnd.observable.javascript" pinned="">
    viewof sqrt = flowQueue()
  </script>
  <script id="253" type="application/vnd.observable.javascript" pinned="">
    viewof sqrt.resolve(Math.sqrt(sqrt))
  </script>
  <script id="185" type="application/vnd.observable.javascript">
    testing = {
      flowQueue; // load after implementation
      const [{ Runtime }, { default: define }] = await Promise.all([
        import(
          "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js"
        ),
        import(`https://api.observablehq.com/@tomlarkworthy/testing.js?v=3`)
      ]);
      const module = new Runtime().module(define);
      return Object.fromEntries(
        await Promise.all(
          ["expect", "createSuite"].map((n) => module.value(n).then((v) => [n, v]))
        )
      );
    }
  </script>
  <script id="188" type="application/vnd.observable.javascript">
    viewof suite = testing.createSuite({
      name: "Unit Tests"
    })
  </script>
  <script id="195" type="application/vnd.observable.javascript">
    suite.test("resolve after send resolves", async () => {
      const q = flowQueue();
      const prom = q.send("send val");
      testing.expect(q.value).toBe("send val");
      q.resolve("resolve val");
      const response = await prom;
      testing.expect(response).toBe("resolve val");
    });
  </script>
  <script id="345" type="application/vnd.observable.javascript">
    viewof maybeReply = flowQueue({ timeout_ms: 100 })
  </script>
  <script id="359" type="application/vnd.observable.javascript">
    maybeReplyReplier = {
      if (maybeReply === "reply") viewof maybeReply.resolve("reply");
    }
  </script>
  <script id="336" type="application/vnd.observable.javascript">
    suite.test("Unreplied queues recover after timeout_ms", async (done) => {
      try {
        await viewof maybeReply.send("no reply");
      } catch (err) {
        const result = await viewof maybeReply.send("reply");
        testing.expect(result).toEqual("reply");
        done();
      }
    })
  </script>
  <script id="208" type="application/vnd.observable.javascript">
    suite.test("resolve with promise", async () => {
      const q = flowQueue();
      const prom = q.send();
      q.resolve(new Promise((resolve) => resolve("resolve val")));
      const response = await prom;
      testing.expect(response).toBe("resolve val");
    })
  </script>
  <script id="212" type="application/vnd.observable.javascript">
    suite.test("resolve without send throws", async () => {
      const q = flowQueue();
      await testing
        .expect(q.resolve())
        .rejects.toEqual(Error("No task executing! "));
    })
  </script>
  <script id="225" type="application/vnd.observable.javascript">
    suite.test("missing resolve rejects with timout", async () => {
      const q = flowQueue({ timeout_ms: 1 });
      await testing
        .expect(q.send())
        .rejects.toEqual(Error("Timeout (maybe increase timeout_ms?) "));
    })
  </script>
  <script id="259" type="application/vnd.observable.javascript">
    suite.test("works in a real notebook", async () => {
      // Here we call a flowQueue that resides in the cells underneath, and collect the result.
      const result = viewof sqrt.send(4);
      await testing.expect(result).resolves.toBe(2);
    })
  </script>
  <script id="309" type="application/vnd.observable.javascript">
    //import { footer } from "@endpointservices/footer"
  </script>
  <script id="312" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
