<!doctype html>
<notebook theme="air">
  <title>Playing with Redis</title>
  <script id="0" type="text/markdown">
    # Playing with Redis
  </script>
  <script id="10" type="application/vnd.observable.javascript">
    import { createClient } from "@tomlarkworthy/redis"
  </script>
  <script id="6" type="application/vnd.observable.javascript" pinned="">
    connection1 = createClient({
      socket: redisConfig
    })
  </script>
  <script id="231" type="text/markdown">
    ## Get all KEYS with ["KEYS", "0"]
  </script>
  <script id="226" type="application/vnd.observable.javascript">
    Inputs.table(
      (await connection1.sendCommand(["KEYS", "*"])).sort().map((key) => ({
        key
      }))
    )
  </script>
  <script id="87" type="text/markdown">
    ## Using a queue (RPUSH and BLPOP)
  </script>
  <script id="31" type="text/markdown">
    ### send message by publishing: Right Push (RPUSH)|
  </script>
  <script id="40" type="application/vnd.observable.javascript">
    viewof userMessage = Inputs.text({
      placeholder: "message"
    })
  </script>
  <script id="36" type="application/vnd.observable.javascript" pinned="">
    messages_in_len = connection1.sendCommand(["RPUSH", "messages_in", userMessage])
  </script>
  <script id="52" type="text/markdown">
    ### listen for messages: Blocking Left Pop

    requires hogging a connection.
  </script>
  <script id="58" type="application/vnd.observable.javascript" pinned="">
    messageListener = createClient({
      socket: redisConfig,
      invalidation
    })
  </script>
  <script id="60" type="application/vnd.observable.javascript" pinned="">
    latestMessage = {
      while (true) yield messageListener.sendCommand(["BLPOP", "messages_in", "0"]);
    }
  </script>
  <script id="78" type="application/vnd.observable.javascript" pinned="">
    latestMessage
  </script>
  <script id="92" type="text/markdown">
    ## Executing a Lua Script
  </script>
  <script id="98" type="application/vnd.observable.javascript" pinned="">
    connection1.sendCommand(["EVAL", `return 'Hello, scripting!'`, "0"])
  </script>
  <script id="137" type="text/markdown">
    ## Atomic fanout to many queues

    The blocking queue approach
    - After a BRPOP, the client could break and a message would be lost.
  </script>
  <script id="185" type="application/vnd.observable.javascript">
    SUBSCRIBERS_KEY = "s1"
  </script>
  <script id="142" type="application/vnd.observable.javascript" pinned="">
    // We can read the whole set in an atomic operation, then enqueue to all client queues in one atmic action with a transaction.
    // We *could* put them all in a single transaction, but this would fail if the listener set was modified during the writing process, which is O(n) and thus larger fanout will fail more often.
    // For our chosen causal consistency model, we only need the read to be correct at *some* snapshot in time, and we need the action to be atomic, so its only necissary to do a transaction on the queues. This transaction is unlikely to fail as we are just pushing which has a special case of conflict resolution.
    send_many = async (subscribers, userMessage) => {
      const queues = await connection1.sendCommand(["SMEMBERS", subscribers]);
      connection1.sendCommand(["MULTI"]);
      queues.forEach((q) => connection1.sendCommand(["RPUSH", q, userMessage]));
      return connection1.sendCommand(["EXEC"]);
    }
  </script>
  <script id="132" type="application/vnd.observable.javascript">
    Inputs.button("send_many", {
      reduce: () => {
        send_many(SUBSCRIBERS_KEY, "hi " + Math.random().toString(16).substring(3));
      }
    })
  </script>
  <script id="202" type="application/vnd.observable.javascript" pinned="">
    q1Messages = {
      while (true) {
        yield q1Client.sendCommand(["BLPOP", "q1", "0"]);
      }
    }
  </script>
  <script id="221" type="application/vnd.observable.javascript">
    q2Messages = {
      while (true) {
        yield q2Client.sendCommand(["BLPOP", "q2", "0"]);
      }
    }
  </script>
  <script id="161" type="application/vnd.observable.javascript" pinned="">
    subscribe = (subscribers, id) =>
      connection1.sendCommand(["SADD", subscribers, id])
  </script>
  <script id="193" type="application/vnd.observable.javascript" pinned="">
    initialize = {
      connection1.sendCommand(["DEL", SUBSCRIBERS_KEY]);
      subscribe(SUBSCRIBERS_KEY, "q1");
      subscribe(SUBSCRIBERS_KEY, "q2");
    }
  </script>
  <script id="189" type="application/vnd.observable.javascript">
    members = (initialize, connection1.sendCommand(["SMEMBERS", SUBSCRIBERS_KEY]))
  </script>
  <script id="204" type="application/vnd.observable.javascript">
    q1Client = createClient({
      socket: redisConfig
    })
  </script>
  <script id="223" type="application/vnd.observable.javascript">
    q2Client = createClient({
      socket: redisConfig
    })
  </script>
  <script id="309" type="text/markdown">
    ### ACKing a stream
  </script>
  <script id="317" type="application/vnd.observable.javascript">
    GROUP = "g0"
  </script>
  <script id="345" type="application/vnd.observable.javascript" pinned="">
    connection1.sendCommand(["XGROUP", "CREATE", "stream-1", GROUP, POS1])
  </script>
  <script id="325" type="application/vnd.observable.javascript">
    CONSUMER = "c0"
  </script>
  <script id="322" type="application/vnd.observable.javascript">
    POS1 = "0"
  </script>
  <script id="331" type="application/vnd.observable.javascript" pinned="">
    // XADD key [NOMKSTREAM] [ MAXLEN | MINID [ = | ~] threshold [LIMIT count]] * | id field value [ field value ...]
    connection1.sendCommand(["XADD", "stream-1", "*", "message", "hi!"])
  </script>
  <script id="363" type="application/vnd.observable.javascript" pinned="">
    connection1.sendCommand(["XLEN", "stream-1"])
  </script>
  <script id="368" type="application/vnd.observable.javascript" pinned="">
    connection1.sendCommand(["XINFO", "STREAM", "stream-1"])
  </script>
  <script id="371" type="application/vnd.observable.javascript" pinned="">
    connection1.sendCommand(["XINFO", "CONSUMERS", "stream-1", GROUP])
  </script>
  <script id="350" type="application/vnd.observable.javascript" pinned="">
    streamClient = createClient({
      socket: redisConfig
    })
  </script>
  <script id="365" type="application/vnd.observable.javascript" pinned="">
    streamClient.sendCommand(["XREAD", "COUNT", "1", "STREAMS", "stream-1", POS1])
  </script>
  <script id="320" type="application/vnd.observable.javascript" pinned="">
    streamClient.sendCommand([
      "XREADGROUP",
      "GROUP",
      GROUP,
      CONSUMER,
      "COUNT",
      "2",
      "STREAMS",
      "stream-1",
      POS1
    ])
  </script>
  <script id="357" type="application/vnd.observable.javascript" pinned="">
    connection1.sendCommand(["XPENDING", "stream-1", GROUP])
  </script>
  <script id="213" type="text/markdown">
    ---
    ## Config
  </script>
  <script id="8" type="application/vnd.observable.javascript">
    redisConfig = ({
      host: "redis.webcode.run",
      port: 443,
      tls: true
    })
  </script>
</notebook>
