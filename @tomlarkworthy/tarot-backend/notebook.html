<!doctype html>
<notebook theme="air">
  <title>Tarot Backend (ChatGPT fortune teller)</title>
  <script id="0" type="text/markdown">
    # Tarot Backend (ChatGPT fortune teller)

    Welcome curious traveler to the Tarot backend. Its purpose is to show you how you can make a fully working app entirely from the comfort of an Observable notebook. You can fork this notebook and create your own.

    The Tarot Backend uses [OpenAI](https://openai.com/) to interpret a 3 card tarot spread. The OpenAI API key is kept secret by executing it serverside in an API endpoint defined inline to the notebook using [webcode.run](https://webcode.run). You can bring your own OpenAI API key so you can run that remote logic locally which is useful during development.

    A history of readings is stored in a Firebase realtime database, and is protected with a service_account, again you can bring your own service account and execute it locally. The service account also has access to Google Cloud Storage

    During an API call, the notebook prerenders a social image and a HTML landing page for that reading. These artifacts are uploaded to Google Cloud Storage. When a user visits [thetarot.online](https://thetarot.online), we use Netlify rewrite rules to redirect to Google Cloud Storage [source](https://github.com/endpointservices/thetarot.online), this is the only code outside of Observable. It provides are really quick and simple way to provide a vanity domain. 

    The UI is designed hierarchically and assembled into a single cell, following the [scalable UI development methodology](https://observablehq.com/@tomlarkworthy/ui-development). This keeps the client notebook slim, it also simplifies embedding, and allows us to embed the application into other sites using [native Observable embedding functionality](https://observablehq.com/@observablehq/introduction-to-embedding).

    We the API request process across several Observable reactive dataflow cells using a [flowQueue](https://observablehq.com/@tomlarkworthy/flow-queue). If a step has a bug, we can then fix that individual line and the trace will continue which makes development very ergonomic. Furthermore, by exploiting [webcode.run](https://webcode.run) live coding, production traffic will be traced in the development notebook, and we can develop and debug directly on prod.

    Errors in prod are recorded with [Sentry](https://observablehq.com/@endpointservices/sentry), and active monitoring is performed with [uptimerobot + healthcheck](https://observablehq.com/@endpointservices/healthcheck).

  </script>
  <script id="1721" type="application/vnd.observable.javascript">
    toc("h2,h3,h4")
  </script>
  <script id="2150" type="text/markdown">
    ## Application UI

    This is the final application, it is a composite of all our separately designed UI pieces.
  </script>
  <script id="681" type="application/vnd.observable.javascript">
    viewof display = (font,
    console.log("viewof display"),
    view`<div style="height: 800px; display: none; background-image: url('${await FileAttachment(
      "imgonline-com-ua-TextureSeamless-ddu5gFbCzzWeXp (1) (1).webp"
    ).url()}'); background-size: contain; backgroud-color: #fff; font-family: Montserrat, sans-serif; max-width: auto;">
      <style>
        body {
          margin: 0px;
        }
        a[href] {
          color: #3182bd
        }
        a[href]:hover {
          text-decoration: underline;
        }
      </style>
      <div style="max-width: 740px; margin: auto">
        <h1 style="display: none">Tarot</h1>
        <a href="https://thetarot.online/index.html">
          <div style="width: 100vw;
      position: relative;
      left: 50%;
      right: 50%;
      margin-left: -50vw;
      margin-right: -50vw;background-color:#eef;"><h1 style="color: black; text-align: center; max-width:100%; padding: 30px; margin-bottom: 50px; padding-bottom: 30px; font-family: Verdana; size: 2em;"><i>thetarot.online</i>
          </h1></div>

        </a>
        ${["name", whoInput()]}
        ${["question", questionInput()]}
        <div style="pointer-events: none">
          ${["deck", pickCards()]}
        </div>
        ${["cards", showCards(cards)]}
        ${["fortune", fortuneOutput()]}
        ${["restart", restartButton()]}
        ${["share", shareButton()]}
        <p style="color: white; bottom: -10px"><small>
          The tarot reader is an open source <a href="https://observablehq.com/@tomlarkworthy/tarot">Observablehq.com</a> web notebook.
          <br>Photo by <a href="https://unsplash.com/@figmentprints?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Cat Han</a> on <a href="https://unsplash.com/s/photos/velvet?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>

        </small></p>
      </div>
    </div>`)
  </script>
  <script id="2161" type="text/markdown">
    ## Application Logic

    Business logic is in seperate cells to the UI, but reevaluates on changes to UI state and drives additional state changes.
  </script>
  <script id="2791" type="text/markdown">
    ### restartAction

    The restart cell binds to the "ask another question" button. It clears the UI state, and yields a value. By having the downstream transition cells reference the value of the restart, we can reset the transitional state too on a restart.
  </script>
  <script id="1781" type="application/vnd.observable.javascript" pinned="">
    restartAction = Generators.observe((notify) => {
      const onrestart = () => {
        console.log("restart");
        viewof display.fortune.value = "";
        viewof display.name.value = "";
        viewof display.question.value = "";
        viewof display.name.singleton.disabled = false;
        viewof display.question.singleton.disabled = false;
        viewof display.cards.style.display = "none";
        viewof display.deck.reset();
        notify();
      };
      viewof display.restart.addEventListener("click", onrestart);
      invalidation.then(() =>
        viewof display.restart.removeEventListener("click", onrestart)
      );

      notify();
    })
  </script>
  <script id="2805" type="text/markdown">
    ### Loading shared fortune

    If the URL contains a share id, we load a fortune from history.
  </script>
  <script id="2798" type="text/markdown">
    #### shareID

    First, we detect a share id from either the URL params, or the last path segment.
  </script>
  <script id="1982" type="application/vnd.observable.javascript" pinned="">
    shareId = {
      console.log("share id");
      const search = new URLSearchParams(location.search).get("share");
      if (search) return search;
      const path = location.pathname.split("/").slice(-1)[0];
      if (!path.match(/[.$\[\]#\/]/)) return path;
    }
  </script>
  <script id="2818" type="text/markdown">
    #### previousFortune

    If a shareId is present we load it from the realtime database, this will return null if shareId is undefined
  </script>
  <script id="1899" type="application/vnd.observable.javascript" pinned="">
    previousFortune = {
      console.log("previousFortune");
      const snapshot = await firebase
        .database()
        .ref(`/@tomlarkworthy/tarot-backend/calls/${shareId}`)
        .once("value");
      return snapshot.val();
    }
  </script>
  <script id="2826" type="text/markdown">
    #### loadPreviousFortune

    This cell executes once, and will update the UI with a previousFortune if we have one.
  </script>
  <script id="1892" type="application/vnd.observable.javascript" pinned="">
    loadPreviousFortune = {
      console.log("loadPreviousFortune");
      if (previousFortune) {
        viewof display.fortune.value =
          previousFortune.reading.choices[0].text ||
          previousFortune.reading.choices[0].message.content;
        viewof display.name.value = previousFortune.name;
        viewof display.question.value = previousFortune.question;
        viewof display.cards.cards.value = await findCardsByName(
          previousFortune.cards
        );
        viewof display.share.value = `${baseURL}/${shareId}`;
        viewof display.deck.value = 3;
        viewof display.deck.style.display = "none";
        viewof display.name.singleton.disabled = true;
        viewof display.question.singleton.disabled = true;
      }
    }
  </script>
  <script id="2831" type="text/markdown">
    ### Application State transitions

    The core application toggles the UI element visibility, based on their current state (which is modified by the user). 
  </script>
  <script id="1224" type="application/vnd.observable.javascript" pinned="">
    transitions = {
      display;
      restartAction; // recompute when display changes
      loadPreviousFortune; // Load history (happens once)
      console.log("transition");
      viewof display.style.display = "block";
      viewof display.name.style.display = "block";
      viewof display.question.style.display = "block";
      viewof display.deck.style.display = "block";

      if (display.name.length == 0) {
        // User has not filled in their name, hide everything except the name control
        viewof display.question.style.display = "none";
        viewof display.deck.style.display = "none";
        viewof display.cards.style.display = "none";
        viewof display.fortune.style.display = "none";
        viewof display.share.style.display = "none";
        viewof display.restart.style.display = "none";
        var state = "askName";
      } else if (display.question.length == 0) {
        viewof display.deck.style.display = "none";
        viewof display.cards.style.display = "none";
        viewof display.fortune.style.display = "none";
        viewof display.share.style.display = "none";
        viewof display.restart.style.display = "none";
        display.cards.cards = await getCards({ numCards: 3 });
        var state = "askQuestion";
      } else if (display.deck < 3) {
        viewof display.cards.style.display = "none";
        viewof display.fortune.style.display = "none";
        viewof display.restart.style.display = "none";
      } else if (display.deck >= 3) {
        viewof display.cards.style.display = "block";
        viewof display.fortune.style.display = "block";
        viewof display.name.style.display = "none";
        viewof display.question.style.display = "none";
        viewof display.deck.style.display = "none";
        viewof display.restart.style.display = "inline-block";
        var state = "showCards";
      }

      if (viewof display.fortune.value.length === 0 && display.deck >= 0) {
        // generate fortune *once*, and only once we are messing with cards
        viewof display.fortune.value = "...";
        viewof display.share.style.display = "none";
        getFortune({
          token: user.getIdToken(),
          name: display.name,
          cards: display.cards.cards,
          question: display.question
        })
          .then((fortune) => {
            viewof display.share.style.display = "inline-block";
            viewof display.share.value = `${baseURL}/${fortune.id}`;
            viewof display.fortune.value = fortune.reading;
            // We will also fetch it to prewarm the cache
            fetch(viewof display.share.value);
          })
          .catch((err) => {
            viewof display.fortune.value = err.message;
          });
        viewof display.name.singleton.disabled = true;
        viewof display.question.singleton.disabled = true;
      }
    }
  </script>
  <script id="2838" type="text/markdown">
    ## Configuration
  </script>
  <script id="1882" type="application/vnd.observable.javascript">
    baseURL = "https://thetarot.online"
  </script>
  <script id="196" type="text/markdown">
    ## Design
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    cards = []
  </script>
  <script id="1458" type="text/markdown">
    #### whoInput
  </script>
  <script id="2114" type="application/vnd.observable.javascript">
    NAME_MAX_LENGTH = 50
  </script>
  <script id="828" type="application/vnd.observable.javascript" pinned="">
    viewof name = whoInput()
  </script>
  <script id="825" type="application/vnd.observable.javascript">
    whoInput = () => {
      const uid = DOM.uid().id;
      const ui = view`<label for=${uid} style="display:block; color: white; background-color: ${textBackground}; padding: 10px; margin: 5px; border-radius: 10px; border: solid ${borderColor};">Who asks the cards?
    ${[
      "...",
      htl.html`<textarea id=${uid} style="width:100%; display:block; box-sizing:border-box; color: white; background-color: ${textBackground}; padding: 10px; border-radius: 10px;" type="text" placeholder="your first name? someone else's name?" maxlength=${NAME_MAX_LENGTH}>`
    ]}
    </label>`;
      return ui;
    }
  </script>
  <script id="1465" type="text/markdown">
    #### questionInput
  </script>
  <script id="2117" type="application/vnd.observable.javascript">
    QUESTION_MAX_LENGTH = 950 // OpenAI max length 1000 of user input (we spend 50 on the NAME)
  </script>
  <script id="815" type="application/vnd.observable.javascript" pinned="">
    viewof question = questionInput()
  </script>
  <script id="807" type="application/vnd.observable.javascript">
    questionInput = () => {
      const uid = DOM.uid().id;
      return view`<label for=${uid} style="display:block; color: white; background-color: ${textBackground}; padding: 10px; margin: 5px; border-radius: 10px; border: solid ${borderColor};" for="cheese">What is the question for the cards? You can include important context.
      ${[
        "...",
        htl.html`<textarea id=${uid} style="width:100%; display:block; box-sizing:border-box; color: white; background-color: ${textBackground}; padding: 10px; border-radius: 10px;" rows=10 placeholder="Write your question here..." maxlength=${QUESTION_MAX_LENGTH}>`
      ]}</textarea>
    </label>`;
    }
  </script>
  <script id="1470" type="text/markdown">
    #### fortuneOutput
  </script>
  <script id="1412" type="application/vnd.observable.javascript">
    fortuneOutput = () => {
      const uid = DOM.uid().id;
      const textarea = htl.html`<textarea disabled="true" id=${uid} style="width:100%; display:block; box-sizing:border-box; color: white; background-color: ${textBackground}; padding: 10px; border-radius: 10px;" rows=10></textarea>`;

      /*
      textarea.addEventListener("input", () => {
        textarea.style.height = `${textarea.scrollHeight}px`;
      });
      setTimeout(() => {
        textarea.style.height = `${textarea.scrollHeight}px`;
      }, 0);
      */

      return view`<div style="display:block; color: white; background-color: ${textBackground}; padding: 10px; margin: 5px; border-radius: 10px; border: solid ${borderColor};">${[
        "...",
        textarea
      ]}<small>
        ‚ö†Ô∏è interpretation by artificial intelligence. For entertainment only.
        </small></div>`;
    }
  </script>
  <script id="1417" type="application/vnd.observable.javascript" pinned="">
    viewof fortuneOutputExample = fortuneOutput()
  </script>
  <script id="1421" type="application/vnd.observable.javascript" pinned="">
    (viewof fortuneOutputExample.value = `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

    `)
  </script>
  <script id="1590" type="text/markdown">
    #### Share button
  </script>
  <script id="969" type="application/vnd.observable.javascript">
    shareButton = (url = "https://example.com") => {
      const ui = view`<div style="display:inline-block; background-color: ${textBackground}; padding: 10px; margin: 5px; border-radius: 10px; border: solid ${borderColor};">
        <p style="color: white;text-align:center">Share this fortune using the following link</p>
        <div style="font-size:24px; display: inline-flex;">
          <div style="position: relative;top:1px; padding-right: 10px">üîó</div>${[
            "...",
            htl.html`<input class="url"  style="border: none; color: white; width:300px" type="text" disabled value="${url}">`
          ]}
          <button class="btn" style="border: none;width: 70px; background-color: #28a745" onclick=${() => {
            navigator.clipboard.writeText(ui.querySelector(".url").value);
            ui.querySelector(".btn").innerHTML = "Copied";
            setTimeout(() => {
              ui.querySelector(".btn").innerHTML = "Copy";
            }, 1000);
          }}>Copy</button>
        </div>
      </div>`;
      return ui;
    }
  </script>
  <script id="1599" type="application/vnd.observable.javascript">
    viewof shareButtonExample = shareButton()
  </script>
  <script id="1639" type="application/vnd.observable.javascript" pinned="">
    (viewof shareButtonExample.value = "https://cool2.com ")
  </script>
  <script id="1595" type="text/markdown">
    #### restartButton
  </script>
  <script id="1698" type="application/vnd.observable.javascript">
    restartButton = (url = "https://example.com") => {
      const ui = view`<button class="btn" style="display:inline-block; background-color: #28a745; padding: 10px; margin: 5px; border-radius: 10px; border: solid ${borderColor}; color: white; font-size: 25px">Ask another question</button>`;
      return ui;
    }
  </script>
  <script id="1743" type="application/vnd.observable.javascript" pinned="">
    viewof restartButtonExample = restartButton()
  </script>
  <script id="1702" type="text/markdown">
    #### pickCards
  </script>
  <script id="1006" type="application/vnd.observable.javascript" pinned="">
    cardBack = FileAttachment("image-4.webp").image()
  </script>
  <script id="1014" type="application/vnd.observable.javascript">
    backUrl = FileAttachment("image-4.webp").url()
  </script>
  <script id="1101" type="text/html">
    <style>
      .pickable .card:hover {
        filter: hue-rotate(180deg);
        y: -10
      }
    </style>
  </script>
  <script id="974" type="application/vnd.observable.javascript">
    pickCards = () => {
      let state = "stack";
      const stack = () => htl.svg`<g transform="translate(500 ${spreadConfig.oy})">
          ${Array.from({ length: 78 }).map(
            (_, i) => htl.svg`<g class="spread" transform="rotate(${
              spreadConfig.oa
            })">
            <g transform="translate(0 ${spreadConfig.dy})">
              <image style="pointer-events: fill" class="card" width="100" height="150" href=${backUrl} onclick=${(
              evt
            ) => {
              if (state === "stack") {
                state = "spread";
                const spreads = ui.querySelectorAll(".spread");
                for (const i in spreads) {
                  const element = spreads[i];
                  if (element.classList) {
                    element.classList.add("pickable");
                    const spread = htl.svg`<animateTransform attributeName="transform"
                                  attributeType="XML"
                                  type="rotate"
                                  from="${spreadConfig.oa}"
                                  to="${-i * spreadConfig.da + spreadConfig.oa}"
                                  dur="0.5s"
                                  fill="freeze"/>`;
                    element.appendChild(spread);
                    spread.beginElement();
                  }
                }
                ui.value = 0;
                ui.dispatchEvent(new Event("input", { bubbles: true }));
              } else if (state === "spread") {
                const slide = htl.svg`<animateTransform attributeName="transform"
                              attributeType="XML"
                              type="translate"
                              from="0 0"
                              to="0 -100"
                              dur="0.5s"
                              fill="freeze"/>`;
                const fade = htl.svg`<animate attributeName="opacity" dur="0.5" keyTimes="0;1" values="1;0;" fill="freeze"/>`;
                evt.target.appendChild(slide);
                evt.target.appendChild(fade);
                slide.beginElement();
                fade.beginElement();
                ui.value++;
                ui.dispatchEvent(new Event("input", { bubbles: true }));
              }
            }}>
            </image>
          </g></g>`
          )}
        </g>`;
      const pickPrompt = htl.svg`<text x="300" y="250" style="fill: ${borderColor}; font-family: Montserrat">Pick 3 cards</text>`;
      const ui = htl.svg`<svg viewbox="0 0 1000 400" style="margin-top:-10%">
          ${pickPrompt}
          ${stack()}
      </svg>`;
      ui.reset = () => {
        ui.innerHTML = pickPrompt.outerHTML;
        ui.appendChild(stack());
        state = ui.value = "stack";
        ui.dispatchEvent(new Event("input", { bubbles: true }));
      };
      return ui;
    }
  </script>
  <script id="980" type="application/vnd.observable.javascript">
    viewof pickCardsExample = pickCards()
  </script>
  <script id="1214" type="application/vnd.observable.javascript" pinned="">
    pickCardsExample
  </script>
  <script id="1838" type="application/vnd.observable.javascript" pinned="">
    viewof pickCardsExample.reset()
  </script>
  <script id="1047" type="application/vnd.observable.javascript">
    viewof spreadConfig = verticalSliders({
      names: ["dy", "oy", "da", "oa"],
      labels: ["dy", "oy", "da", "oa"],
      mins: [-1000, -1000, -2, -90],
      maxs: [1000, 1000, 2, 90],
      steps: [1, 1, 0.01, 1],
      values: [-818, 948, -0.77, -33]
    })
  </script>
  <script id="1073" type="application/vnd.observable.javascript">
    spreadConfig
  </script>
  <script id="1331" type="text/markdown">
    #### Show cards
  </script>
  <script id="1336" type="application/vnd.observable.javascript">
    showCards = juice(
      (cards) => {
        const ui = htl.svg`<svg viewBox="0 0 ${boardw} 400" width="100%">
        ${cards.map(
          (c, i) => htl.svg`<g transform="translate(${
            cpad * i + coffsetx
          } ${coffsety})">
          <rect x="0" y="${texty}" width="${cwidth}px" height="40px" stroke="red" stroke-width="3px" />
          <text x=${cwidth / 2} y="${
            texty + 25
          }" style="font: 40px serif; fill: red;" dominant-baseline="middle" text-anchor="middle" >${
            i == 0 ? "PAST" : i == 1 ? "PRESENT" : "FUTURE"
          }</text> 
          <image width=${cwidth} href=${c.imgURL} />
        `
        )}
      </svg>`;
        return ui;
      },
      { cards: "[0]" }
    )
  </script>
  <script id="4016" type="application/vnd.observable.javascript">
    viewof showCardsExample = Inputs.toggle({
      label: "show cards example?"
    })
  </script>
  <script id="1341" type="application/vnd.observable.javascript">
    viewof exampleCards = {
      if (showCardsExample) return showCards(await getCards({ numCards: 3 }));
      return invalidation;
    }
  </script>
  <script id="1394" type="application/vnd.observable.javascript">
    exampleCards
  </script>
  <script id="1398" type="application/vnd.observable.javascript">
    Inputs.button("shuffle", {
      reduce: async () => (exampleCards.cards = await getCards({ numCards: 3 }))
    })
  </script>
  <script id="581" type="text/markdown">
    ## Social Image Generator Pipeline
  </script>
  <script id="2319" type="text/html">
    <img src="${exampleOutput}">
  </script>
  <script id="2309" type="application/vnd.observable.javascript">
    viewof exampleOutput = Inputs.button("Run social Image flowQueue", {
      required: true,
      reduce: () =>
        socialImage({
          shareId: "-MydHQ7WsdpMYfOwMUcY"
        })
    })
  </script>
  <script id="2339" type="application/vnd.observable.javascript">
    socialImage = async ({ shareId } = {}) => {
      try {
        return viewof socialImageParams.send({
          shareId
        });
      } catch (err) {
        return undefined;
      }
    }
  </script>
  <script id="2298" type="application/vnd.observable.javascript">
    viewof socialImageParams = flowQueue({
      timeout_ms: 15000
    })
  </script>
  <script id="2420" type="application/vnd.observable.javascript">
    socialImageParams
  </script>
  <script id="2376" type="application/vnd.observable.javascript" pinned="">
    socialData = (
      await adminFirebase
        .database()
        .ref(`@tomlarkworthy/tarot-backend/calls/${socialImageParams.shareId}`)
        .once("value")
    ).val()
  </script>
  <script id="2197" type="application/vnd.observable.javascript">
    import { rasterize } from "@mbostock/saving-svg"
  </script>
  <script id="2171" type="application/vnd.observable.javascript">
    image = {
      if (socialData) {
        return socialImageInner({
          cards: await findCardsByName(socialData.cards),
          reading:
            socialData.reading.choices[0].text ||
            socialData.reading.choices[0].message.content
        });
      } else {
        const err = new Error("Can't find fortune");
        err.status = 404;
        viewof socialImageParams.reject(err);
        return err;
      }
    }
  </script>
  <script id="3098" type="text/markdown">
    #### socialImageInner
  </script>
  <script id="237" type="application/vnd.observable.javascript">
    boardw = 1218
  </script>
  <script id="367" type="application/vnd.observable.javascript">
    boardh = 618
  </script>
  <script id="273" type="application/vnd.observable.javascript">
    viewof texty = Inputs.range([-100, 500], {
      label: "text offset y",
      step: 1,
      value: -45
    })
  </script>
  <script id="243" type="application/vnd.observable.javascript">
    viewof coffsetx = Inputs.range([0, 500], {
      label: "card offset x",
      step: 1,
      value: 172
    })
  </script>
  <script id="249" type="application/vnd.observable.javascript">
    viewof coffsety = Inputs.range([0, 500], {
      label: "card offset y",
      step: 1,
      value: 74
    })
  </script>
  <script id="227" type="application/vnd.observable.javascript">
    viewof cwidth = Inputs.range([0, 500], {
      label: "card width",
      step: 1,
      value: 176
    })
  </script>
  <script id="234" type="application/vnd.observable.javascript">
    viewof cpad = Inputs.range([0, 500], {
      label: "card spacing",
      step: 1,
      value: 347
    })
  </script>
  <script id="502" type="application/vnd.observable.javascript">
    viewof textBackground = colorPicker("rgba(19, 17, 43, 0.77)")
  </script>
  <script id="557" type="application/vnd.observable.javascript">
    viewof borderColor = colorPicker("rgb(181, 101, 101)")
  </script>
  <script id="2166" type="application/vnd.observable.javascript" pinned="">
    socialImageInner = async ({ reading, cards } = {}) => {
      const promises = [];
      const ui = svg`<svg viewBox="0 0 ${boardw} 618" width="100%">
      <image width="100%" href=${await FileAttachment(
        "imgonline-com-ua-TextureSeamless-ddu5gFbCzzWeXp (1) (1).webp"
      ).url()} />
      ${cards.map(
        (c, i) => htl.svg`<g transform="translate(${
          cpad * i + coffsetx
        } ${coffsety})">
        <rect x="0" y="${texty}" width="${cwidth}px" height="40px" stroke="red" stroke-width="3px" />
        <text x=${cwidth / 2} y="${
          texty + 25
        }" style="font: 40px serif; fill: red;" dominant-baseline="middle" text-anchor="middle" >${
          i == 0 ? "PAST" : i == 1 ? "PRESENT" : "FUTURE"
        }</text> 
        <image width=${cwidth} href=${c.imgURL} />
      `
      )}

      <foreignObject x="50" width="${boardw - 100}px" y="${
        (boardh * 2) / 3 - 30
      }" height="${boardh / 3}">
        <div style="background-color: ${textBackground}; border-radius: 10px; border: solid ${borderColor};">
          <div class="fortune" style="color:white; width:${
            boardw - 140
          }px; height:${boardh / 3 - 5}px;font-family: Montserrat">
            ${reading}
          </div>
        </div>
      </foreignObject>
    </svg>`;

      await Promise.all(
        [...ui.querySelectorAll("image")].map((img) => img.decode())
      ).catch(() => {});
      return ui;
    }
  </script>
  <script id="2303" type="application/vnd.observable.javascript" pinned="">
    fitImage = {
      await textFit(image.querySelector(".fortune"), {
        alignHoriz: true,
        alignVert: true
      });
      // textFit did not look like it was always applied so I think we need to slow it down
      return new Promise((resolve) => setTimeout(() => resolve(image), 100));
    }
  </script>
  <script id="2240" type="application/vnd.observable.javascript">
    jpeg = dom2img.toJpeg(fitImage)
  </script>
  <script id="2233" type="application/vnd.observable.javascript">
    dom2img = await import("https://cdn.skypack.dev/html-to-image@1.9.0?min")
  </script>
  <script id="3655" type="text/markdown">
    #### End of Social Image Generation Pipeline
  </script>
  <script id="2317" type="application/vnd.observable.javascript">
    viewof socialImageParams.respond(jpeg)
  </script>
  <script id="1726" type="text/markdown">
    ## Business Logic
  </script>
  <script id="390" type="application/vnd.observable.javascript">
    viewof reading = Inputs.input(undefined)
  </script>
  <script id="1533" type="application/vnd.observable.javascript" pinned="">
    readingOrEmpty = viewof reading.value || ""
  </script>
  <script id="170" type="text/markdown">
    ### Run tarot reading in remote service

    We can pass the cards and question and name parameters to a webcode.run endpoint, which runs the core code remotely, and injects the OPENAI_API_KEY secret so you do not need to fill this out.

  </script>
  <script id="1505" type="application/vnd.observable.javascript">
    viewof clientResponse = Inputs.button("run remote", {
      reduce: async () => {
        const data = (
          await getFortune({
            token: user.getIdToken(),
            name: "Tom",
            cards: cards.map((c) => c.name),
            question: "Will I be rich?"
          })
        ).reading;
        viewof reading.value = data;
        viewof reading.dispatchEvent(new Event("input", { bubbles: true }));
        return data;
      }
    })
  </script>
  <script id="2437" type="text/markdown">
    ### getFortune API client 
  </script>
  <script id="1496" type="application/vnd.observable.javascript" pinned="">
    getFortune = async ({ name, token, cards, question } = {}) => {
      const url = `${apiServer.href}?config=${btoa(
        JSON.stringify({
          name,
          cards: cards.map((c) => c.name),
          question
        })
      )}`;
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${await user.getIdToken()}`
        }
      });
      if (response.status === 200) return await response.json();
      else {
        throw new Error(`Error ${response.status}: ${await response.text()}`);
      }
    }
  </script>
  <script id="162" type="text/markdown">
    ## API Server
  </script>
  <script id="2897" type="text/markdown">
    ### [Optional] Local Credentials
  </script>
  <script id="694" type="application/vnd.observable.javascript">
    viewof OPENAI_API_KEY = Inputs.bind(
      Inputs.text({ label: "OPENAI_API_KEY", placeholder: "API KEY" }),
      localStorageView("OPENAI_API_KEY")
    )
  </script>
  <script id="700" type="application/vnd.observable.javascript">
    viewof ADMIN_SERVICE_ACCOUNT = Inputs.bind(
      Inputs.text({ label: "TAROT_ADMIN_SERVICE_ACCOUNT" }),
      localStorageView("TAROT_ADMIN_SERVICE_ACCOUNT")
    )
  </script>
  <script id="62" type="text/markdown">
    This button uses the local credentials and bypasses the API by writing straight the the pipeline.

    ${Inputs.button("trigger API pipeline using local credentials", {
      required: true,
      reduce: async () => {
        const data = await viewof config.send({
          name: "Tom",
          cards: cards.map((c) => c.name),
          question: "Will I be rich?",
          OPENAI_API_KEY,
          ADMIN_SERVICE_ACCOUNT,
          token: await user.getIdToken()
        });

        viewof reading.value = data;
        viewof reading.dispatchEvent(new Event("input", { bubbles: true }));
      }
    })}
  </script>
  <script id="3943" type="text/markdown">
    ### Health check
  </script>
  <script id="3947" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("trigger health check", {
      required: true,
      reduce: async () => {
        return await Promise.all(
          Array.from({ length: 5 }).map(async () =>
            viewof config.send({
              health: true
            })
          )
        );
      }
    })
  </script>
  <script id="3748" type="text/markdown">
    ### Load Test

    We had some difficulties with stability, the load test fires 5 overlapping requests to test the concurrent behaviour
  </script>
  <script id="3753" type="application/vnd.observable.javascript">
    viewof results = Inputs.button(
      "trigger 5 API pipeline requests using local credentials",
      {
        required: true,
        reduce: async () => {
          return await Promise.all(
            Array.from({ length: 5 }).map(async () =>
              viewof config.send({
                name: "Tom",
                cards: cards.map((c) => c.name),
                question: "Will I be rich?",
                OPENAI_API_KEY,
                ADMIN_SERVICE_ACCOUNT,
                token: await user.getIdToken()
              })
            )
          );
        }
      }
    )
  </script>
  <script id="3792" type="text/markdown">
    ### Debug Case From History
  </script>
  <script id="3796" type="application/vnd.observable.javascript">
    viewof debugConfig = Inputs.bind(
      Inputs.text({
        label: "Enter config"
      }),
      localStorageView("tarotConfig")
    )
  </script>
  <script id="3804" type="application/vnd.observable.javascript">
    parsedDebugConfig = {
      try {
        return JSON.parse(atob(debugConfig));
      } catch (err) {
        return invalidation;
      }
    }
  </script>
  <script id="3809" type="application/vnd.observable.javascript" pinned="">
    viewof debugResults = Inputs.button("run debug case", {
      required: true,
      reduce: async () =>
        viewof config.send({
          ...parsedDebugConfig,
          OPENAI_API_KEY,
          ADMIN_SERVICE_ACCOUNT,
          token: await user.getIdToken()
        })
    })
  </script>
  <script id="3949" type="application/vnd.observable.javascript" pinned="">
    debugResults
  </script>
  <script id="2901" type="text/markdown">
    ### <a target="_blank" href=${apiServer.href + '?health'}>HTTP Endpoint</a>
  </script>
  <script id="20" type="application/vnd.observable.javascript">
    apiServer = endpoint(
      "api",
      async (req, res, ctx) => {
        debugger;
        // save in a DB, deduplication, rate limit, authentication
        const config = JSON.parse(
          atob(req.query.config || /* base64('{}') = */ "e30=")
        ); // name, cards, questions
        config.health = req.query.health !== undefined;
        config.token = req.headers["authorization"]?.split(" ")[1];
        config.OPENAI_API_KEY = ctx.secrets.OPENAI_API_KEY; // Mixin API_KEY from secrets
        config.ADMIN_SERVICE_ACCOUNT = ctx.secrets.secretadmin_service_account_key;
        try {
          const response = await viewof config.send(config);
          res.json(response);
        } catch (err) {
          res.status(500).json({
            error: err.toString()
          });
        }
      },
      {
        modifiers: ["orchistrator"],
        hostNotebook: "@tomlarkworthy/tarot-backend"
      }
    )
  </script>
  <script id="2905" type="text/markdown">
    ### API Request pipeline
  </script>
  <script id="33" type="application/vnd.observable.javascript" pinned="">
    viewof config = flowQueue({ timeout_ms: 45000 })
  </script>
  <script id="794" type="application/vnd.observable.javascript" pinned="">
    config
  </script>
  <script id="3676" type="text/markdown">
    #### Validate User Input
  </script>
  <script id="2123" type="application/vnd.observable.javascript" pinned="">
    validatedConfig = {
      var msg = "unknown";

      if (config.health) {
        return viewof config.respond("ok"); // Check queue health if param is 'health'
      }

      if (!config.question || config.question == "") {
        msg = "No question";
      } else if (config.question.length >= QUESTION_MAX_LENGTH) {
        msg = "Question too long";
      } else if (!config.name || config.name == "") {
        msg = "No name";
      } else if (config.name.length >= NAME_MAX_LENGTH) {
        msg = "Name too long";
      } else {
        return config;
      }

      const err = new Error(msg);
      err.status = 400;
      viewof config.reject(err);
      throw new Error(`Invalid request ${msg}`);
    }
  </script>
  <script id="3682" type="text/markdown">
    ### User token validation
  </script>
  <script id="771" type="application/vnd.observable.javascript">
    currentUser = {
      if (!validatedConfig) return invalidation; // Processing stops when doing a health check here.
      try {
        return verifyIdToken(adminFirebase, validatedConfig.token);
      } catch (err) {
        viewof config.reject(err);
      }
    }
  </script>
  <script id="3686" type="text/markdown">
    #### Rate limit check
  </script>
  <script id="785" type="application/vnd.observable.javascript" pinned="">
    currentUsersRequestsInLastDay = requestsInLastDay(currentUser.uid)
  </script>
  <script id="788" type="application/vnd.observable.javascript" pinned="">
    rateLimitOk = {
      if (currentUsersRequestsInLastDay < 20) {
        return true;
      } else {
        console.log("currentUsersRequestsInLastDay", currentUsersRequestsInLastDay);
        const err = new Error("You have exceeded your quota");
        err.status = 402;
        viewof config.reject(err);
        return invalidation;
      }
    }
  </script>
  <script id="3691" type="text/markdown">
    #### Call openAI
  </script>
  <script id="6" type="application/vnd.observable.javascript" pinned="">
    openapi_reponse = (rateLimitOk,
    recordMeteredUse(currentUser.uid),
    fetchp("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${config.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "user",
            content: `Pretend you are legendary fortune teller. "${config.name}" asks "${config.question}". The cards are "${config.cards[0]}" (past position), "${config.cards[1]}" (present) and the "${config.cards[2]}" (future). Please respond with just what you would say, including dramatic flare.`
          }
        ],
        ...settings
      })
    }))
  </script>
  <script id="4403" type="application/vnd.observable.javascript">
    import { fetchp } from "@tomlarkworthy/fetchp"
  </script>
  <script id="3582" type="text/markdown">
    #### OpenAI Generation Settings
  </script>
  <script id="1868" type="application/vnd.observable.javascript">
    settings = ({
      temperature: 0.9,
      max_tokens: 500,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0
    })
  </script>
  <script id="3586" type="text/markdown">
    #### OpenAI Response
  </script>
  <script id="14" type="application/vnd.observable.javascript" pinned="">
    result = openapi_reponse.status === 200
      ? openapi_reponse.json()
      : viewof config.reject(new Error(await openapi_reponse.text()))
  </script>
  <script id="3592" type="text/markdown">
    #### Record OpenAI Response in History
  </script>
  <script id="1873" type="application/vnd.observable.javascript" pinned="">
    id = {
      try {
        return persistHistory({
          ...viewof config.value,
          settings,
          reading: result
        });
      } catch (err) {
        viewof config.respond(result);
        throw err;
      }
    }
  </script>
  <script id="1850" type="text/markdown">
    ### history
  </script>
  <script id="1854" type="application/vnd.observable.javascript" pinned="">
    persistHistory = async ({ name, cards, question, reading, settings } = {}) => {
      const snap = await adminFirebase
        .database()
        .ref(`/@tomlarkworthy/tarot-backend/calls/`)
        .push({
          name,
          question,
          cards,
          reading,
          settings,
          time: { ".sv": "timestamp" }
        });
      return snap.key;
    }
  </script>
  <script id="3599" type="text/markdown">
    #### OpenAI Text Safety Classification
  </script>
  <script id="2090" type="application/vnd.observable.javascript" pinned="">
    // Not needed anymore
    classification = 0 /*contentFilter({
      content: result.choices[0].text,
      API_KEY: config.OPENAI_API_KEY
    })*/
  </script>
  <script id="596" type="text/markdown">
    ### Rate limiting
  </script>
  <script id="763" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("record use", {
      reduce: () => recordMeteredUse(user.uid)
    })
  </script>
  <script id="661" type="application/vnd.observable.javascript">
    recordMeteredUse = (uid) =>
      firebase
        .database()
        .ref(`/@tomlarkworthy/tarot-backend/users/${uid}/history/`)
        .push({ ".sv": "timestamp" })
  </script>
  <script id="635" type="application/vnd.observable.javascript" pinned="">
    requestsInLastDay = async (uid) => {
      const snap = await adminFirebase
        .database()
        .ref(`/@tomlarkworthy/tarot-backend/users/${uid}/history`)
        .once("value");
      return Object.values(snap.val() || {}).reduce(
        (sum, timestamp) =>
          timestamp > Date.now() - 1000 * 60 * 60 * 24 ? sum + 1 : sum,
        0
      );
    }
  </script>
  <script id="1481" type="application/vnd.observable.javascript" pinned="">
    quota = htl.html`<a target="_blank" href="https://console.firebase.google.com/u/0/project/larkworthy-dfb11/database/larkworthy-dfb11-default-rtdb/data/@tomlarkworthy/tarot-backend/users/${user.uid}/history">quota records`
  </script>
  <script id="2041" type="text/markdown">
    ### Content Filter

    https://beta.openai.com/docs/engines/content-filter

      - 0: The text is safe.
      - 1: This text is sensitive. This means that the text could be talking about a sensitive topic, something political, religious, or talking about a protected class such as race or nationality.
      - 2: This text is unsafe. This means that the text contains profane language, prejudiced or hateful language, something that could be NSFW, or text that portrays certain groups/people in a harmful manner.
  </script>
  <script id="2046" type="application/vnd.observable.javascript" pinned="">
    contentFilter = async ({ content, API_KEY } = {}) => {
      const response = await fetch(
        `https://api.openai.com/v1/engines/content-filter-alpha/completions`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${API_KEY}`
          },
          body: JSON.stringify({
            prompt: `<|endoftext|>${content}\n--\nLabel:`,
            temperature: 0,
            max_tokens: 1,
            top_p: 0,
            logprobs: 10
          })
        }
      );

      if (response.status !== 200) throw new Error(await response.text());

      const responseJson = await response.json();
      var output_label = responseJson["choices"][0]["text"];

      const toxic_threshold = -0.355;

      if (output_label == "2") {
        const logprobs = responseJson["choices"][0]["logprobs"]["top_logprobs"][0];
        if (logprobs["2"] < toxic_threshold) {
          const logprob_0 = logprobs["0"];
          const logprob_1 = logprobs["1"];

          if (logprob_0 && logprob_1) {
            if (logprob_0 >= logprob_1) {
              output_label = "0";
            } else {
              output_label = "1";
            }
          } else if (logprob_0) {
            output_label = "0";
          } else {
            output_label = "1";
          }
        }
      }
      if (!["0", "1", "2"].includes(output_label)) {
        output_label = "2";
      }
      return Number.parseInt(output_label);
    }
  </script>
  <script id="2057" type="application/vnd.observable.javascript" pinned="">
    viewof exampleFilter = Inputs.button("testContentFilter", {
      reduce: async () => {
        const text = loremIpsum({
          count: 1, // Number of "words", "sentences", or "paragraphs"
          format: "plain", // "plain" or "html"
          paragraphLowerBound: 3, // Min. number of sentences per paragraph.
          paragraphUpperBound: 7, // Max. number of sentences per paragarph.
          random: Math.random, // A PRNG function
          sentenceLowerBound: 5, // Min. number of words per sentence.
          sentenceUpperBound: 15, // Max. number of words per sentence.
          suffix: "\n", // Line ending, defaults to "\n" or "\r\n" (win32)
          units: "paragraph" // paragraph(s), "sentence(s)", or "word(s)"
        });
        return await contentFilter({
          API_KEY: OPENAI_API_KEY,
          content: text
        });
      }
    })
  </script>
  <script id="2667" type="text/markdown">
    #### uploadObject to Cloud Storage
  </script>
  <script id="2639" type="application/vnd.observable.javascript" pinned="">
    uploadObject = async ({ name, access_token, content_type, content } = {}) => {
      /*
       curl -X POST --data-binary @data.txt \
        -H "Authorization: Bearer $OAUTH2_TOKEN" \
        -H "Content-Type: application/txt" \
        "https://storage.googleapis.com/upload/storage/v1/b/larkworthy-dfb11.appspot.com/o?uploadType=media&name=data.txt"
      */
      const bucket = "larkworthy-dfb11.appspot.com";

      const response = await fetch(
        `https://storage.googleapis.com/upload/storage/v1/b/${bucket}/o?uploadType=media&name=${encodeURIComponent(
          name
        )}`,
        {
          method: "POST",
          headers: {
            "content-type": content_type,
            Authorization: `Bearer ${access_token}`
          },
          body: content
        }
      );
      if (response.status !== 200) throw new Error(`${await response.text()}`);
      else return response.json();
    }
  </script>
  <script id="2470" type="text/markdown">
    ### Generate Social Image
  </script>
  <script id="2474" type="application/vnd.observable.javascript" pinned="">
    fortuneImg = {
      try {
        return socialImage({
          shareId: id
        });
      } catch (err) {
        viewof config.respond(result);
        throw err;
      }
    }
  </script>
  <script id="2488" type="application/vnd.observable.javascript" pinned="">
    fortuneImageData = await fetch(fortuneImg)
      .then((res) => res.blob())
      .then((res) => res.arrayBuffer())
  </script>
  <script id="2502" type="application/vnd.observable.javascript">
    access_token = getAccessTokenFromServiceAccount(config.ADMIN_SERVICE_ACCOUNT)
  </script>
  <script id="2652" type="application/vnd.observable.javascript" pinned="">
    fortuneImageData
  </script>
  <script id="2681" type="text/markdown">
    #### uploadImageToCloud
  </script>
  <script id="2501" type="application/vnd.observable.javascript" pinned="">
    cloudImage = ({
      upload: await uploadObject({
        name: `@tomlarkworthy/tarot-backend/images/${id}`,
        content_type: "image/jpeg",
        access_token,
        content: fortuneImageData
      }),
      id
    })
  </script>
  <script id="2672" type="text/markdown">
    #### Render page()
  </script>
  <script id="2692" type="application/vnd.observable.javascript" pinned="">
    page = ({
      name,
      question,
      imgURL,
      shareId,
      debug = false
    } = {}) => `<!DOCTYPE html>
    <head>
      <link rel="preload" href="https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js" as="script" />
      <link rel="preload" href="https://api.observablehq.com/@tomlarkworthy/tarot-backend.js?v=3" as="script" />

      <title>${name ? `Tarot Reading for ${name}` : "Tarot Reader"}</title>
      <meta name="viewport" content="width=device-width;initial-scale=1.0;user-scalable=no;user-scalable=0;">
      <meta property="og:title" content="${
        name ? `Tarot Reading for ${name}` : "Tarot Reader"
      }">
      <meta property="og:description" content="${
        question || "Ask a question for the cards"
      }">
      <meta name="description" content="${
        question || "Ask a question for the cards"
      }">

      <meta property="og:type" content="article" />
      <meta property="og:image" content="${
        imgURL ||
        "https://storage.googleapis.com/larkworthy-dfb11.appspot.com/%40tomlarkworthy/tarot-backend/images/-MyWC6L4ZE1HtVWM1SRc"
      }">
      <meta property="og:url" content="${
        shareId ? `${baseURL}/${shareId}` : "https://thetarot.online"
      }">
      <meta name="twitter:card" content="summary_large_image">

    </head>
    <body style="background-color:black;">
    <div id="display"></div>
    <div id="debugger"></div>
    <script type="module">
    import {Runtime, Inspector} from "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js";
    import notebook from "https://api.observablehq.com/@tomlarkworthy/tarot-backend.js?v=3";
    new Runtime().module(notebook, name => {

      if (name === "viewof display") {
        return new Inspector(document.querySelector("#display"));
      } else if (name === "transitions") {
        return true;
      } else if (name === "ndd" && ${debug}) {
        return new Inspector(document.querySelector("#debugger"));
      }
    });
    <\/script>
    <script defer data-domain="thetarot.online" src="https://plausible.io/js/plausible.js"><\/script>`
  </script>
  <script id="3566" type="text/markdown">
    ### upload share page
  </script>
  <script id="2660" type="application/vnd.observable.javascript" pinned="">
    uploads = ({
      html: await uploadObject({
        name: `@tomlarkworthy/tarot-backend/pages/${id}`,
        content_type: "text/html",
        access_token,
        content: page({
          shareId: id,
          name: config.name,
          question: config.question,
          imgURL: cloudImage.upload.mediaLink
        })
      }),
      img: cloudImage.upload,
      id
    })
  </script>
  <script id="3605" type="text/markdown">
    #### End of Pipeline
  </script>
  <script id="12" type="application/vnd.observable.javascript" pinned="">
    responder = {
      uploads;
      try {
        if (classification == 0) {
          viewof config.respond({
            id,
            reading: result.choices[0].message.content
          });
        } else {
          const err = new Error(
            `Response was classified as sensative or unsafe. Try a different question.`
          );
          err.status = 400;
          throw err;
        }
      } catch (err) {
        viewof config.reject(err);
      }
    }
  </script>
  <script id="4291" type="text/markdown">
    ### clientside user
  </script>
  <script id="4277" type="application/vnd.observable.javascript">
    user = {
      try {
        if (getContext().serverless === true) {
          return invalidation;
        }
      } catch (err) {}
      return (await firebase.auth().signInAnonymously()).user;
    }
  </script>
  <script id="3561" type="text/markdown">
    ### manual deploy <a target="_blank" href="https://storage.googleapis.com/larkworthy-dfb11.appspot.com/@tomlarkworthy/tarot-backend/pages/index.html">index.html</a>
  </script>
  <script id="2723" type="application/vnd.observable.javascript">
    Inputs.button("update index.html", {
      reduce: async () => {
        await uploadObject({
          name: `@tomlarkworthy/tarot-backend/pages/index.html`,
          content_type: "text/html",
          access_token: await getAccessTokenFromServiceAccount(
            ADMIN_SERVICE_ACCOUNT
          ),
          content: page({})
        });
      }
    })
  </script>
  <script id="4356" type="text/markdown">
    ### Test server
  </script>
  <script id="4320" type="application/vnd.observable.javascript" pinned="">
    deploy(
      "index",
      (req, res) => {
        res.send(page({ debug: true }));
      },
      {
        hostNotebook: "@tomlarkworthy/tarot-backend"
      }
    )
  </script>
  <script id="3821" type="text/markdown">
    ### Debugging

    We will allow the notebook state to be serialized
  </script>
  <script id="3883" type="application/vnd.observable.javascript">
    import { notebookSnapshot, modules } from "@tomlarkworthy/notebook-snapshot"
  </script>
  <script id="3917" type="application/vnd.observable.javascript">
    trackingVariable_e3366d24de62 = true
  </script>
  <script id="3958" type="text/markdown">
    By exporting the state in a endoint we can sample the state of the server via a flatdata collector.
  </script>
  <script id="3912" type="application/vnd.observable.javascript" pinned="">
    endpoint(
      "variables",
      async (req, res) => {
        res.json(
          (await notebookSnapshot("trackingVariable_e3366d24de62")).map(
            (variable) => ({
              state: variable.state,
              name: variable.name,
              // Note these cells might contain personal information, so we only allow errors values to leave the environment
              ...(variable.state === "rejected" && { value: variable.value })
            })
          )
        );
      },
      {
        hostNotebook: "@tomlarkworthy/tarot-backend"
      }
    )
  </script>
  <script id="725" type="text/markdown">
    ## Firebase Backends
  </script>
  <script id="612" type="application/vnd.observable.javascript">
    import {
      firebase,
      DocView
    } with { userConfig as firebaseConfig } from "@tomlarkworthy/firebase"
  </script>
  <script id="706" type="application/vnd.observable.javascript">
    import { firebase as adminFirebase } with { adminConfig as firebaseConfig } from "@tomlarkworthy/firebase"
  </script>
  <script id="607" type="application/vnd.observable.javascript">
    userConfig = ({
      name: "userbase",
      apiKey: "AIzaSyBN4bxw6d0cM0CGPNzRrkRlBqwFQnPLdN4",
      authDomain: "larkworthy-dfb11.firebaseapp.com",
      databaseURL:
        "https://larkworthy-dfb11-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "larkworthy-dfb11",
      storageBucket: "larkworthy-dfb11.appspot.com",
      messagingSenderId: "786910701676",
      appId: "1:786910701676:web:8d7dd002acf3b78c74d049"
    })
  </script>
  <script id="704" type="application/vnd.observable.javascript">
    adminConfig = ({
      name: "adminbase",
      apiKey: "AIzaSyBN4bxw6d0cM0CGPNzRrkRlBqwFQnPLdN4",
      authDomain: "larkworthy-dfb11.firebaseapp.com",
      databaseURL:
        "https://larkworthy-dfb11-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "larkworthy-dfb11",
      storageBucket: "larkworthy-dfb11.appspot.com",
      messagingSenderId: "786910701676",
      appId: "1:786910701676:web:8d7dd002acf3b78c74d049"
    })
  </script>
  <script id="3007" type="text/markdown">
    ## Utilities
  </script>
  <script id="3011" type="text/markdown">
    ### findCardsByName
  </script>
  <script id="1923" type="application/vnd.observable.javascript">
    findCardsByName = async (cardNames) =>
      await promiseRecursive(
        cardNames
          .map((cardName) => cardData.cards.find((cd) => cd.name === cardName))
          .map((c) => ({
            name: c.name,
            imgURL: fileAttachments[c.img].url()
          }))
      )
  </script>
  <script id="3015" type="text/markdown">
    ### promiseRecursive
  </script>
  <script id="1970" type="application/vnd.observable.javascript">
    // Thanks you trincot!
    // https://stackoverflow.com/a/44072329/862295
    // A wonderful peice of code contralises all promises in a nexted object to the root.
    function promiseRecursive(obj) {
      const getPromises = (obj) =>
        Object.keys(obj).reduce(
          (acc, key) =>
            Object(obj[key]) !== obj[key]
              ? acc
              : acc.concat(
                  typeof obj[key].then === "function"
                    ? [[obj, key]]
                    : getPromises(obj[key])
                ),
          []
        );
      const all = getPromises(obj);
      return Promise.all(all.map(([obj, key]) => obj[key])).then(
        (responses) => (
          all.forEach(([obj, key], i) => (obj[key] = responses[i])), obj
        )
      );
    }
  </script>
  <script id="4059" type="text/markdown">
    ### textFit v2.3.1 11/2014 by STRML (strml.github.com) (see license in source)
  </script>
  <script id="449" type="application/vnd.observable.javascript">
    /**
     * textFit v2.3.1
     * Previously known as jQuery.textFit
     * 11/2014 by STRML (strml.github.com)
     * MIT License
     *
     * To use: textFit(document.getElementById('target-div'), options);
     *
     * Will make the *text* content inside a container scale to fit the container
     * The container is required to have a set width and height
     * Uses binary search to fit text with minimal layout calls.
     * Version 2.0 does not use jQuery.
     */
    /*global define:true, document:true, window:true, HTMLElement:true*/
    textFit = {
      var defaultSettings = {
        alignVert: false, // if true, textFit will align vertically using css tables
        alignHoriz: false, // if true, textFit will set text-align: center
        multiLine: false, // if true, textFit will not set white-space: no-wrap
        detectMultiLine: true, // disable to turn off automatic multi-line sensing
        minFontSize: 6,
        maxFontSize: 80,
        reProcess: true, // if true, textFit will re-process already-fit nodes. Set to 'false' for better performance
        widthOnly: false, // if true, textFit will fit text to element width, regardless of text height
        alignVertWithFlexbox: false // if true, textFit will use flexbox for vertical alignment
      };

      return function textFit(els, options) {
        if (!options) options = {};

        // Extend options.
        var settings = {};
        for (var key in defaultSettings) {
          if (options.hasOwnProperty(key)) {
            settings[key] = options[key];
          } else {
            settings[key] = defaultSettings[key];
          }
        }

        // Convert jQuery objects into arrays
        if (typeof els.toArray === "function") {
          els = els.toArray();
        }

        // Support passing a single el
        var elType = Object.prototype.toString.call(els);
        if (
          elType !== "[object Array]" &&
          elType !== "[object NodeList]" &&
          elType !== "[object HTMLCollection]"
        ) {
          els = [els];
        }

        // Process each el we've passed.
        for (var i = 0; i < els.length; i++) {
          processItem(els[i], settings);
        }
      };

      /**
       * The meat. Given an el, make the text inside it fit its parent.
       * @param  {DOMElement} el       Child el.
       * @param  {Object} settings     Options for fit.
       */
      function processItem(el, settings) {
        if (
          !isElement(el) ||
          (!settings.reProcess && el.getAttribute("textFitted"))
        ) {
          return false;
        }

        // Set textFitted attribute so we know this was processed.
        if (!settings.reProcess) {
          el.setAttribute("textFitted", 1);
        }

        var innerSpan, originalHeight, originalHTML, originalWidth;
        var low, mid, high;

        // Get element data.
        originalHTML = el.innerHTML;
        originalWidth = innerWidth(el);
        originalHeight = innerHeight(el);

        // Don't process if we can't find box dimensions
        if (!originalWidth || (!settings.widthOnly && !originalHeight)) {
          if (!settings.widthOnly)
            throw new Error(
              "Set a static height and width on the target element " +
                el.outerHTML +
                " before using textFit!"
            );
          else
            throw new Error(
              "Set a static width on the target element " +
                el.outerHTML +
                " before using textFit!"
            );
        }

        // Add textFitted span inside this container.
        if (originalHTML.indexOf("textFitted") === -1) {
          innerSpan = document.createElement("span");
          innerSpan.className = "textFitted";
          // Inline block ensure it takes on the size of its contents, even if they are enclosed
          // in other tags like <p>
          innerSpan.style["display"] = "inline-block";
          innerSpan.innerHTML = originalHTML;
          el.innerHTML = "";
          el.appendChild(innerSpan);
        } else {
          // Reprocessing.
          innerSpan = el.querySelector("span.textFitted");
          // Remove vertical align if we're reprocessing.
          if (hasClass(innerSpan, "textFitAlignVert")) {
            innerSpan.className = innerSpan.className.replace(
              "textFitAlignVert",
              ""
            );
            innerSpan.style["height"] = "";
            el.className.replace("textFitAlignVertFlex", "");
          }
        }

        // Prepare & set alignment
        if (settings.alignHoriz) {
          el.style["text-align"] = "center";
          innerSpan.style["text-align"] = "center";
        }

        // Check if this string is multiple lines
        // Not guaranteed to always work if you use wonky line-heights
        var multiLine = settings.multiLine;
        if (
          settings.detectMultiLine &&
          !multiLine &&
          innerSpan.getBoundingClientRect().height >=
            parseInt(window.getComputedStyle(innerSpan)["font-size"], 10) * 2
        ) {
          multiLine = true;
        }

        // If we're not treating this as a multiline string, don't let it wrap.
        if (!multiLine) {
          el.style["white-space"] = "nowrap";
        }

        low = settings.minFontSize;
        high = settings.maxFontSize;

        // Binary search for highest best fit
        var size = low;
        while (low <= high) {
          mid = (high + low) >> 1;
          innerSpan.style.fontSize = mid + "px";
          var innerSpanBoundingClientRect = innerSpan.getBoundingClientRect();
          if (
            innerSpanBoundingClientRect.width <= originalWidth &&
            (settings.widthOnly ||
              innerSpanBoundingClientRect.height <= originalHeight)
          ) {
            size = mid;
            low = mid + 1;
          } else {
            high = mid - 1;
          }
          // await injection point
        }
        // found, updating font if differs:
        if (innerSpan.style.fontSize != size + "px")
          innerSpan.style.fontSize = size + "px";

        // Our height is finalized. If we are aligning vertically, set that up.
        if (settings.alignVert) {
          addStyleSheet();
          var height = innerSpan.scrollHeight;
          if (window.getComputedStyle(el)["position"] === "static") {
            el.style["position"] = "relative";
          }
          if (!hasClass(innerSpan, "textFitAlignVert")) {
            innerSpan.className = innerSpan.className + " textFitAlignVert";
          }
          innerSpan.style["height"] = height + "px";
          if (
            settings.alignVertWithFlexbox &&
            !hasClass(el, "textFitAlignVertFlex")
          ) {
            el.className = el.className + " textFitAlignVertFlex";
          }
        }
      }

      // Calculate height without padding.
      function innerHeight(el) {
        var style = window.getComputedStyle(el, null);
        return (
          el.getBoundingClientRect().height -
          parseInt(style.getPropertyValue("padding-top"), 10) -
          parseInt(style.getPropertyValue("padding-bottom"), 10)
        );
      }

      // Calculate width without padding.
      function innerWidth(el) {
        var style = window.getComputedStyle(el, null);
        return (
          el.getBoundingClientRect().width -
          parseInt(style.getPropertyValue("padding-left"), 10) -
          parseInt(style.getPropertyValue("padding-right"), 10)
        );
      }

      //Returns true if it is a DOM element
      function isElement(o) {
        return typeof HTMLElement === "object"
          ? o instanceof HTMLElement //DOM2
          : o &&
              typeof o === "object" &&
              o !== null &&
              o.nodeType === 1 &&
              typeof o.nodeName === "string";
      }

      function hasClass(element, cls) {
        return (" " + element.className + " ").indexOf(" " + cls + " ") > -1;
      }

      // Better than a stylesheet dependency
      function addStyleSheet() {
        if (document.getElementById("textFitStyleSheet")) return;
        var style = [
          ".textFitAlignVert{",
          "position: absolute;",
          "top: 0; right: 0; bottom: 0; left: 0;",
          "margin: auto;",
          "display: flex;",
          "justify-content: center;",
          "flex-direction: column;",
          "}",
          ".textFitAlignVertFlex{",
          "display: flex;",
          "}",
          ".textFitAlignVertFlex .textFitAlignVert{",
          "position: static;",
          "}"
        ].join("");

        var css = document.createElement("style");
        css.type = "text/css";
        css.id = "textFitStyleSheet";
        css.innerHTML = style;
        document.body.appendChild(css);
      }
    }
  </script>
  <script id="439" type="application/vnd.observable.javascript">
    loremIpsum = (await require("https://bundle.run/lorem-ipsum@2.0.4")).loremIpsum
  </script>
  <script id="553" type="text/html">
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Montserrat&display=swap');
    </style>
  </script>
  <script id="3002" type="text/markdown">
    ## Dependencies
  </script>
  <script id="8" type="application/vnd.observable.javascript">
    import {
      getCards,
      images as cardData,
      fileAttachments
    } from "@triptych/tarot-utilities"
  </script>
  <script id="17" type="application/vnd.observable.javascript">
    import { endpoint } from "@endpointservices/webcode"
  </script>
  <script id="25" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="49" type="application/vnd.observable.javascript">
    import { localStorageView } from "@tomlarkworthy/local-storage-view"
  </script>
  <script id="505" type="application/vnd.observable.javascript">
    import { colorPicker } from "@shaunlebron/color-picker"
  </script>
  <script id="777" type="application/vnd.observable.javascript">
    import {
      verifyIdToken,
      getAccessTokenFromServiceAccount
    } from "@tomlarkworthy/firebase-admin"
  </script>
  <script id="809" type="application/vnd.observable.javascript">
    import { view, bindOneWay } from "@tomlarkworthy/view"
  </script>
  <script id="1044" type="application/vnd.observable.javascript">
    import { verticalSliders } from "@tomlarkworthy/vertical-sliders"
  </script>
  <script id="1351" type="application/vnd.observable.javascript">
    import { juice } from "@tomlarkworthy/juice"
  </script>
  <script id="1718" type="application/vnd.observable.javascript">
    import { toc } from "@nebrius/indented-toc"
  </script>
  <script id="2447" type="application/vnd.observable.javascript">
    import { deploy, getContext } from "@endpointservices/serverless-cells"
  </script>
  <script id="4227" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer-with-backups"
  </script>
  <script id="4068" type="text/markdown">
    ### Analytics & Backup
  </script>
  <script id="1310" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
