<!doctype html>
<notebook theme="air">
  <title>single stroke font</title>
  <script id="454" type="text/html">
    <h1 style="display: none;">single stroke font</h1>
    <div style="height:100px"">
  </script>
  <script id="341" type="application/vnd.observable.javascript">
    svg`<svg width="100%" height=200 viewBox="0 0 1000 100">
      <path stroke="green" stroke-width=3 d="${scaleAxisTransform(fontPath(text), {
        scale: scale
      })}" />
    </svg>`
  </script>
  <script id="489" type="application/vnd.observable.javascript">
    viewof fontSource = Inputs.bind(
      Inputs.text({
        label: "font *",
        width: 600
      }),
      localStorageView("ssf_font", {
        defaultValue:
          "http://fonts.gstatic.com/s/roboto/v15/7MygqTe2zs9YkP0adA9QQQ.ttf"
      })
    )
  </script>
  <script id="390" type="application/vnd.observable.javascript">
    viewof text = Inputs.text({ label: "Text", value: "single stroke font" })
  </script>
  <script id="401" type="application/vnd.observable.javascript">
    viewof scale = Inputs.range([0, 10], { label: "scale", value: 1.5 })
  </script>
  <script id="537" type="text/markdown">
    \* A list of _.ttf_ URLs is [here](https://gist.github.com/karimnaaji/b6c9c9e819204113e9cabf290d580551)
  </script>
  <script id="561" type="text/html">
    <div style="height:400px"">
  </script>
  <script id="91" type="text/markdown">
    ## Open Type (convert .ttf to SVG)
  </script>
  <script id="24" type="application/vnd.observable.javascript">
    num = {
      let i = 0;
      while (true) {
        i = (i + 1) % 10;
        yield i;
        await new Promise((r) => setTimeout(r, 100));
      }
    }
  </script>
  <script id="50" type="application/vnd.observable.javascript">
    opentype = require("opentype.js")
  </script>
  <script id="71" type="application/vnd.observable.javascript">
    font = new Promise((r, e) =>
      opentype.load(fontSource.replaceAll("http://", "https://"), (err, font) => {
        if (err) e(err);
        r(font);
      })
    )
  </script>
  <script id="54" type="application/vnd.observable.javascript">
    function fontPath(digit) {
      const path = font.getPath(digit.toString(), 0, 100, 100); // Get the path for the digit
      const svgPath = path.toSVG(); // Convert the path to an SVG path string
      return svgPath.match(/"(.*)"/)[1];
    }
  </script>
  <script id="56" type="application/vnd.observable.javascript">
    path = fontPath(num)
  </script>
  <script id="80" type="application/vnd.observable.javascript">
    shape = svg`<svg width=100 height=120 viewBox="0 0 100 100"><path fill=green stroke="green" stroke-width=3 d="${fontPath(
      num
    )}" >`
  </script>
  <script id="266" type="text/markdown">
    ## flow_mat (Medial/Scale Axis Transform)
    ### finds the skeleton of a shape
  </script>
  <script id="93" type="application/vnd.observable.javascript">
    flo_mat = import("https://unpkg.com/flo-mat@3.0.1/browser/index.min.js")
  </script>
  <script id="272" type="application/vnd.observable.javascript">
    matsToPath = {
      /**
       * Returns an SVG path string of a line.
       * @param ps The line endpoints.
       */
      function getLinePathStr(ps) {
        let [[x0, y0], [x1, y1]] = ps;
        return `M${round(x0)} ${round(y0)} L${round(x1)} ${round(y1)}`;
      }

      /**
       * Returns an SVG path string of a quadratic bezier curve.
       * @param ps The quadratic bezier control points.
       */
      function getQuadBezierPathStr(ps) {
        let [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return `M${round(x0)} ${round(y0)} Q${round(x1)} ${round(y1)} ${round(
          x2
        )} ${round(y2)}`;
      }

      /**
       * Returns an SVG path string of a cubic bezier curve.
       * @param ps The cubic bezier control points.
       */
      function getCubicBezierPathStr(ps) {
        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return `M${round(x0)} ${round(y0)} C${round(x1)} ${round(y1)} ${round(
          x2
        )} ${round(y2)} ${round(x3)} ${round(y3)}`;
      }

      /**
       * Returns a function that draws an array of MAT curves on an SVG element.
       * @param mats An array of MATs to draw.
       * @param svg The SVG element on which to draw.
       * @param type The type of MAT to draw. This simply affects the class on the
       * path element.
       */
      function drawMats(mats) {
        const paths = [];
        mats.forEach(f);

        /**
         * Draws a MAT curve on an SVG element.
         */
        function f(mat) {
          let cpNode = mat.cpNode;

          if (!cpNode) {
            return;
          }

          let fs = [
            ,
            ,
            getLinePathStr,
            getQuadBezierPathStr,
            getCubicBezierPathStr
          ];

          flo_mat.traverseEdges(cpNode, function (cpNode) {
            if (flo_mat.isTerminating(cpNode)) {
              return;
            }
            let bezier = flo_mat.getCurveToNext(cpNode);
            if (!bezier) {
              return;
            }
            paths.push(fs[bezier.length](bezier));
          });
        }
        return paths.join();
      }

      return drawMats;
    }
  </script>
  <script id="294" type="application/vnd.observable.javascript">
    svg`<svg width=100 height=100 viewBox="0 0 100 100">
      <path stroke="green" stroke-width=3 d="${scaleAxisTransform(path)}" />
    </svg>`
  </script>
  <script id="320" type="application/vnd.observable.javascript">
    scaleAxisTransform = (path, { scale = 1.5 } = {}) => {
      const paths = flo_mat.getPathsFromStr(path);
      const mats = flo_mat.findMats(paths);
      const sats = mats.map((mat) => flo_mat.toScaleAxis(mat, scale));
      return matsToPath(sats);
    }
  </script>
  <script id="520" type="application/vnd.observable.javascript">
    DecimalPrecision2 = (function () {
      if (Number.EPSILON === undefined) {
        Number.EPSILON = Math.pow(2, -52);
      }
      if (Math.sign === undefined) {
        Math.sign = function (x) {
          return (x > 0) - (x < 0) || +x;
        };
      }
      return {
        // Decimal round (half away from zero)
        round: function (num, decimalPlaces) {
          var p = Math.pow(10, decimalPlaces || 0);
          var n = num * p * (1 + Number.EPSILON);
          return Math.round(n) / p;
        },
        // Decimal ceil
        ceil: function (num, decimalPlaces) {
          var p = Math.pow(10, decimalPlaces || 0);
          var n = num * p * (1 - Math.sign(num) * Number.EPSILON);
          return Math.ceil(n) / p;
        },
        // Decimal floor
        floor: function (num, decimalPlaces) {
          var p = Math.pow(10, decimalPlaces || 0);
          var n = num * p * (1 + Math.sign(num) * Number.EPSILON);
          return Math.floor(n) / p;
        },
        // Decimal trunc
        trunc: function (num, decimalPlaces) {
          return (num < 0 ? this.ceil : this.floor)(num, decimalPlaces);
        },
        // Format using fixed-point notation
        toFixed: function (num, decimalPlaces) {
          return this.round(num, decimalPlaces).toFixed(decimalPlaces);
        }
      };
    })()
  </script>
  <script id="523" type="application/vnd.observable.javascript" pinned="">
    DecimalPrecision2.trunc(3.321321321, 2)
  </script>
  <script id="497" type="application/vnd.observable.javascript">
    round = (n) => DecimalPrecision2.trunc(n, 2)
  </script>
  <script id="550" type="application/vnd.observable.javascript">
    import { localStorageView } from "@tomlarkworthy/local-storage-view"
  </script>
</notebook>
