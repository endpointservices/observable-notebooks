<!doctype html>
<notebook theme="air">
  <title>Design Guidelines and Linter for Reusable UI Components</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`# Design Guidelines and Linter for Reusable UI Components

    Lets collect best practices for \`viewof\` and [Input](/@observablehq/inputs) development. Comments and suggestions *extremely* welcome. 

    The general idea is that if we build our UI components in a certain way, then they can be programatically scripted by other UI components, allowing rich animations or powerful UIs from smaller atomic pieces.

    This is my best guess at what it takes, from experience building [@tomlarkworthy/animation](/@tomlarkworthy/animation)

    [@mootari](/@mootari) helped considerably with ideation and refinement of the linting rules. 
    `
  </script>
  <script id="132" type="application/vnd.observable.javascript">
    md`### Conformance linter
    Enter a notebook url and a cell name to run (limited) automated testing for UI best practices
    `
  </script>
  <script id="142" type="application/vnd.observable.javascript">
    viewof testTarget = {
      function test() {
        ui.value = {
          notebook: notebookEl.value.replace("https://observablehq.com/", ''),
          cell: cellEl.value
        };
        ui.dispatchEvent(new CustomEvent('input'));
      }
      const ui = html`
        <input class="notebook"
               style="width: 50%"
               size="50"
               placeholder="Notebook URL" 
               value=${args.notebook} />
        <br>
        <input class="cell"
               style="width: 40%"
               size="20"
               placeholder="cell"
               value=${args.cell} />
        <button class="test-btn" style="width: 10%">test</button>
      `;
      const notebookEl = ui.querySelector(".notebook");
      const cellEl = ui.querySelector(".cell");
      const testButtonEl = ui.querySelector(".test-btn");
      testButtonEl.addEventListener('click', test);
      test();
      return ui;
    }
  </script>
  <script id="422" type="application/vnd.observable.javascript">
    {
      const link = `${testTarget.notebook}#${testTarget.cell}`;
      const permlink =
        `?notebook=${encodeURIComponent(testTarget.notebook)}` +
        `&cell=${encodeURIComponent(testTarget.cell)}`;

      return md`
    Component source: [${link}](/${link})

    Linter permlink: [${permlink}](${permlink})`;
    }
  </script>
  <script id="630" type="application/vnd.observable.javascript">
    md`### Test component`
  </script>
  <script id="627" type="application/vnd.observable.javascript">
    build()
  </script>
  <script id="517" type="application/vnd.observable.javascript">
    md`
    ### Some famous UI controls linter results
    - [@observablehq/inputs#Range](https://observablehq.com/@tomlarkworthy/ui-linter?notebook=%40observablehq%2Finputs&cell=Range)
      - ðŸ˜Ž
    - [@jashkenas/inputs#slider](https://observablehq.com/@tomlarkworthy/ui-linter?notebook=%40jashkenas%2Finputs&cell=slider)
      - No property setter
    - [@mootari/range-slider#rangeSlider](https://observablehq.com/@tomlarkworthy/ui-linter?notebook=%40mootari%2Frange-slider&cell=rangeSlider)
      - No property setter
    - [@bartok32/diy-inputs#slider](https://observablehq.com/@tomlarkworthy/ui-linter?notebook=%40bartok32%2Fdiy-inputs&cell=slider)
      - No property setter
      - input event with bubbles: false
    - [@tomlarkworthy/native-inputs#Range](https://observablehq.com/@tomlarkworthy/ui-linter?notebook=%40tomlarkworthy%2Fnative-inputs&cell=Range)
      - ðŸ˜Ž (not famous but useful to compare with native behaviour)
    - [@bryangingechen/grid-inputs#grid](https://observablehq.com/@tomlarkworthy/ui-linter?notebook=%40bryangingechen%2Fgrid-inputs&cell=grid)
      - input events don't bubble (not caught by linter yet)
      - No property setter
    `
  </script>
  <script id="233" type="application/vnd.observable.javascript">
    viewof suite = createSuite({
      //name: `Automated UI conformance tests for ${testTarget.notebook}#${testTarget.cell}`
      name: `Design Lint Results`,
      timeout_ms: 1000
    })
  </script>
  <script id="216" type="application/vnd.observable.javascript">
    md`## Input constructor should be simple

    It's easier for people to get started if the simplest possible instantiation works out of the box.
    `
  </script>
  <script id="261" type="application/vnd.observable.javascript">
    suite.test("Constructor accepts zero args", async done => {
      await build();
      done();
    })
  </script>
  <script id="268" type="application/vnd.observable.javascript">
    suite.test("Constructor accepts empty object arg", async done => {
      await build();
      done();
    })
  </script>
  <script id="565" type="application/vnd.observable.javascript">
    md`## UI has addEventListener defined

    Its the absolute minimum to be a viewof
    `
  </script>
  <script id="570" type="application/vnd.observable.javascript">
    suite.test("Component has addEventListener method", async done => {
      const component = await build();
      expect(component.addEventListener).toBeDefined();
      done();
    })
  </script>
  <script id="308" type="application/vnd.observable.javascript">
    md`## Input _value_ should be enumerable

    Either an input is wrapping a primitive type, or its wrapping an object. If its an object it should have enumerable properties.
    `
  </script>
  <script id="313" type="application/vnd.observable.javascript">
    suite.test("Value is primitive or has enumerable properties", async done => {
      const component = await build();
      const value = component.value;
      if (typeof value === "object") {
        expect(Object.keys(value).length).toBeGreaterThan(0);
      }
      done();
    })
  </script>
  <script id="5" type="application/vnd.observable.javascript">
    backwritable = md`
    ## Input _value_ should be mutable (back writable)

    _value_ should be a writable _property_ of the view. Whatever comes out of the 'value' you should be able to push back in and the UI should update, just like native controls.

    ~~~js
    viewof example = {
      const ui = html\`...\`
      Object.defineProperty(ui, 'value', {
        get: ...
        set: (newVal) => ...   <--- Inputs should be mutable
      });
      return ui;
    }
    ~~~

    This allows other cells to add additional features without editing the source code, or create writable composite control views, or be driven by external animation. It makes the control reusable.
    `
  </script>
  <script id="284" type="application/vnd.observable.javascript">
    suite.test("Component value is defined", async done => {
      const component = await build();
      expect(component.value).toBeDefined();
      done();
    })
  </script>
  <script id="305" type="application/vnd.observable.javascript">
    suite.test("Component value is writable", async done => {
      const component = await build();
      const descriptor = Object.getOwnPropertyDescriptor(component, "value");

      if (descriptor && descriptor.set) {
        // If a setter is defined then it is explicitly writable
        done();
      } else if (
        component instanceof HTMLElement &&
        Object.getPrototypeOf(component).hasOwnProperty('value')
      ) {
        // DOM elements with native value are mutable
        done();
      } else {
        done(new Error("No property setter"));
      }
    })
  </script>
  <script id="678" type="application/vnd.observable.javascript" pinned="">
    {
      const component = await build();
      return Object.getOwnPropertyDescriptor(component, "value");
    }
  </script>
  <script id="99" type="application/vnd.observable.javascript">
    md`
    ## Inputs SHOULD NOT raise 'input' event on mutation

    _"This is intentional and matches the behavior of native inputs. You have to dispatch an event explicitly if desired."_ -- [M Bostock](https://github.com/observablehq/inputs/issues/73)
    `
  </script>
  <script id="339" type="application/vnd.observable.javascript">
    suite.test("Input events not raised on write", async done => {
      const component = await build();
      component.addEventListener('input', () => {
        done(new Error("Input event was raised on mutation"));
      });
      component.value = component.value;
      done();
    })
  </script>
  <script id="685" type="application/vnd.observable.javascript">
    md`
    ## Inputs SHOULD visually update on mutation

    While event should NOT be dispatch on mutatation, the UI should visually update for consistency with native components
    `
  </script>
  <script id="24" type="application/vnd.observable.javascript">
    md`
    ## Inputs SHOULD cache unchanged values

    _value_ should only change object reference when value changes.

    _"itâ€™d be better if the value object were the same if the value hasnâ€™t changed"_ -- [M Bostock](https://github.com/observablehq/inputs/issues/73)

    ~~~js
    viewof example = {
      let cache = calcValue();
      const ui = html\`...\`
      dispatch = () => {
        cache = calcValue();
        ui.dispatchEvent(new CustomEvent('input'))
      }
      Object.defineProperty(ui, 'value', {
        get: () => cache  <--- value is cached
      })
    }
    ~~~

    ---
    ` 
  </script>
  <script id="345" type="application/vnd.observable.javascript">
    suite.test("Component value is cached between sequential reads", async done => {
      const component = await build();
      const reading1 = component.value;
      const reading2 = component.value;
      expect(reading1).toBe(reading2); // Note reference equality
      done();
    })
  </script>
  <script id="35" type="application/vnd.observable.javascript">
    md`
    ## Input Event SHOULD bubble

    Input events leaving the UI component should have \`bubbles: true\`. This enables parents controls to listen to child events with minimal wiring, and is consistent with native 'input' events. Raise synthetic events like so: 

    ~~~js
        _.dispatchEvent(new Event('input', { bubbles: true }));
    ~~~

    This is how components might be reused, motivating the use of bubbling:-

    ~~~js
    viewof parent = {
      const ui = html\`<div>
        \${viewof child1()}
        \${viewof child2()}
      </div>\`
      ...
      return ui; // ui will emit an input events 
    }
    ~~~

    ---
    `
  </script>
  <script id="454" type="application/vnd.observable.javascript" pinned="">
    suite.test("Input events bubble", async done => {
      const component = await build();
      component.addEventListener('input', evt => {
        if (!evt.bubbles) {
          done(new Error("input event with bubbles: false"));
        }
      });

      component.querySelectorAll("input").forEach(inputEl => {
        inputEl.dispatchEvent(new CustomEvent('input', { bubbles: true }));
      });
      done();
    })
  </script>
  <script id="50" type="application/vnd.observable.javascript">
    md`### Remark 

    'Input Event SHOULD bubble' and 'Inputs SHOULD cache unchanged values' are not easy to implement at the same time. Should the parent catch the event, update the cache, then throw a new event?

    `
  </script>
  <script id="114" type="application/vnd.observable.javascript">
    md`## UI should work on mobile and desktop and a variety of browsers

    note _mousemove_ can act strange. _pointermove_ is better (?).

    Safari can be the odd one out too.

    `
  </script>
  <script id="488" type="application/vnd.observable.javascript">
    md`# Supporting State`
  </script>
  <script id="237" type="application/vnd.observable.javascript">
    build = {
      const cell = await peekFirst({
        notebook: testTarget.notebook,
        cell: testTarget.cell
      });
      if (typeof cell === 'function') return cell;
      else {
        throw new Error("Target cell must be a builder");
      }
    }
  </script>
  <script id="390" type="application/vnd.observable.javascript">
    args = {
      const s = new URLSearchParams(location.search);
      return {
        notebook:
          s.get("notebook") || 'https://observablehq.com/@bartok32/diy-inputs',
        cell: s.get('cell') || 'slider'
      };
    }
  </script>
  <script id="203" type="application/vnd.observable.javascript">
    import { peekFirst } from '@tomlarkworthy/metaprogramming'
  </script>
  <script id="228" type="application/vnd.observable.javascript">
    import { createSuite, expect } from '@tomlarkworthy/testing'
  </script>
  <script id="713" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="715" type="application/vnd.observable.javascript" pinned="">
    footer
  </script>
</notebook>
