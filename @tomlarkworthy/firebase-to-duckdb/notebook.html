<!doctype html>
<notebook theme="air">
  <title>Building a SMART FARM EP04: Firebase to DuckDB SQL</title>
  <script id="0" type="text/markdown">
    # Building a SMART FARM EP04: Firebase to DuckDB SQL

  </script>
  <script id="365" type="text/markdown">
    So far our SMART FARM has data storage provided by Firebase ([EP01](https://observablehq.com/@tomlarkworthy/livecoding-2022-06-07)), and it is actively ingesting data from real farms in Colombia using Blues Wireless cellular connection ([EP02](https://observablehq.com/@tomlarkworthy/blueswireless-2022-06-14)). We are able to send dashboards to field workers on-demand using WhatsApp ([EP03](https://observablehq.com/@tomlarkworthy/dashboards-over-whatsapp)). Now we wish to produce KPI's relevant to the industry, in our case the *Growing Degree Days* (GDD) which is a measure of plant maturation based on temperature over time.

    Firebase is not a good fit for data analytics, so we will stream our data into [DuckDB-WASM](https://duckdb.org/2021/10/29/duckdb-wasm.html) so we can do SQL inside the browser, in realtime.

    I learnt a lot of tricks by making this notebook
    - Throwing away a DuckDB client and recreating it is more memory efficient than dropping tables and recreating them.
    - Creating custom workflow, like a button to reset the state of the notebook, has massive ROI
    - Using a flowQueue is *great* for development of streaming pipelines, if a bug is encountered, the flow is interrupted and you can fix in-place and the streaming continues because of the cell memoization.
    - You can configure dataflow to refresh your SQL views when new data arrives, giving you a realtime SQL view.
  </script>
  <script id="1092" type="text/markdown">
    ## Full episode
  </script>
  <script id="343" type="text/html">
    <iframe width="${Math.min(width, 640)}" height="350" src="https://www.youtube.com/embed/VtNK9-kZ-Ys?start=${videoStartAt}&autoplay=${videoStartAt > 10 ? 1 : 0}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen> </iframe>
  </script>
  <script id="643" type="application/vnd.observable.javascript">
    viewof videoStartAt = Inputs.select(
      new Map([
        ["recap", 9],
        ["what analytics are useful to growers?", 45],
        ["setting up DuckDB", 375],
        ["Streaming firebase into DuckDB using flowQueue", 565],
        ["Setting up a reset button", 1180],
        ["Calculating growth days witb SQL cells", 1507],
        ["Using SQL Window function to extract intervals", 1755],
        ["Expanding with lookback window (Out of Memory Error!)", 2784],
        ["Writing back the computations into Firebase", 2940],
        ["Next steps, batch + realtime Lambda Architecture", 3070]
      ]),
      {
        label: "Jump to a location of interest"
      }
    )
  </script>
  <script id="85" type="text/markdown">
    ## Firebase Database
    Setup in [EP01](https://observablehq.com/@tomlarkworthy/livecoding-2022-06-07)
  </script>
  <script id="61" type="application/vnd.observable.javascript">
    import {
      firebase,
      viewof user,
      listen
    } with { firebaseConfig as firebaseConfig } from "@tomlarkworthy/firebase"
  </script>
  <script id="57" type="application/vnd.observable.javascript">
    firebaseConfig = ({
      apiKey: "AIzaSyA9OQ--0Sn8Gm6C1B4M-SbnxRMtKHgnHzs",
      authDomain: "agropatterns-iot.firebaseapp.com",
      databaseURL: "https://agropatterns-iot-default-rtdb.firebaseio.com",
      projectId: "agropatterns-iot",
      appId: "1:650132950601:web:115b1ba65750d2b0aaf998",
      uiConfig: {
        // https://github.com/firebase/firebaseui-web#configuration
        signInOptions: ["anonymous"]
      }
    })
  </script>
  <script id="87" type="application/vnd.observable.javascript">
    db = firebase.database()
  </script>
  <script id="176" type="text/markdown">
    ## Live Temperature Dashboard

    Setup in [EP02](https://observablehq.com/@tomlarkworthy/blueswireless-2022-06-14). This is 24 hour window of latest sensor readings. The green band represents the growth zone for the plant. Most sensors are sending data every 15 minutes which will be reflected in the dashboard automatically.
  </script>
  <script id="140" type="application/vnd.observable.javascript">
    viewof querySensorName = Inputs.select(Object.keys(latest), {
      label: "Choose sensor to chart",
      value: "dev:864475046461397"
    })
  </script>
  <script id="164" type="application/vnd.observable.javascript">
    dashboard = Plot.plot({
      x: { type: "time" },
      y: { domain: [0, 40], label: "Temperature" },
      color: {
        domain: [0, 40],
        scheme: "turbo"
      },
      marks: [
        Plot.rect([{}], { fill: "#F4BFA6", y1: 25, y2: 40 }),
        Plot.rect([{}], { fill: "#A7D3A6", y1: 5, y2: 25 }),
        Plot.rect([{}], { fill: "#A4B5E3", y1: 0, y2: 5 }),
        Plot.ruleY([20], { stroke: "#0003", strokeDasharray: [5] }),
        Plot.lineY(
          liveView.filter((d) => d.body.temperature), // Fix for unfiltering data serverside
          {
            stroke: "#0003",
            x: (d) => new Date(d.when * 1000),
            y: (d) => d.body.temperature
          }
        ),
        Plot.dot(
          liveView.filter((d) => d.body.temperature), // Fix for unfiltering data serverside
          {
            r: 5,
            x: (d) => new Date(d.when * 1000),
            y: (d) => d.body.temperature,
            fill: (d) => d.body.temperature
          }
        )
      ]
    })
  </script>
  <script id="157" type="text/markdown">
    ### streaming query (realtime updates)
  </script>
  <script id="159" type="application/vnd.observable.javascript" pinned="">
    liveViewRaw = Generators.observe((notify) => {
      db.ref(`history/sensors/${querySensorName}`)
        .orderByKey()
        .startAt(Math.floor(Date.now() / 1000 - 60 * 60 * 24) + "") // reduce data returned
        .on("value", (snapshot) => {
          const data = snapshot.val();
          if (data) notify(data);
        });
    })
  </script>
  <script id="166" type="application/vnd.observable.javascript">
    liveView = Object.entries(liveViewRaw).map(([k, v]) => v)
  </script>
  <script id="372" type="application/vnd.observable.javascript">
    latest = Generators.observe((notify) => {
      db.ref(`current/sensors`).once("value", (snapshot) => {
        const data = snapshot.val();
        // clear synthetic data from EP01 testings
        delete data["sensor2"];
        delete data["defaultSensorName"];
        notify(data);
      });
    })
  </script>
  <script id="261" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="1166" type="text/markdown">
    ## DuckDB

    In this episode we setup DuckDB
  </script>
  <script id="1168" type="application/vnd.observable.javascript">
    import { DuckDBClient } from "@cmudig/duckdb"
  </script>
  <script id="1171" type="application/vnd.observable.javascript" pinned="">
    duckdb = (reset, new DuckDBClient())
  </script>
  <script id="1598" type="text/markdown">
    By making a second reference to a common duckdb client, we can use the first reference to populate the tables, and refresh the 2nd whenever we received new data and need to recompute our SQL cell analytic queries. 
  </script>
  <script id="1244" type="application/vnd.observable.javascript" pinned="">
    fullduck = {
      // Refresh fullduck every insertion (causes analytics to be rerun)
      doInsertRowToDuckDB;
      return duckdb;
    }
  </script>
  <script id="1540" type="text/markdown">
    ### Workflow QoL
    The reset button allows us to reset the state and perform the data loading from scratch. *Extremely* useful during development.
  </script>
  <script id="1229" type="application/vnd.observable.javascript" pinned="">
    mutable reset = (daysLookback, 0)
  </script>
  <script id="1234" type="application/vnd.observable.javascript">
    Inputs.button("reset and reload data", {
      reduce: () => mutable reset++
    })
  </script>
  <script id="1543" type="text/markdown">
    ### Days Lookback

    This controls the size of the aggregation window

    ðŸ¤” In the livestream if the window function was greater than 2 DuckDB crashed. 

    ðŸ’¡ Since the livestream I noticed that recreating the duckdb client every reset allowed us to go to 5. Clearly dropping tables does not reclaim memory
  </script>
  <script id="1338" type="application/vnd.observable.javascript">
    viewof daysLookback = Inputs.range([1, 10], {
      label: "days to look back",
      step: 1,
      value: 1
    })
  </script>
  <script id="1512" type="application/vnd.observable.javascript">
    timeStartIso = new Date(timeStart * 1000).toISOString()
  </script>
  <script id="1509" type="application/vnd.observable.javascript">
    timeStart = Math.floor(Date.now() / 1000 - 60 * 60 * 24 * daysLookback)
  </script>
  <script id="1175" type="application/sql" pinned="" database="var:db">
    SELECT * FROM readings WEHRE 
      WHERE time > ${timeStartIso} 
      ORDER BY time ;
  </script>
  <script id="1180" type="application/vnd.observable.javascript" pinned="">
    doCreateTable = {
      reset;
      await duckdb.query(`DROP TABLE IF EXISTS readings`);
      return duckdb.query(
        `CREATE TABLE IF NOT EXISTS readings(sensor STRING, time TIMESTAMP, temperature FLOAT)`
      );
    }
  </script>
  <script id="1476" type="text/markdown">
    ### Streaming Firebase Query

    We pipe the results of a Firebase `child_added` into a `flowQueue` which will let us processes data one element at a time in realtime.
  </script>
  <script id="1164" type="application/vnd.observable.javascript" pinned="">
    lastAnalyticRow = Generators.observe((notify) => {
      reset;
      const dataHandler = (snapshot) => {
        const data = snapshot.val();
        console.log(data);
        if (data.body.temperature) {
          viewof firebaseRow.send(data);
          notify(data);
        }
      };
      const ref = db
        .ref(`history/sensors/${querySensorName}`)
        .orderByKey()
        .startAt(timeStart + ""); // reduce data returned

      ref.on("child_added", dataHandler);

      invalidation.then(() => {
        ref.off("child_added", dataHandler);
      });
    })
  </script>
  <script id="1482" type="text/markdown">
    ### Per row data processing
  </script>
  <script id="1186" type="application/vnd.observable.javascript" pinned="">
    viewof firebaseRow = (doCreateTable,
    flowQueue({
      timeout_ms: 10000000
    }))
  </script>
  <script id="1189" type="application/vnd.observable.javascript" pinned="">
    firebaseRow
  </script>
  <script id="1487" type="text/markdown">
    For each document from Firebase we execute a SQL INSERT statement to fill DuckDB
  </script>
  <script id="1194" type="application/vnd.observable.javascript" pinned="">
    doInsertRowToDuckDB = {
      doCreateTable;
      return duckdb.query(
        `INSERT INTO readings VALUES ('${firebaseRow.device}', '${new Date(
          (firebaseRow.when || firebaseRow.tower_when) * 1000
        ).toISOString()}', ${firebaseRow.body.temperature});`
      );
    }
  </script>
  <script id="1218" type="application/vnd.observable.javascript" pinned="">
    finishInsert = {
      doInsertRowToDuckDB; // Finsih processing everytime we insert a row
      viewof firebaseRow.resolve();
    }
  </script>
  <script id="1254" type="text/markdown">
    ## Realtime Analytics: Growing Degree Days (GDD)

    We perform analytics against our `fullduck` client which is refreshed every data insert.

    The first issue is we convert our point-in-time temperature measurements into intervals and calculate their average time using a WINDOW function. Based on the average temperature of the time interval we classify the segment as being in the growth zone or not.
  </script>
  <script id="1250" type="application/sql" pinned="" database="var:db">

    SELECT sensor, startTime, endTime, avgTemperature, endTime - startTime as duration, temperature > 5 AND temperature < 25 AS isGrowth 
      FROM (
      SELECT sensor, time, temperature, 
          AVG(temperature) OVER lookback avgTemperature,
          MIN(time) OVER lookback startTime,
          MAX(time) OVER lookback endTime
      FROM readings
      WHERE time > ${timeStartIso}
      WINDOW lookback AS (
        ORDER BY "time"
        ROWS 1 PRECEDING)
      ORDER BY time
    )
  </script>
  <script id="1494" type="text/markdown">
    Next we sum up the duration of our intervals that are classified as "growth" to compute total growthHours
  </script>
  <script id="1307" type="application/sql" pinned="" database="var:db">
    SELECT sensor, CAST(SUM(EXTRACT(epoch from growthDuration)) AS FLOAT) / (60 * 60) as growthHours
    FROM (SELECT *, CASE WHEN isGrowth THEN duration ELSE INTERVAL 0 seconds END growthDuration 
      FROM (
        SELECT sensor, startTime, endTime, avgTemperature, endTime - startTime as duration, temperature > 5 AND temperature < 25 AS isGrowth 
          FROM (
          SELECT sensor, time, temperature, 
              AVG(temperature) OVER lookback avgTemperature,
              MIN(time) OVER lookback startTime,
              MAX(time) OVER lookback endTime
          FROM readings
          WHERE time > ${timeStartIso} /* Our uploaded data is indexed wrong so this correct the misindexing */
          WINDOW lookback AS (
            ORDER BY "time"
            ROWS 1 PRECEDING)
          ORDER BY time
        )
      )
      ) GROUP BY sensor
  </script>
  <script id="1620" type="text/markdown">
    We can write these aggregations back into the DB (next time we will schedule these)
  </script>
  <script id="1352" type="application/vnd.observable.javascript" pinned="">
    writeAggregation = {
      await firebase.auth().signInAnonymously();
      return db
        .ref(
          `/aggregations/GDD/${querySensorName}/${new Date()
            .toISOString()
            .substring(0, 10)}`
        )
        .set(aggregation[0]);
    }
  </script>
  <script id="585" type="text/markdown">
    ## Next episode
  </script>
  <script id="616" type="application/vnd.observable.javascript">
    upcoming
  </script>
  <script id="453" type="text/markdown">
    ## Dependancies
  </script>
  <script id="592" type="application/vnd.observable.javascript">
    import { upcoming } from "@endpointservices/meetups";
  </script>
  <script id="206" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer"
  </script>
  <script id="227" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
