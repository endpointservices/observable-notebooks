<!doctype html>
<notebook theme="air">
  <title>notebookSnapshot()</title>
  <script id="0" type="text/markdown">
    # *notebookSnapshot()*

    This returns an array of the cell states *now*

    ```js
    [{
      name: String,  // [Optional] Cell name 
      state: String, // 'fulfilled', 'pending', 'rejected'
      value: Any     // pending/rejected value/reason
    }, ...]
    ```

    ---
    Usage:
    ```js
    import {notebookSnapshot} from '@tomlarkworthy/notebook-snapshot'
    ```

  </script>
  <script id="102" type="text/markdown">
    #### Thanks [@mootari/access-runtime](https://observablehq.com/@mootari/access-runtime)

    This notebook operates upon a hacks developed by [@mootari](/@mootari) and [@bryangingechen](/@bryangingechen). Read more in the dependency link ðŸ‘‡
  </script>
  <script id="8" type="application/vnd.observable.javascript">
    import { runtime, modules } from "@mootari/access-runtime"
  </script>
  <script id="171" type="text/markdown">
    ### Fixing for edge cases

    The trick used to discover which module is the current notebook can break with some modules. You can provide a known variable as the first parameter to aid detection of a particular notebook, but it's not needed for most usecases
  </script>
  <script id="113" type="text/markdown">
    ### Demo

    *look* its *this* notebook's snapshot! If you click refresh, the value of *refresh* increments, because of the default reduce action of an *Input.button*. I also added some Errors so you can see the state "rejected".
  </script>
  <script id="68" type="application/vnd.observable.javascript">
    viewof refresh = Inputs.button(md`refresh *notebookSnapshot()*`)
  </script>
  <script id="44" type="application/vnd.observable.javascript">
    exampleResults = (refresh,
    Inputs.table(await notebookSnapshot("dependsOnThrownError"), {
      columns: ["name", "state", "value"]
    }))
  </script>
  <script id="38" type="application/vnd.observable.javascript" pinned="">
    thrownError = {
      throw new Error("I was thrown!");
    }
  </script>
  <script id="47" type="application/vnd.observable.javascript">
    dependsOnThrownError = thrownError
  </script>
  <script id="119" type="text/markdown">
    ### Implementation
  </script>
  <script id="7" type="application/vnd.observable.javascript" pinned="">
    notebookSnapshot = (knownVariable) => {
      const moduleName = knownVariable
        ? modules.get(
            [...runtime._variables].find((v) => v._name === knownVariable)?._module
          )
        : "main";
      if (!moduleName) {
        debugger;
        throw new Error(
          `Cannot find tracking variable '${knownVariable}' for notebook snapshot in runtime variables ${JSON.stringify(
            [...runtime._variables]
          )}`
        );
      }
      console.log(moduleName);

      return Promise.all(
        Array.from(runtime._variables)
          .filter((v) => modules.get(v._module) === moduleName)
          .map((v) => {
            return promiseState(v._promise).then(([state, value]) => ({
              ...(v._name && { name: v._name }),
              value,
              state
            }));
          })
      );
    }
  </script>
  <script id="16" type="application/vnd.observable.javascript" pinned="">
    // Credit: Henning Koch
    // https://makandracards.com/makandra/46681-javascript-how-to-query-the-state-of-a-promise
    promiseState = (promise) =>
      new Promise((resolve) => {
        // Symbols and RegExps are never content-equal
        var uniqueValue = window["Symbol"] ? Symbol("unique") : /unique/;

        function notifyPendingOrResolved(value) {
          if (value === uniqueValue) {
            return resolve(["pending", undefined]);
          } else {
            return resolve(["fulfilled", value]);
          }
        }

        function notifyRejected(reason) {
          return resolve(["rejected", reason]);
        }

        var race = [promise, Promise.resolve(uniqueValue)];
        Promise.race(race).then(notifyPendingOrResolved, notifyRejected);
      })
  </script>
  <script id="216" type="text/markdown">
    ### Tests and CI

    We load the testing framework asynchronously to avoid statically depending on test libraries in production use. We can externally check these tests pass with [healthcheck](https://webcode.run/observablehq.com/@endpointservices/healthcheck?target=%40tomlarkworthy%2Fnotebook-snapshot&excludes=thrownError%2C+dependsOnThrownError&wait=5) which is passed to an external monitoring solution (see [howto-monitoring](https://observablehq.com/@tomlarkworthy/howto-monitoring)).

    Continuous integration is important for a library like this where API changes in Observable can easily break the implementation.
  </script>
  <script id="214" type="application/vnd.observable.javascript">
    testing = {
      const [{ Runtime }, { default: define }] = await Promise.all([
        import(
          "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js"
        ),
        import(`https://api.observablehq.com/@tomlarkworthy/testing.js?v=3`)
      ]);
      const module = new Runtime().module(define);
      return Object.fromEntries(
        await Promise.all(
          ["expect", "createSuite"].map((n) => module.value(n).then((v) => [n, v]))
        )
      );
    }
  </script>
  <script id="227" type="application/vnd.observable.javascript">
    viewof suite = testing.createSuite()
  </script>
  <script id="233" type="application/vnd.observable.javascript">
    suite.test("known variable found", async () => {
      testing
        .expect((await notebookSnapshot()).find((cell) => cell.name === "testing"))
        .toBeDefined();
    })
  </script>
  <script id="207" type="application/vnd.observable.javascript">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="210" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
