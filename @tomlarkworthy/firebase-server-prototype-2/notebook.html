<!doctype html>
<notebook theme="air">
  <title>Hackable Firebase Realtime Database Server Prototype #2</title>
  <script id="0" type="text/html">
    <h1 style="display: none;">Hackable Firebase Realtime Database Server Prototype #2<h1>
    ${gfx}
    <h2 style="font-size:42px">Prototype #2</h2>
    <h3>Focus areas: Firebase Client compatibility, Redis Persistence, GET/PUT/LISTEN/UNLISTEN</h3>
  </script>
  <script id="1327" type="application/vnd.observable.javascript">
    import { localStorageView } from "@tomlarkworthy/local-storage-view"
  </script>
  <script id="1333" type="application/vnd.observable.javascript">
    import { makeSticky } from "@mootari/sticky-positioning"
  </script>
  <script id="1336" type="application/vnd.observable.javascript">
    import { view } from "@tomlarkworthy/view"
  </script>
  <script id="1325" type="application/vnd.observable.javascript">
    viewof showOverlay = Inputs.bind(
      Inputs.toggle({ label: "show SDK logging?" }),
      localStorageView("logger")
    )
  </script>
  <script id="1323" type="application/vnd.observable.javascript">
    viewof rtdbLogs = Inputs.input([])
  </script>
  <script id="1363" type="application/vnd.observable.javascript" pinned="">
    log = (...args) => {
      viewof rtdbLogs.value =
        viewof rtdbLogs.value + "\n" + args.map((a) => JSON.stringify(a));
      viewof rtdbLogs.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="1321" type="application/vnd.observable.javascript">
    overlay = {
      if (!showOverlay) return;
      const sidebar = view`<div style="pointer-events: auto; width:40%; padding-top:3em;right:50px;background-color: white;">
        ${Inputs.bind(
          Inputs.textarea({
            width: "100%",
            rows: 10,
            disabled: true
          }),
          viewof rtdbLogs
        )}
        <div style="display:flex;">
          ${Inputs.button("clear logs", {
            reduce: () => (
              (viewof rtdbLogs.value = []),
              viewof rtdbLogs.dispatchEvent(new Event("input", { bubbles: true }))
            )
          })}
          ${viewof restartClient}
        </div>
      </div>`;
      const container = html`<div style="width:100%; height:100%; position: fixed;top:0px; pointer-events: none; ">${sidebar}`;
      const unstick = makeSticky(container, sidebar, { offset: 10 });
      invalidation.then(unstick);
      return container;
    }
  </script>
  <script id="1276" type="text/markdown">
    This notebook is part of a [collection](https://observablehq.com/collection/@tomlarkworthy/firebase) creating **an improved, open-source Firebase-compatible realtime database**. We will create an elastic architecture by leveraging new serverless technology. Serverless will enable us to horizontally scale the expensive parts of request handling, such as authorization rules and external API connectors, without impacting throughput. The goal is to offer end user programmability of the system, including using ordinary Javascript for authorization rules, and other goodies like custom federated data sources. **Lack of programmability is the main weakness of existing managed realtime database offerings**.

    To make something truly end user programmable, it is not enough to offer the source code under a permissive license. It needs innovate on documentation, innovate on workflow, offer social commenting features and be painless to stand up the customizations. This is why the prototype is hosted on Observable, it enables **literate programming**, in notebook comments, the fastest development feedback loop, one click forking -- all in the browser with zero setup. Our intellectual property is not locked in though, the code is an ES6 module that is also exported to Github [here](https://github.com/endpointservices/observable-notebooks/tree/main/%40tomlarkworthy/redis-backend-1).

    This notebook is a prototype of a Redis based persistence and message broker backend. It's a living prototype, the code is executed in *your* browser. Its part of my quest to create a **transparent cloud**. It contains unit tests that exercise the broad features. are run in your browser that connect to an external Redis server. You can watch the network tab executing the commands in your browser's development tools. If you fork this notebook, you can change the code, the commands will hit the same redis server unless you also change the [redisConfig](https://observablehq.com/@tomlarkworthy/redis-backend-1#redisConfig) cell below.
  </script>
  <script id="1281" type="text/markdown">
    ## At-least-once ordered delivery over unreliable communications

    Causal consistency has implications when transporting messages over an unreliable transport. During network partitions, messages need to be buffered until there is an opportunity to send them. When they are eventually sent, they need to be applied by the server in the same order the client originally raised them and *exactly once*, because of **causal consistency**.

    With ordered streaming transports like Websockets/TCP, it is enough for clients to buffer pending messages in a queue, and send them in order. In high performance applications, clients will not wait for a response, but rather pipeline requests one-after-another. If a connection is lost, any unacknowledged operations will be resent in order again ([source](https://github.com/firebase/firebase-js-sdk/blob/8bece487710aa6315c7dd98bcb086cd18fc9a943/packages/database/src/core/PersistentConnection.ts#L1069)). Pending operations are only removed from the queue after acknowledgement by the server ([source](https://github.com/firebase/firebase-js-sdk/blob/8bece487710aa6315c7dd98bcb086cd18fc9a943/packages/database/src/core/PersistentConnection.ts#L632)).

    For the unordered transport like HTTP, the client can send multiple database requests in a single HTTP request. Firebase clients only have one HTTP in flight at a time ([source](https://github.com/firebase/firebase-js-sdk/blob/8bece487710aa6315c7dd98bcb086cd18fc9a943/packages/database/src/realtime/BrowserPollConnection.ts#L660), [source](https://github.com/firebase/firebase-js-sdk/blob/8bece487710aa6315c7dd98bcb086cd18fc9a943/packages/database/src/realtime/BrowserPollConnection.ts#L676)), but operations are still logically pipelines and acknowledged in streams much similar to the websocket transport.



  </script>
  <script id="1283" type="text/markdown">

    ## Causal Consistency over Stateless Workers

    So now we get to the core technical challenge. Causal consistency implies preserving the ordering of an individual client's operations. However, if operations are sent to a horizontally scaled service, each operation might hit different worker, yet they *must* coordinate to **effect** the persisted shared database state one-after-another. 

    In Google's real Firebase Realtime database implementation all requests hit a single server so it can maintain a per client queue of pending operations, but by switching to an elastic architecture, the load balancer in front of the elastic compute works against us by scattering incoming operations across difference machines. Thus, the required pending operation queue needs to be moved to external shared state.
  </script>
  <script id="992" type="text/markdown">
    *Let's build a 3rd party wire compatible Firebase Database Server.*
  </script>
  <script id="866" type="application/vnd.observable.javascript">
    toc("h2,h3,h4,h5,h6")
  </script>
  <script id="674" type="text/markdown">
    ## Introduction
  </script>
  <script id="378" type="text/markdown">
    This is a prototype **Firebase wire compatible** Realtime Database Server. Vanilla Firebase web clients are able to connect and sync data with it. The server is written in [Observable](https://observablehq.com/) to simplify programmable customizability, you can one-click fork to host your own ([*really*](https://observablehq.com/@observablehq/fork-suggest-merge)).

    I think an end user programmable database server has much potential, for example, you could use ordinary code to authorize requests, you could even call out to external APIs, checking signatures *etc.* You could create synthetic data views to federated data sources *on-demand*, or fanout writes to additional storage engines. You can collocate the database near to users for incredibly low latency. 

    This is just a prototype though, and **not ready for production use**. However, it is a step in the right direction. The code layout has been optimized for observability, readability and developer ergonomics. Through use of [webcode.run](https://webcode.run) live coding, live traffic can be execution in the developers browser. You can attach the Chrome DevTools debugger and REPL traffic live. Furthermore, through the use of [flowQueue](/@tomlarkworthy/flow-queue)s, tunnelled requests leave their live execution trace in the variables of the notebook, so you can see the processing steps without special tooling. See the accompanying [Youtube video](https://observablehq.com/@tomlarkworthy/firebase-server-prototype-1) about some of the innovative development features.

    <iframe width="${Math.min(720, width)}" height="315" src="https://www.youtube.com/embed/P6zuvlcAKag" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </script>
  <script id="475" type="text/markdown">
    ### What this prototype does

    - Works with vanilla Firebase clients over public internet.
    - Key based Listen/Get/Put
    - Persist data to Redis
    - HTTP long poll transport

    ### What this prototype doesn't do

    - JSON interpolation
    - OrderBy/limit
    - onDisconnect semantics
    - websocket transport
    - REST API
    - Redis security
    - horizontal scalability
    - long poll big payload segment assembly
    - query indexes
    - server values

  </script>
  <script id="477" type="text/markdown">
    ## Background
    In a previous work we developed a tool for [reverse engineering the Firebase Realtime Database wire protocol](https://observablehq.com/@tomlarkworthy/rtdb-protocol), which included a very primitive Firebase Server Fake. Since then, we have created a [Redis driver](https://observablehq.com/@tomlarkworthy/redis) so notebooks can persist data to Redis directly, and so now we are in a position to put it all together. 

  </script>
  <script id="999" type="text/markdown">
    ## Follow along
    [twitter](https://twitter.com/tomlarkworthy) or 
    <iframe src="https://webcode.substack.com/embed" width="640" height="200px" style="border:1px solid #EEE; background:white;" frameborder="0" scrolling="no"></iframe>
  </script>
  <script id="900" type="text/markdown">
    ## Database URL
  </script>
  <script id="566" type="text/markdown">
    With a specially formatted database URL we can send a vanilla Firebase client to a 3rd party server implementation.
  </script>
  <script id="560" type="application/vnd.observable.javascript">
    databaseURL = `https://webcode.run?ns=${thisNotebooksNamespace}|${thisNotebooksSlug};server`
  </script>
  <script id="748" type="text/markdown">
    ## Live Tests

    The tests are meant to be read. They illustrate what features are working and furthermore, they are executed in **your** browser so you know it works because you have seen it work. Pop open DevTools and take a look when the clients are reset.

    In this early stage the tests are a bit flakey and you might need to restart the clients, refresh the page, and try a few times until everything is warmed up 😳.
  </script>
  <script id="100" type="application/vnd.observable.javascript">
    clientConfig = ({
      firebaseServer: {
        url: databaseURL
      }
    })
  </script>
  <script id="342" type="text/markdown">
    ### Firebase Test Clients
  </script>
  <script id="502" type="application/vnd.observable.javascript">
    import {
      viewof restartClient,
      rtdb,
      rootA,
      rootB
    } with { clientConfig as config } from "@tomlarkworthy/firebase-server-test-clients"
  </script>
  <script id="1342" type="application/vnd.observable.javascript">
    referenceDatabase = {
      rtdb.enableLogging((log) => {
        viewof rtdbLogs.value = viewof rtdbLogs.value + "\n" + log;
        viewof rtdbLogs.dispatchEvent(new Event("input", { bubbles: true }));
      });

    }
  </script>
  <script id="882" type="text/markdown">
    ### Test Results
  </script>
  <script id="114" type="application/vnd.observable.javascript">
    viewof suite = (server,
    flowQueue,
    createSuite({
      name: null
    }))
  </script>
  <script id="878" type="text/markdown">
    ### Restart Test Clients & Tests
  </script>
  <script id="578" type="application/vnd.observable.javascript">
    viewof restartClient
  </script>
  <script id="914" type="text/markdown">
    ### Smoke Tests
  </script>
  <script id="920" type="text/markdown">
    #### Read your write
  </script>
  <script id="124" type="application/vnd.observable.javascript" pinned="">
    readYourWriteTest = suite.test("Read your own write - String", async () => {
      const payload = randomString();
      const location = rtdb.child(rootA, "collection/readyourownwrite");
      await rtdb.set(location, payload);
      const response = (await rtdb.get(location)).val();
      expect(response).toEqual(payload);
    })
  </script>
  <script id="919" type="text/markdown">
    #### Read other's write
  </script>
  <script id="174" type="application/vnd.observable.javascript" pinned="">
    readTheirWriteTest = suite.test("Read their write - String", async () => {
      const payload = randomString();
      const locationA = rtdb.child(rootA, "collection/readtheirwrite");
      const locationB = rtdb.child(rootB, "collection/readtheirwrite");
      await rtdb.set(locationA, payload);
      const response = await rtdb.get(locationB);
      expect(response.val()).toEqual(payload);
    })
  </script>
  <script id="931" type="text/markdown">
    #### Listen notified of other's write
  </script>
  <script id="535" type="application/vnd.observable.javascript" pinned="">
    listenNotifiedOfWrite = suite.test(
      "onValue is notified of other's write",
      async (done) => {
        const payload = randomString();
        const locationA = rtdb.child(rootA, "collection/subscribetheirwrite");
        const locationB = rtdb.child(rootB, "collection/subscribetheirwrite");
        rtdb.onValue(locationB, (snap) => {
          const val = snap.val();
          log(val);
          if (_.isEqual(val, payload)) {
            done();
          }
        });

        await rtdb.set(locationA, payload);
      }
    )
  </script>
  <script id="510" type="text/markdown">
    ## Custom Firebase Realtime Server
  </script>
  <script id="385" type="text/markdown">
    ### Storage Engine: Redis

    Redis the the storage engine for this prototype. We are using a custom [redis-web](https://observablehq.com/@tomlarkworthy/redis) client.
  </script>
  <script id="1005" type="application/vnd.observable.javascript" pinned="">
    import {
      enqueue_operation,
      enqueue_notify,
      process_operation,
      next_notify,
      ack_notify,
      createClient,
      createLongpollSession,
      retrieveLongpollSession,
      incrementLongpollResponseNum,
      operations
    } from "@tomlarkworthy/redis-backend-1"
  </script>
  <script id="1272" type="text/markdown">
    ## Shared redis is used for global operations such as process_operation
  </script>
  <script id="1157" type="application/vnd.observable.javascript" pinned="">
    operations
  </script>
  <script id="572" type="application/vnd.observable.javascript">
    redisConfig = ({
      socket: {
        host: "redis.webcode.run",
        port: 443,
        tls: true
      }
    })
  </script>
  <script id="941" type="text/markdown">
    ### Long Poll Endpoint

    Firebase clients make long lived connection to this endpoint
  </script>
  <script id="23" type="application/vnd.observable.javascript" pinned="">
    server = endpoint("server", async (req, res) => {
      try {
        log("incoming HTTP");
        viewof incomingLongpollRequest.send({ req, res }); // handle in to poll pipeline (unfold across Dataflow)
      } catch (err) {
        res.status(500).send(err.message);
      }
    })
  </script>
  <script id="359" type="text/markdown">
    ### Long Poll Request Pipeline

    If you are live tunnelling the server endpoint, these cells will evaluate in response to production traffic (and will handle production traffic).
  </script>
  <script id="365" type="application/vnd.observable.javascript" pinned="">
    viewof incomingLongpollRequest = flowQueue({
      name: "incomingLongpollRequest",
      timeout_ms: 20000
    })
  </script>
  <script id="372" type="application/vnd.observable.javascript" pinned="">
    incomingLongpollRequest
  </script>
  <script id="452" type="application/vnd.observable.javascript">
    newSessionResponse = (callbackId, session, replyId) => `
      function pLPCommand(c, a1, a2, a3, a4) {
      parent.window["pLPCommand${callbackId}"] && parent.window["pLPCommand${callbackId}"](c, a1, a2, a3, a4);
      }
      function pRTLPCB(pN, data) {
      parent.window["pRTLPCB${callbackId}"] && parent.window["pRTLPCB${callbackId}"](pN, data);
      }
      pLPCommand('start','${session.client.client_id}','${session.password}')
      pRTLPCB(${replyId},${JSON.stringify([
      {
        t: "c",
        d: {
          t: "h",
          d: {
            ts: Date.now(),
            v: "5",
            h: "webcode.run",
            s: session.id
          }
        }
      }
    ])})`
  </script>
  <script id="460" type="application/vnd.observable.javascript">
    disconnectFrame = ({ id, pw } = {}) => `<html><body><script>
      function EnvSendPing(destURL) {
      try{
      var xhr=new XMLHttpRequest();
      xhr.open("GET", destURL, false);
      xhr.send(null);
      } catch (e) { }
      }
      function EnvDisconnect() {
      EnvSendPing("/.lp?disconn=t&id=${id}&pw=${pw}");
      }
      if(window.addEventListener)
      window.addEventListener('unload',EnvDisconnect,false);
      else if(window.attachEvent)
      window.attachEvent('onunload',EnvDisconnect);
      <\/script></body></html>`
  </script>
  <script id="369" type="application/vnd.observable.javascript" pinned="">
    incomingLongpollRequestAction = {
      log("started incomingLongpollRequestAction");
      const req = incomingLongpollRequest.req;
      const res = incomingLongpollRequest.res;

      const callbackId = req.query.cb;
      if (req.query.start) {
        // New session initialized
        const cid = Math.random().toString(16).substring(3);
        const client = await createClient(redisConfig, cid);
        log("New long poll session");
        const session = await createLongpollSession(client, {
          password: Math.random().toString(16).substring(3)
        });

        log("Creating new long poll session", session);

        res.header("content-type", "application/javascript");
        res.send(
          newSessionResponse(
            callbackId,
            session,
            await incrementLongpollResponseNum(client)
          )
        );
        viewof incomingLongpollRequest.respond("new connection");
      } else if (req.query.dframe) {
        res.header("content-type", "text/html");
        res.send(
          disconnectFrame({
            id: req.query.id,
            pw: req.query.pw
          })
        );
        viewof incomingLongpollRequest.respond("disconnect frame");
      } else {
        const client = await createClient(redisConfig, req.query.id);
        const session = await retrieveLongpollSession(client);
        log("Long poll existing session", session);
        if (!session) {
          return viewof incomingLongpollRequest.reject(
            new Error("Unrecognized connection id for " + req.query.id)
          );
        }

        res.header("content-type", "application/javascript");
        // We look for proof that a future longpoll came in, by stamping actions with a timestamp
        // If a future one comes in this one is no longer necissary and should be closed.
        const longpoll = Date.now();
        var commandIndex = 0;
        while (req.query[`d${commandIndex}`]) {
          const data = JSON.parse(
            atob(req.query[`d${commandIndex}`].replaceAll(".", "="))
          );
          commandIndex++;
          data.d.longpoll = longpoll;
          log("Incoming request", data);
          try {
            const response = await viewof incomingRequest.send({
              session,
              request: data
            });
          } catch (err) {
            console.error(err);
          }
        }

        new Promise(async (_) => {
          log("run actions");
          while ("NOOP" !== (await process_operation(session.client))) {}
        });

        log("polling for response");
        viewof incomingLongpollRequest.respond("streaming"); // let other stuff happen

        while (true) {
          const fromRedis = await next_notify(session.client);
          if (fromRedis) {
            debugger;
            // TODO this return path should be its own flow step
            const [id, reply] = fromRedis;

            /*
            if (Number.parseInt(reply.longpoll) > longpoll) {
              log("seen newer longpoll");
              res.send(`pRTLPCB(${await incrementLongpollResponseNum(client)},[])`);
              break;
            }*/

            // TODO: correctness: this should not be done until the next long poll comes in
            // that the point we know the previous command was processed
            log("ack reply", id, reply);
            ack_notify(session.client, id);

            res.send(
              `pRTLPCB(${await incrementLongpollResponseNum(
                client
              )},${JSON.stringify([
                {
                  t: "d",
                  d: {
                    ...(reply.request_id && {
                      r: Number.parseInt(reply.request_id)
                    }),
                    ...(reply.action === "DATA" && { a: "d" }),
                    b: {
                      ...(reply.status && { s: reply.status }),
                      d: JSON.parse(reply.data || '""'),
                      ...(reply.key && {
                        p: reply.key.replace("firebase-server-prototype-2", "")
                      })
                    }
                  }
                }
              ])});`
            );
            break;
          } else {
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }
        }
        log("Terminating");
      }
    }
  </script>
  <script id="355" type="text/markdown">
    ### Data Request Pipeline
  </script>
  <script id="186" type="application/vnd.observable.javascript" pinned="">
    viewof incomingRequest = flowQueue({
      name: "incomingRequest",
      timeout_ms: 10000
    })
  </script>
  <script id="219" type="application/vnd.observable.javascript">
    incomingRequest
  </script>
  <script id="224" type="application/vnd.observable.javascript" pinned="">
    requestRouter = {
      log("running requestRouter", incomingRequest);
      const client = incomingRequest.session.client;
      const session = incomingRequest.session;
      const request = incomingRequest.request;
      const commandHandler = {
        s: viewof incomingStats,
        p: viewof incomingPut,
        q: viewof incomingQuery,
        g: viewof incomingGet
      }[request.d.a];

      if (!commandHandler) {
        return viewof incomingRequest.reject(
          new Error("Unrecognised server action " + request.d.a)
        );
      }

      return commandHandler
        .send({
          session,
          command: request.d
        })
        .then((handlerResponse) => {
          log("requestRouter done", handlerResponse);
          viewof incomingRequest.respond(handlerResponse);
          return handlerResponse;
        })
        .catch(viewof incomingRequest.reject);
    }
  </script>
  <script id="310" type="text/markdown">
    #### STATS
  </script>
  <script id="318" type="application/vnd.observable.javascript" pinned="">
    viewof incomingStats = flowQueue({
      name: "incomingStats",
      timeout_ms: 5000
    })
  </script>
  <script id="320" type="application/vnd.observable.javascript" pinned="">
    incomingStats
  </script>
  <script id="322" type="application/vnd.observable.javascript" pinned="">
    incomingStatsAction = {
      log("incomingStatsAction", incomingStats);
      const client = incomingStats.session.client;
      const request_id = incomingStats.command.r;
      try {
        // Short curcuit straight to the reply queue for this client
        const response = enqueue_notify(client, client.client_id, {
          request_id,
          status: "ok"
        });
        viewof incomingStats.respond(response);
        return response;
      } catch (err) {
        console.error(err, incomingStats);
        viewof incomingStats.reject(err);
        return err;
      }
    }
  </script>
  <script id="235" type="text/markdown">
    #### PUT
  </script>
  <script id="230" type="application/vnd.observable.javascript" pinned="">
    viewof incomingPut = flowQueue({
      name: "incomingPut",
      timeout_ms: 5000
    })
  </script>
  <script id="232" type="application/vnd.observable.javascript" pinned="">
    incomingPut
  </script>
  <script id="242" type="application/vnd.observable.javascript" pinned="">
    incomingPutAction = {
      const client = incomingPut.session.client;
      const path = incomingPut.command.b.p;
      const data = incomingPut.command.b.d;
      const request_id = incomingPut.command.r;
      try {
        const response = enqueue_operation(client, {
          request_id,
          action: "PUT",
          key: "firebase-server-prototype-2" + path,
          value: JSON.stringify(data)
        });
        viewof incomingPut.respond(response);
        return response;
      } catch (err) {
        viewof incomingPut.reject(err);
        return err;
      }
    }
  </script>
  <script id="269" type="text/markdown">
    #### GET
  </script>
  <script id="273" type="application/vnd.observable.javascript" pinned="">
    viewof incomingGet = flowQueue({
      name: "incomingGet",
      timeout_ms: 5000
    })
  </script>
  <script id="728" type="application/vnd.observable.javascript" pinned="">
    incomingGet
  </script>
  <script id="280" type="application/vnd.observable.javascript" pinned="">
    incomingGetAction = {
      const client = incomingGet.session.client;
      const path = incomingGet.command.b.p;
      const query = incomingGet.command.b.q;
      const request_id = incomingGet.command.r;

      // TODO permissions check
      // { s: "permission_denied", d: "Permission denied" };
      try {
        const response = enqueue_operation(client, {
          request_id,
          action: "GET",
          key: "firebase-server-prototype-2" + path
        });
        viewof incomingGet.respond(response);
        return response;
      } catch (err) {
        viewof incomingGet.reject(err);
        return err;
      }
    }
  </script>
  <script id="522" type="text/markdown">
    #### QUERY
  </script>
  <script id="712" type="application/vnd.observable.javascript">
    pathToListeners = ({})
  </script>
  <script id="531" type="application/vnd.observable.javascript">
    viewof incomingQuery = flowQueue({
      name: "incomingQuery",
      timeout_ms: 5000
    })
  </script>
  <script id="529" type="application/vnd.observable.javascript">
    incomingQuery
  </script>
  <script id="527" type="application/vnd.observable.javascript" pinned="">
    incomingQueryAction = {
      // Actions: Listen/Query
      const client = incomingQuery.session.client;
      const command = incomingQuery.command;
      const request_id = incomingQuery.command.r;
      const path = incomingQuery.command.b.p;

      try {
        const response = enqueue_operation(client, {
          request_id,
          action: "LISTEN",
          key: "firebase-server-prototype-2" + path
        });
        viewof incomingQuery.respond(response);
        return response;
      } catch (err) {
        viewof incomingQuery.reject(err);
        return err;
      }
    }
  </script>
  <script id="439" type="text/markdown">
    ### Utils
  </script>
  <script id="134" type="application/vnd.observable.javascript">
    randomString = () => Math.random().toString(16).substring(3)
  </script>
  <script id="546" type="application/vnd.observable.javascript">
    thisNotebooksNamespace = {
      if (thisNotebooksSlug === HEALTH_CHECK_FALLBACK_SLUG)
        return HEALTH_CHECK_FALLBACK_NAMESPACE;
      else return /@([^/]*)\//.exec(html`<a href="?">`.href)[1];
    }
  </script>
  <script id="551" type="application/vnd.observable.javascript">
    thisNotebooksSlug = {
      const thisSlug = /\/([^/]*)\?/.exec(html`<a href="?">`.href)[1];
      if (thisSlug === "healthcheck") return HEALTH_CHECK_FALLBACK_SLUG;
      else return thisSlug;
    }
  </script>
  <script id="824" type="text/markdown">
    ### Remote notebook state

    We expose an endpoint for reading the remote notebooks state, which can be useful for debugging remote errors.
  </script>
  <script id="813" type="application/vnd.observable.javascript">
    import { notebookSnapshot } from "@tomlarkworthy/notebook-snapshot"
  </script>
  <script id="811" type="application/vnd.observable.javascript">
    trackingVariable_e3366d24de62 = true
  </script>
  <script id="809" type="application/vnd.observable.javascript">
    endpoint("variables", async (req, res) => {
      res.json(
        (await notebookSnapshot("trackingVariable_e3366d24de62")).map(
          (variable) => ({
            state: variable.state,
            name: variable.name,
            // Note these cells might contain personal information, so we only allow errors values to leave the environment
            ...(variable.state === "rejected" && {})
          })
        )
      );
    })
  </script>
  <script id="843" type="text/markdown">
    ### [Health check](https://observablehq.com/@endpointservices/healthcheck)

    The healthcheck is actively monitored and includes the smoke tests.

    | Region      | URL |
    | ----------- | ----------- |
    | us-central1      | https://webcode.run/regions/us-central1/observablehq.com/@endpointservices/healthcheck?target=%40tomlarkworthy%2Ffirebase-server-prototype-1&wait=50      |
    | europe-west4   | https://webcode.run/regions/europe-west4/observablehq.com/@endpointservices/healthcheck?target=%40tomlarkworthy%2Ffirebase-server-prototype-1&wait=50        |
  </script>
  <script id="954" type="text/markdown">
    When running inside the healthcheck notebook, the slug is detected incorrectly as "healthcheck" which means the clients connect to the wrong place. So we have manual fix.
  </script>
  <script id="949" type="application/vnd.observable.javascript">
    HEALTH_CHECK_FALLBACK_SLUG = "firebase-server-prototype-1"
  </script>
  <script id="961" type="application/vnd.observable.javascript">
    HEALTH_CHECK_FALLBACK_NAMESPACE = "tomlarkworthy"
  </script>
  <script id="447" type="text/markdown">
    ### Notebook Error Monitoring, Analytics and Backups
  </script>
  <script id="587" type="application/vnd.observable.javascript">
    footer
  </script>
  <script id="443" type="text/markdown">
    ### Dependancies
  </script>
  <script id="654" type="application/vnd.observable.javascript">
    import { gfx } from "@tomlarkworthy/hackable-realtime-database-title-graphic"
  </script>
  <script id="26" type="application/vnd.observable.javascript">
    import { endpoint } from "@endpointservices/webcode"
  </script>
  <script id="82" type="application/vnd.observable.javascript">
    import { expect, createSuite } from "@tomlarkworthy/testing"
  </script>
  <script id="156" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="212" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer-with-backups"
  </script>
  <script id="861" type="application/vnd.observable.javascript">
    import { toc } from "@bryangingechen/toc"
  </script>
</notebook>
