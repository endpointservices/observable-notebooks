<!doctype html>
<notebook theme="air">
  <title>Roboco-op: Observable Runtime Decompiler</title>
  <script id="0" type="text/markdown">
    # Roboco-op: Observable Runtime Decompiler
  </script>
  <script id="35" type="application/vnd.observable.javascript" pinned="">
    cells
  </script>
  <script id="37" type="application/vnd.observable.javascript" pinned="">
    viewof context_viz
  </script>
  <script id="28" type="text/markdown">
    ### find_prompt: 
  </script>
  <script id="108" type="application/vnd.observable.javascript" pinned="">
    find_prompt = ({
      prompt:
        'write a cell called find_prompt. Using acorn JS parser, search some JS code for the existence of an Object literal containing fields: "prompt", "time", "comment" and return that object.',
      time: 1699380798090,
      comment:
        "This function search for the existence of an object literal containing fields: 'prompt', 'time', 'comment' in an input JavaScript code using the acorn JS parser. It returns the found object."
    } &&
      function findPrompt(code) {
        let ast;
        let fixed_code;
        let ast_type;
        try {
          fixed_code = "async () => " + code;
          ast = acorn.parse(fixed_code, { ecmaVersion: 2020 });
          ast_type = "block";
        } catch (e) {
          try {
            fixed_code = "() => (" + code + ")";
            ast = acorn.parse(fixed_code, { ecmaVersion: 2020 });
            ast_type = "expr";
          } catch (e) {}
        }

        function search(node, parent) {
          if (node?.type === "ObjectExpression") {
            const keys = node.properties.map((p) => p.key?.name || p.key?.value);
            if (
              keys.includes("prompt") &&
              keys.includes("time") &&
              keys.includes("comment")
            ) {
              const info = Object.fromEntries(
                node.properties.map((p) => [
                  p.key.name || p.key.value,
                  p.value.value
                ])
              );

              let trimmed;
              if (parent?.operator == "&&" && parent.left == node) {
                trimmed =
                  fixed_code.slice(0, parent.start) +
                  fixed_code.slice(parent.right.start, parent.right.end) +
                  fixed_code.slice(parent.end);
              } else if (parent.type == "ExpressionStatement") {
                trimmed =
                  fixed_code.slice(0, parent.start) + fixed_code.slice(parent.end);
              } else {
                trimmed =
                  fixed_code.slice(0, node.start) +
                  "{}" +
                  fixed_code.slice(node.end);
              }
              return [
                info,
                ast_type == "expr"
                  ? trimmed.substring(7, trimmed.length - 1).trim()
                  : trimmed.substring(11).trim()
              ];
            }
          }
          for (const key in node) {
            if (node[key] && typeof node[key] === "object") {
              const found = search(node[key], node);
              if (found) return found;
            }
          }
        }

        return search(ast, null) || [undefined, code];
      })
  </script>
  <script id="84" type="application/vnd.observable.javascript" pinned="">
    viewof find_prompt_tests = createSuite("find_prompt")
  </script>
  <script id="225" type="application/vnd.observable.javascript">
    example_source = `async function(crtWarpAdjustment,deps)
    {
      ({
        prompt:
          "We need to use a displacement map, which requires an image. So lets generate an image based on the crtWarpAdjustment settings that does the barrel and trapazoid distortion and saves it as an image blob",
        time: 1701202409079,
        comment:
          "Generate a CRT warp image based on barrel and trapezoid distortion settings"
      });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const width = (canvas.width = 200);
      const height = (canvas.height = 100);

      // Generate the barrel warp as a radial gradient
      const gradient = ctx.createRadialGradient(
        width / 2,
        height / 2,
        0,
        width / 2,
        height / 2,
        Math.max(width, height) / 2
      );
      gradient.addColorStop(0, \`rgba(0,0,0,0)\`);
      gradient.addColorStop(1, \`rgba(0,0,0,\${crtWarpAdjustment.barrel_warp})\`);

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      // Apply the trapezoid warp by scaling the canvas
      ctx.setTransform(1, 0, crtWarpAdjustment.trapezoid_warp, 1, 0, 0);
      ctx.drawImage(canvas, 0, 0);

      // Convert canvas to an image blob
      const warp = await new Promise((resolve) => {
        canvas.toBlob((blob) => {
          resolve(URL.createObjectURL(blob));
        });
      });
      deps.register("crtWarpDisplacementMap", warp, 1);
      return warp;
    }`
  </script>
  <script id="237" type="application/vnd.observable.javascript" pinned="">
    example_code = observableDefinitionToCode(example_source)
  </script>
  <script id="241" type="application/vnd.observable.javascript" pinned="">
    example_prompt = {
      debugger;
      return find_prompt(example_code);
    }
  </script>
  <script id="87" type="application/vnd.observable.javascript" pinned="">
    find_prompt_tests.test("simple expressions (1)", async () => {
      const source = `function(md){return(({"prompt":"p","time":1,"comment":"c"}) && md\`\`)}`;
      expect(find_prompt(observableDefinitionToCode(source))).toEqual([
        { prompt: "p", time: 1, comment: "c" },
        "md``"
      ]);
    })
  </script>
  <script id="134" type="application/vnd.observable.javascript" pinned="">
    find_prompt_tests.test("simple expressions (1)", async () => {
      const source = `function(md){return({"prompt":"p","time":1,"comment":"c"} && md\`\`)}`;
      expect(find_prompt(observableDefinitionToCode(source))).toEqual([
        { prompt: "p", time: 1, comment: "c" },
        "md``"
      ]);
    })
  </script>
  <script id="139" type="application/vnd.observable.javascript" pinned="">
    find_prompt_tests.test("simple expression (1)", async () => {
      const source = `{
      prompt: "p",
      time: 1,
      comment: "c"
    } &&
      md\` \``;
      expect(find_prompt(source)).toEqual([
        { prompt: "p", time: 1, comment: "c" },
        "md` `"
      ]);
    })
  </script>
  <script id="131" type="application/vnd.observable.javascript" pinned="">
    find_prompt_tests.test("simple block (1)", async () => {
      const source = `({"prompt":"p","time":1,"comment":"c"}) && md\`\``;
      expect(find_prompt(source)).toEqual([
        { prompt: "p", time: 1, comment: "c" },
        "md``"
      ]);
    })
  </script>
  <script id="201" type="application/vnd.observable.javascript" pinned="">
    find_prompt_tests.test("simple block", async () => {
      const source = `function(width){
      ({ prompt: "p", time: 1, comment: "c" })
      return width + 1;
    }`;
      const code = observableDefinitionToCode(source);
      expect(find_prompt(code)).toEqual([
        { prompt: "p", time: 1, comment: "c" },
        `{

      return width + 1;
    }`
      ]);
    })
  </script>
  <script id="245" type="application/vnd.observable.javascript" pinned="">
    find_prompt_tests.test("await block", async () => {
      const source = `async function(width){
      ({ prompt: "p", time: 1, comment: "c" })
      return await width + 1;
    }`;
      const code = observableDefinitionToCode(source);
      debugger;
      expect(find_prompt(code)).toEqual([
        { prompt: "p", time: 1, comment: "c" },
        `{

      return await width + 1;
    }`
      ]);
    })
  </script>
  <script id="46" type="application/vnd.observable.javascript" pinned="">
    update_context
  </script>
  <script id="145" type="text/markdown">
    ## observableDefinitionToCode
  </script>
  <script id="147" type="application/vnd.observable.javascript" pinned="">
    observableDefinitionToCode = (source) => {
      try {
        const defn = "(" + source + ")";
        const ast = acorn.parse(defn);
        const functionExpression = ast.body[0].expression;
        if (functionExpression.type !== "FunctionExpression")
          throw functionExpression;
        const block = defn.slice(
          functionExpression.body.start,
          functionExpression.body.end
        );

        const exprMatch = /{return\(([\s\S]*)\)}$/.exec(block);
        if (exprMatch) return exprMatch[1].trim();
        else return block;
      } catch (e) {
        return undefined;
      }
    }
  </script>
  <script id="151" type="application/vnd.observable.javascript" pinned="">
    viewof observableDefinitionToCode_tests = createSuite("find_prompt")
  </script>
  <script id="162" type="application/vnd.observable.javascript" pinned="">
    observableDefinitionToCode_tests.test(
      "observableDefinitionToCode expr (1)",
      async () => {
        const source = `function(md){return({"prompt":"p","time":1,"comment":"c"} && md\`\`)}`;
        expect(observableDefinitionToCode(source)).toEqual(
          `{"prompt":"p","time":1,"comment":"c"} && md\`\``
        );
      }
    )
  </script>
  <script id="178" type="application/vnd.observable.javascript" pinned="">
    observableDefinitionToCode_tests.test(
      "observableDefinitionToCode expr (2)",
      async () => {
        const source = `function(md){return(
    {
      prompt: "p",
      time: 1,
      comment: "c"
    } &&
      md\` \`
    )}`;
        expect(observableDefinitionToCode(source)).toEqual(`{
      prompt: "p",
      time: 1,
      comment: "c"
    } &&
      md\` \``);
      }
    )
  </script>
  <script id="189" type="application/vnd.observable.javascript" pinned="">
    observableDefinitionToCode_tests.test(
      "observableDefinitionToCode block (1)",
      async () => {
        const source = `function(width){
      return width + 1;
    }`;
        expect(observableDefinitionToCode(source)).toEqual(`{
      return width + 1;
    }`);
      }
    )
  </script>
  <script id="82" type="application/vnd.observable.javascript" pinned="">
    import { createSuite, expect } from "@tomlarkworthy/testing"
  </script>
  <script id="5" type="application/vnd.observable.javascript" pinned="">
    import {
      viewof context_viz,
      ask,
      excludes,
      cells,
      update_context,
      on_prompt,
      api_call_response,
      context,
      prompt,
      suggestion,
      settings,
      OPENAI_API_KEY,
      api_endpoint,
      feedback_prompt,
      feedback_cells_selector,
      /* observableDefinitionToCode,*/
      /*find_prompt,*/
      acorn
    } with {
      find_prompt as find_prompt,
      observableDefinitionToCode as observableDefinitionToCode
    } from "@tomlarkworthy/robocoop"
  </script>
</notebook>
