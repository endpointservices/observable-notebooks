<!doctype html>
<notebook theme="air">
  <title>Building a SMART FARM EP05: Lambda Architecture</title>
  <script id="0" type="text/markdown">
    # Building a SMART FARM EP05: Lambda Architecture

  </script>
  <script id="365" type="text/markdown">
    So far our SMART FARM has data storage provided by Firebase ([EP01](https://observablehq.com/@tomlarkworthy/livecoding-2022-06-07)), and it is actively ingesting data from real farms in Colombia using Blues Wireless cellular connection ([EP02](https://observablehq.com/@tomlarkworthy/blueswireless-2022-06-14)). We are able to send dashboards to field workers on-demand using WhatsApp ([EP03](https://observablehq.com/@tomlarkworthy/dashboards-over-whatsapp)). Last time in ([EP04](https://observablehq.com/@tomlarkworthy/firebase-to-duckdb?collection=@tomlarkworthy/livecoding)) we calculated the *Growing Degree Days* (GDD) using DuckDB SQL but it could only look back a few days before exhausting memory constraints.

    In this episode, we take our prototyped GDD calculations and make them work in realtime over large time ranges by precomputation. We functionify our previous dataflow based calculation logic with a flowQueue. With a function frontend, we can automate precomputing daily totals of GDD for all our sensors.

    With GDD precomputed over our reading history, we can utilize the lambda architecture to combine batch data with realtime data. So now we can view GDD over a month time range *and still have the latest realtime data included*. Somewhat amazingly, we have achieved this entirely within a web browser
  </script>
  <script id="1092" type="text/markdown">
    ## Full episode
  </script>
  <script id="343" type="text/html">
    <iframe width="${Math.min(width, 640)}" height="350" src="https://www.youtube.com/embed/AqzgVQ2S14U?start=${videoStartAt}&autoplay=${videoStartAt > 10 ? 1 : 0}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen> </iframe>
  </script>
  <script id="643" type="application/vnd.observable.javascript">
    viewof videoStartAt = Inputs.select(
      new Map([
        ["recap", 1],
        ["what analytics are useful to growers?", 45],
        ["Tarot of the day", 180],
        ["Review of Growing Degrees Calculation in DuckDB SQL (EP04)", 290],
        ["functionification", 1270],
        ["lambda architecture", 2205]
      ]),
      {
        label: "Jump to a location of interest"
      }
    )
  </script>
  <script id="1933" type="text/markdown">
    ### Realtime data over a large timeranges

    This plot is a realtime view of the Growing Degree Days of some of our sensors. It would not be possible to draw this quickly if we summed all the sensor data over the time range. Instead, we precompute some daily aggregates and combine the pre-aggregated data to the latest streamed realtime data to be able to query a large timerange yet still have the latest data represented. Combining pre-aggregated 'batch' data with realtime 'streaming' data is known as a [lambda architectue](https://en.wikipedia.org/wiki/Lambda_architecture).

  </script>
  <script id="1833" type="application/vnd.observable.javascript">
    Plot.plot({
      color: {
        legend: true
      },
      y: {
        domain: [0, 24]
      },
      x: {
        type: "time"
      },
      marks: [
        Plot.ruleY([0]),
        Plot.lineY(historical.concat(latestData), {
          x: "timestamp",
          y: "gdd",
          stroke: "device"
        })
      ]
    })
  </script>
  <script id="1958" type="text/markdown">
    ### Historical GDD

    Our historical data is pulled pre-aggregated from "aggregations/GDD". We precompute these aggregates later on in the notebook. 
  </script>
  <script id="1813" type="application/vnd.observable.javascript" pinned="">
    historyRaw = new Promise((resolve) =>
      db.ref("aggregations/GDD").once("value", (snap) => resolve(snap.val()))
    )
  </script>
  <script id="1822" type="application/vnd.observable.javascript" pinned="">
    historical = {
      const data = [];
      Object.entries(historyRaw).map(([device, readings]) => [
        device,
        Object.entries(readings).forEach(([timestamp, gdd]) => {
          if (typeof gdd === "number")
            data.push({
              device,
              timestamp: new Date(timestamp * 1000),
              gdd
            });
        })
      ]);
      return data;
    }
  </script>
  <script id="1963" type="text/markdown">
    ### Realtime data

    Our latest data is streamed from `history/sensors/dev:864475046458393`, we are only getting data for one sensor for this simple demo.
  </script>
  <script id="1847" type="application/vnd.observable.javascript" pinned="">
    todaySeconds = new Date(new Date().toISOString().substring(0, 10)).getTime() /
      1000
  </script>
  <script id="1879" type="application/vnd.observable.javascript" pinned="">
    latestDataRaw = Generators.observe((notify) => {
      reset;
      const dataset = (this && this.dataset) || [];
      const dataHandler = (snapshot) => {
        debugger;
        const data = snapshot.val();
        console.log(data);
        if (data.body.temperature) {
          dataset.push(data);
          notify({
            dataset,
            row: data
          });
        }
      };
      const ref = db
        .ref(`history/sensors/dev:864475046458393`)
        .orderByKey()
        .startAt(todaySeconds + "");

      ref.on("child_added", dataHandler);

      invalidation.then(() => {
        dataset.length = 0;
        ref.off("child_added", dataHandler);
      });
    })
  </script>
  <script id="1985" type="text/markdown">
    We need to compute the GDD from the sensor samples. Ideally, we would reuse the SQL query used in the historical aggregation, as that was adaptive to missing data. But for simplicity we just assume each sample is 15 minutes and compute it with code. In production I would spend a little bit more time here to properly reuse the SQL query so any changes are reflected on both sides of the lambda architecture.
  </script>
  <script id="1903" type="application/vnd.observable.javascript" pinned="">
    latestDataGdd = latestDataRaw.dataset
      .map((entry) => ({
        device: entry.device,
        timestamp: new Date(entry.when * 1000),
        temperature: entry.body.temperature
      }))
      .reduce(
        (gdd, row) =>
          gdd + (row.temperature > 5 && row.temperature < 25 ? 0.25 : 0),
        0
      )
  </script>
  <script id="1916" type="application/vnd.observable.javascript" pinned="">
    latestData = [
      {
        device: "dev:864475046458393",
        timestamp: new Date(todaySeconds * 1000),
        gdd: latestDataGdd
      }
    ]
  </script>
  <script id="85" type="text/markdown">
    ## (EP01) Firebase Database
    Setup in [EP01](https://observablehq.com/@tomlarkworthy/livecoding-2022-06-07)
  </script>
  <script id="61" type="application/vnd.observable.javascript">
    import {
      firebase,
      viewof user,
      listen
    } with { firebaseConfig as firebaseConfig } from "@tomlarkworthy/firebase"
  </script>
  <script id="57" type="application/vnd.observable.javascript">
    firebaseConfig = ({
      apiKey: "AIzaSyA9OQ--0Sn8Gm6C1B4M-SbnxRMtKHgnHzs",
      authDomain: "agropatterns-iot.firebaseapp.com",
      databaseURL: "https://agropatterns-iot-default-rtdb.firebaseio.com",
      projectId: "agropatterns-iot",
      appId: "1:650132950601:web:115b1ba65750d2b0aaf998",
      uiConfig: {
        // https://github.com/firebase/firebaseui-web#configuration
        signInOptions: ["anonymous"]
      }
    })
  </script>
  <script id="87" type="application/vnd.observable.javascript">
    db = firebase.database()
  </script>
  <script id="176" type="text/markdown">
    ## (EP02) Live Temperature Dashboard

    Setup in [EP02](https://observablehq.com/@tomlarkworthy/blueswireless-2022-06-14). This is 24 hour window of latest sensor readings. The green band represents the growth zone for the plant. Most sensors are sending data every 15 minutes which will be reflected in the dashboard automatically.
  </script>
  <script id="140" type="application/vnd.observable.javascript">
    viewof querySensorName = Inputs.select(Object.keys(latest), {
      label: "Choose sensor to chart",
      value: "dev:864475046458393"
    })
  </script>
  <script id="164" type="application/vnd.observable.javascript">
    dashboard = Plot.plot({
      x: { type: "time" },
      y: { domain: [0, 40], label: "Temperature" },
      color: {
        domain: [0, 40],
        scheme: "turbo"
      },
      marks: [
        Plot.rect([{}], { fill: "#F4BFA6", y1: 25, y2: 40 }),
        Plot.rect([{}], { fill: "#A7D3A6", y1: 5, y2: 25 }),
        Plot.rect([{}], { fill: "#A4B5E3", y1: 0, y2: 5 }),
        Plot.ruleY([20], { stroke: "#0003", strokeDasharray: [5] }),
        Plot.lineY(
          liveView.filter((d) => d.body.temperature), // Fix for unfiltering data serverside
          {
            stroke: "#0003",
            x: (d) => new Date(d.when * 1000),
            y: (d) => d.body.temperature
          }
        ),
        Plot.dot(
          liveView.filter((d) => d.body.temperature), // Fix for unfiltering data serverside
          {
            r: 5,
            x: (d) => new Date(d.when * 1000),
            y: (d) => d.body.temperature,
            fill: (d) => d.body.temperature
          }
        )
      ]
    })
  </script>
  <script id="157" type="text/markdown">
    ### streaming query (realtime updates)
  </script>
  <script id="159" type="application/vnd.observable.javascript" pinned="">
    liveViewRaw = Generators.observe((notify) => {
      db.ref(`history/sensors/${querySensorName}`)
        .orderByKey()
        .startAt(Math.floor(Date.now() / 1000 - 60 * 60 * 24) + "") // reduce data returned
        .on("value", (snapshot) => {
          const data = snapshot.val();
          if (data) notify(data);
        });
    })
  </script>
  <script id="166" type="application/vnd.observable.javascript">
    liveView = Object.entries(liveViewRaw).map(([k, v]) => v)
  </script>
  <script id="372" type="application/vnd.observable.javascript">
    latest = Generators.observe((notify) => {
      db.ref(`current/sensors`).once("value", (snapshot) => {
        const data = snapshot.val();
        // clear synthetic data from EP01 testings
        delete data["sensor2"];
        delete data["defaultSensorName"];
        notify(data);
      });
    })
  </script>
  <script id="261" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="1166" type="text/markdown">
    ## (EP04) DuckDB

    Setup in [EP04](https://observablehq.com/@tomlarkworthy/firebase-to-duckdb?collection=@tomlarkworthy/livecoding). We use DuckDB so we can execute SQL within a web browser using Observable awesome SQL cells. For our SMART farm we calculated "growing degree days" (GDD)
  </script>
  <script id="1168" type="application/vnd.observable.javascript">
    import { DuckDBClient } from "@cmudig/duckdb"
  </script>
  <script id="1171" type="application/vnd.observable.javascript">
    duckdb = (prepareAggregation, reset, new DuckDBClient())
  </script>
  <script id="1598" type="text/markdown">
    By making a second reference to a common duckdb client, we can use the first reference to populate the tables, and refresh the 2nd whenever we received new data and need to recompute our SQL cell analytic queries. 
  </script>
  <script id="1244" type="application/vnd.observable.javascript" pinned="">
    fullduck = {
      // Refresh fullduck every insertion (causes analytics to be rerun)
      doInsertRowToDuckDB;
      return duckdb;
    }
  </script>
  <script id="1540" type="text/markdown">
    ### (EP04) Workflow QoL
    The reset button allows us to reset the state and perform the data loading from scratch. *Extremely* useful during development.
  </script>
  <script id="1229" type="application/vnd.observable.javascript" pinned="">
    mutable reset = 0
  </script>
  <script id="2183" type="application/vnd.observable.javascript">
    Inputs.button("reset", { reduce: () => mutable reset++ })
  </script>
  <script id="1482" type="text/markdown">
    ### (EP04) Inserting Data to DuckDB

    For each document sent to the flow queue we execute a SQL INSERT statement to fill DuckDB
  </script>
  <script id="1180" type="application/vnd.observable.javascript" pinned="">
    doCreateTable = {
      reset;
      await duckdb.query(`DROP TABLE IF EXISTS readings`);
      return duckdb.query(
        `CREATE TABLE IF NOT EXISTS readings(sensor STRING, time TIMESTAMP, temperature FLOAT)`
      );
    }
  </script>
  <script id="1186" type="application/vnd.observable.javascript">
    viewof firebaseRow = (prepareAggregation,
    flowQueue({
      timeout_ms: 10000000
    }))
  </script>
  <script id="2204" type="application/vnd.observable.javascript" pinned="">
    firebaseRow
  </script>
  <script id="1194" type="application/vnd.observable.javascript">
    doInsertRowToDuckDB = {
      doCreateTable;
      if (firebaseRow === null) return;
      return duckdb.query(
        `INSERT INTO readings VALUES ('${firebaseRow.device}', '${new Date(
          (firebaseRow.when || firebaseRow.tower_when) * 1000
        ).toISOString()}', ${firebaseRow.body.temperature});`
      );
    }
  </script>
  <script id="1218" type="application/vnd.observable.javascript">
    finishInsert = {
      doInsertRowToDuckDB; // Finsih processing everytime we insert a row
      viewof firebaseRow.resolve();
    }
  </script>
  <script id="2150" type="text/markdown">
    ### (EP04) Computing Grow Degree Days (GDD) in DuckDB
  </script>
  <script id="1307" type="application/sql" pinned="" database="var:db">
    SELECT sensor, CAST(SUM(EXTRACT(epoch from growthDuration)) AS FLOAT) / (60 * 60) as growthHours
    FROM (SELECT *, CASE WHEN isGrowth THEN duration ELSE INTERVAL 0 seconds END growthDuration 
      FROM (
        SELECT sensor, startTime, endTime, avgTemperature, endTime - startTime as duration, temperature > 5 AND temperature < 25 AS isGrowth 
          FROM (
          SELECT sensor, time, temperature, 
              AVG(temperature) OVER lookback avgTemperature,
              MIN(time) OVER lookback startTime,
              MAX(time) OVER lookback endTime
          FROM readings
          WHERE time > ${startTimeIso} AND time < ${endTimeIso}
          WINDOW lookback AS (
            ORDER BY "time"
            ROWS 1 PRECEDING)
          ORDER BY time
        )
      )
      ) GROUP BY sensor
  </script>
  <script id="1757" type="text/markdown">
    ## EP05 Functionification of daily GDD 

    We took the EP04 calculations which were written in the notebook dataflow style and wrapped them in a function so we can more easily reuse the work. We created a function called `aggregate(day, sensor)` which computes the GDD for a day for a given sensor and writes it into `"aggregations/GDD"`. 

    To aid in understanding the dataflow, we open the notebook dataflow debugger:
  </script>
  <script id="2181" type="application/vnd.observable.javascript">
    ndd = _ndd
  </script>
  <script id="2160" type="application/vnd.observable.javascript">
    import {_ndd} from '@tomlarkworthy/ndd'
  </script>
  <script id="2190" type="application/vnd.observable.javascript">
    Inputs.button(`Aggregate ${querySensorName} on 2022-07-05`, {
      reduce: () => aggregate("2022-07-05", querySensorName)
    })
  </script>
  <script id="2251" type="text/markdown">
    The aggregate functions forwards to a `flowQueue`, which allows us to package up dataflow.
  </script>
  <script id="1766" type="application/vnd.observable.javascript" pinned="">
    aggregate = (targetDay, sensor) =>
      viewof aggregationRequest.send({
        targetDay,
        sensor
      })
  </script>
  <script id="1760" type="application/vnd.observable.javascript" pinned="">
    viewof aggregationRequest = (reset,
    flowQueue({
      timeout_ms: 10000000
    }))
  </script>
  <script id="2259" type="text/markdown">
    The head of the queue contains the aggregation request parameters:
  </script>
  <script id="1764" type="application/vnd.observable.javascript" pinned="">
    aggregationRequest
  </script>
  <script id="1639" type="application/vnd.observable.javascript" pinned="">
    startTime = new Date(aggregationRequest.targetDay)
  </script>
  <script id="1667" type="application/vnd.observable.javascript">
    startTimeIso = startTime.toISOString()
  </script>
  <script id="1642" type="application/vnd.observable.javascript" pinned="">
    endTime = new Date(startTime.getTime() + 60 * 60 * 24 * 1000)
  </script>
  <script id="1665" type="application/vnd.observable.javascript">
    endTimeIso = endTime.toISOString()
  </script>
  <script id="2303" type="text/markdown">
    We first query the sensor data from `history/sensors/{sensor}` from Firebase with a "once" query
  </script>
  <script id="1703" type="application/vnd.observable.javascript" pinned="">
    aggregationSensorDataRaw = new Promise((resolve) => {
      db.ref(`history/sensors/${aggregationRequest.sensor}`)
        .orderByKey()
        .startAt(startTime.getTime() / 1000 + "")
        .endAt(endTime.getTime() / 1000 + "")
        .once("value", (snap) => resolve(snap.val()));
    })
  </script>
  <script id="2354" type="text/markdown">
    We massage it into [tidy data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) form in a follow up cell
  </script>
  <script id="1710" type="application/vnd.observable.javascript" pinned="">
    aggregationSensorData = aggregationSensorDataRaw
      ? Object.entries(aggregationSensorDataRaw)
          .filter(([k, v]) => v.body.temperature)
          .map(([k, v]) => v)
      : []
  </script>
  <script id="2263" type="text/markdown">
    We reset DuckDB state before inserting data
  </script>
  <script id="2009" type="application/vnd.observable.javascript" pinned="">
    prepareAggregation = {
      aggregationSensorData;
    }
  </script>
  <script id="2360" type="text/markdown">
    Our insert cell does not resolve until all data is inserted thanks to the `Promise.all`
  </script>
  <script id="1718" type="application/vnd.observable.javascript" pinned="">
    insertIntoDb = {
      prepareAggregation;
      doCreateTable; // ensure DuckDB is reset and tables recreated
      if (aggregationSensorData.length === 0) {
        viewof firebaseRow.send(null);
      } else {
        return await Promise.all(
          aggregationSensorData.map((data) => viewof firebaseRow.send(data))
        );
      }
    }
  </script>
  <script id="2363" type="text/markdown">
    We can directly retrieve the value of the SQL cell after all data has been inserted, which in our case, is computing the GDD growthHours
  </script>
  <script id="1736" type="application/vnd.observable.javascript" pinned="">
    growthHoursAggregation = {
      insertIntoDb; // dataflow link to do after insertion
      return aggregation[0]?.growthHours || 0;
    }
  </script>
  <script id="2373" type="text/markdown">
    After computing the growthHours we insert it back into Firebase at `/aggregations/GDD/`as a batch precomputation. Our lambda architecture will read this precomputed data to save time for the realtime graphs. 
  </script>
  <script id="1746" type="application/vnd.observable.javascript" pinned="">
    writeAggregation = {
      await firebase.auth().signInAnonymously();
      return db
        .ref(
          `/aggregations/GDD/${aggregationRequest.sensor}/${
            startTime.getTime() / 1000
          }`
        )
        .set(growthHoursAggregation);
    }
  </script>
  <script id="2376" type="text/markdown">
    After writing to Firebase we can consider the aggregation task complete, we return the growthHours as the 'return' value
  </script>
  <script id="1777" type="application/vnd.observable.javascript" pinned="">
    returnResultToFlowQueue = {
      writeAggregation;
      return viewof aggregationRequest.resolve(growthHoursAggregation);
    }
  </script>
  <script id="1773" type="text/markdown">
    ### Orchestrating aggregate

    Now that aggregation has a function interface, it is more easily reused. We can create an aggregateAll function that applies aggregate to several sensors, and we can write a backfill function that calls aggregate over many days, for example.

    In the future, we will want to schedule aggregate with a [cron](https://observablehq.com/@endpointservices/cron).

    What we have now is enough to demonstrate the performance gains of the lambda architecture. For a bit of fun, checkout the notebook dataflow debugger after pressing backfill button)
  </script>
  <script id="2398" type="application/vnd.observable.javascript">
    Inputs.button(`aggregateAll("2022-07-02")`, {
      reduce: () => aggregateAll("2022-07-02")
    })
  </script>
  <script id="1797" type="application/vnd.observable.javascript" pinned="">
    function aggregateAll(day) {
      return Promise.all(
        [
          "dev:864475046458393",
          "dev:864475046461397",
          "dev:864475046554399"
        ].map((device) => aggregate(day, device))
      );
    }
  </script>
  <script id="1942" type="application/vnd.observable.javascript" pinned="">
    Inputs.button("backfill", {
      reduce: async () => {
        for (let i = 22; i <= 26; i++) {
          await aggregateAll(`2022-07-${(i < 10 ? "0" : "") + i}`);
        }
      }
    })
  </script>
  <script id="1634" type="text/markdown">
    ## Tarot of the Day
    *Will our vlog "building a smart farm" help with future heat waves in the united states?*

    <a target="_blank" href="https://thetarot.online/-N6n9gDvUEeH_7tKXMLz"><img 
    width=${Math.min(width, 640)}                                                                         src="https://storage.googleapis.com/download/storage/v1/b/larkworthy-dfb11.appspot.com/o/@tomlarkworthy%2Ftarot-backend%2Fimages%2F-N6n9gDvUEeH_7tKXMLz?generation=1657642077175681&alt=media">
    </img></a>


  </script>
  <script id="585" type="text/markdown">
    ## Next episode
  </script>
  <script id="616" type="application/vnd.observable.javascript">
    upcoming
  </script>
  <script id="453" type="text/markdown">
    ## Dependancies
  </script>
  <script id="592" type="application/vnd.observable.javascript">
    import { upcoming } from "@endpointservices/meetups";
  </script>
  <script id="206" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer"
  </script>
  <script id="227" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
