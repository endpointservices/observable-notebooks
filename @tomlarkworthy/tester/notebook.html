<!doctype html>
<notebook theme="air">
  <title>Tests</title>
  <script id="0" type="text/markdown">
    # Tests
  </script>
  <script id="453" type="application/vnd.observable.javascript">
    tests()
  </script>
  <script id="400" type="text/markdown">
    ## Low Boiler-plate

    Any *cell*, that starts with `test_` is considered a test, whether in the main notebook or in a dependancy. The cell is considered "passing" if it evaluates to a non-error. Inspired by pytest auto-discovery.


    The runner makes no assumption on how you actually test. You could use programatic tests or something more sophisticated like `expect`. Just throw something to indicate failure.

    You can filter the tests to lower the quantity

    ```js
    import {tests} from "@tomlarkworthy/tests"
    ```
  </script>
  <script id="327" type="text/markdown">
    ## Interactive Examples

    Demo of the test state is reactive, even with active dataflow.
  </script>
  <script id="376" type="application/vnd.observable.javascript">
    viewof example_type = Inputs.radio(
      ["success", "error", "pending", "changing"],
      {
        label: "case"
      }
    )
  </script>
  <script id="329" type="application/vnd.observable.javascript" pinned="">
    test_tests_example = {
      switch (example_type) {
        case "error":
          throw "Error";
        case "success":
          yield "Ok";
        case "pending":
          yield new Promise(() => {});
        case "changing":
          while (true) {
            yield Math.random();
            await new Promise((r) => setTimeout(r, 1000));
          }
      }
      yield new Promise(() => {});
    }
  </script>
  <script id="200" type="text/markdown">
    ## Testing variables

    variables that start with "`test_`", sniffed from the runtime, updated reactively
  </script>
  <script id="88" type="application/vnd.observable.javascript">
    modules = moduleMap(runtime)
  </script>
  <script id="53" type="application/vnd.observable.javascript">
    viewof testing_variables = scan({
      view: viewof runtime_variables,
      scan: (acc, value) => {
        const test_vars = [...value]
          .filter((v) => typeof v._name == "string" && v._name.startsWith("test_"))
          .map((v) => ({
            name: (modules.get(v._module)?.name || "") + "#" + v._name,
            running: v._reachable,
            variable: v
          }));
        return _.isEqual(acc, test_vars) ? undefined : test_vars;
      },
      invalidation
    })
  </script>
  <script id="169" type="application/vnd.observable.javascript">
    Inputs.table(testing_variables)
  </script>
  <script id="513" type="text/markdown">
    ## UI
  </script>
  <script id="557" type="application/vnd.observable.javascript" pinned="">
    isObservable = isOnObservableCom() &&
      !document.baseURI.startsWith(
        "https://observablehq.com/@tomlarkworthy/lopepage"
      ) // for testing on Observble lopepage notebook
  </script>
  <script id="322" type="application/vnd.observable.javascript">
    tests = ({ filter = () => true } = {}) => {
      background_task;
      return Inputs.table(current.filter(filter), {
        rows: Infinity,
        columns: ["name", "state", "value"],
        reverse: true,
        format: {
          state: (state) =>
            state === "fulfilled"
              ? "✅"
              : state === "rejected"
              ? "❌"
              : state === "pending"
              ? "⌛️"
              : "⏸️",
          name: url,
          value: inspect
        },
        width: {
          state: "5%"
        },
        layout: "auto"
      });
    }
  </script>
  <script id="311" type="application/vnd.observable.javascript">
    current = testing_variables
      .map((testing_variable) => ({
        name: testing_variable.name,
        state: "paused",
        ...latest_state.get(testing_variable.name),
        computed: testing_variable.running,
        variable: testing_variable.variable
      }))
      .sort((b, a) => {
        // 1) errors first
        if (a.error !== b.error) return a.error ? -1 : 1;
        // 2) “local” names (starting with ‘#’) next
        const aLocal = a.name.startsWith("#");
        const bLocal = b.name.startsWith("#");
        if (aLocal !== bLocal) return aLocal ? -1 : 1;
        // 3) finally, lexicographic by name
        return a.name.localeCompare(b.name);
      })
  </script>
  <script id="517" type="application/vnd.observable.javascript">
    import { linkTo } from "@tomlarkworthy/lopepage-urls"
  </script>
  <script id="496" type="application/vnd.observable.javascript" pinned="">
    url = (name) => {
      if (isObservable) {
        return html`<a href="/${name}" target="_blank">${name}</a>`;
      } else {
        return html`<a href="${linkTo(name)}">${name}</a>`;
      }
    }
  </script>
  <script id="207" type="text/markdown">
    ## Latest State

    Variables update reactively, so observers are registered for running testing variables and update the latest state as information arrives. Only applied to running variables.
  </script>
  <script id="273" type="application/vnd.observable.javascript">
    Inputs.table(
      [...latest_state.entries()].map(([name, state]) => ({
        name,
        ...state
      }))
    )
  </script>
  <script id="243" type="application/vnd.observable.javascript">
    viewof latest_state = Inputs.input(new Map())
  </script>
  <script id="211" type="application/vnd.observable.javascript">
    observers = new Map()
  </script>
  <script id="302" type="text/markdown">
    ### Observer syncronization
  </script>
  <script id="217" type="application/vnd.observable.javascript">
    changes = testing_variables &&
      unorderedSync(
        testing_variables.filter((v) => v.running),
        [...observers.keys()],
        (a, b) => a.name == b
      )
  </script>
  <script id="224" type="application/vnd.observable.javascript">
    on_add = changes.add.forEach((testing_variable) => {
      observers.set(
        testing_variable.name,
        observe(testing_variable.variable, {
          fulfilled: (value) => {
            viewof latest_state.value.set(testing_variable.name, {
              state: "fulfilled",
              value: value
            });
            viewof latest_state.dispatchEvent(new Event("input"));
          },
          pending: (value) => {
            viewof latest_state.value.set(testing_variable.name, {
              state: "pending"
            });
            viewof latest_state.dispatchEvent(new Event("input"));
          },
          rejected: (error) => {
            viewof latest_state.value.set(testing_variable.name, {
              state: "rejected",
              value: error
            });
            viewof latest_state.dispatchEvent(new Event("input"));
          }
        })
      );
    })
  </script>
  <script id="293" type="application/vnd.observable.javascript">
    on_remove = {
      testing_variables;
      changes.remove.forEach((name) => {
        const current = observers.get(name);
        if (current) {
          current(); // deregister listener
          observers.delete(name);
        }
        viewof latest_state.value.delete(name);
      });
      viewof latest_state.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="457" type="text/markdown">
    ## Background Tasks
  </script>
  <script id="478" type="application/vnd.observable.javascript" pinned="">
    tasks = {
      on_add;
      on_remove;
      submit_summary;
    }
  </script>
  <script id="464" type="application/vnd.observable.javascript" pinned="">
    background_task = keepalive(testsModule, "tasks")
  </script>
  <script id="459" type="application/vnd.observable.javascript">
    viewof testsModule = thisModule()
  </script>
  <script id="81" type="application/vnd.observable.javascript">
    import { moduleMap, submit_summary } from "@tomlarkworthy/module-map"
  </script>
  <script id="47" type="application/vnd.observable.javascript">
    import {
      isOnObservableCom,
      viewof runtime_variables,
      runtime,
      unorderedSync,
      observe,
      thisModule,
      keepalive
    } from "@tomlarkworthy/runtime-sdk"
  </script>
  <script id="55" type="application/vnd.observable.javascript">
    import { scan } from "@tomlarkworthy/stream-operators"
  </script>
  <script id="485" type="application/vnd.observable.javascript">
    import { inspect, Inspector } from "@tomlarkworthy/inspector"
  </script>
</notebook>
