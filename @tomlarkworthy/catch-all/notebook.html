<!doctype html>
<notebook theme="air">
  <title>Detect notebook runtime errors with catchAll((cellName, reason) =&gt; {...})</title>
  <script id="0" type="text/markdown">
    # Detect notebook runtime errors with *catchAll((cellName, reason) => {...})*

    <span style="font-size: 300px; padding-left: 100px">ðŸš¨</span>



    *catchAll* registers a callback that will be informed of any uncaught cell errors in the notebook. 

    ---
    Usage:
    ```js
    import {catchAll} from '@tomlarkworthy/catch-all'
    ```

  </script>
  <script id="419" type="text/markdown">
    ### Change Log

    - 2022-06-26, removed mootari/access-runtime and inspected cells instead. This loses the cellName, but does track new cells being added

  </script>
  <script id="370" type="text/markdown">
    #### note

    You can pass an *invalidation* promise as the 2nd argument to clean up the observers, this is needed if you expect to be calling *catchAll* more than once.
  </script>
  <script id="113" type="text/markdown">
    ### Demo
  </script>
  <script id="68" type="application/vnd.observable.javascript">
    viewof errorTrigger = Inputs.button(md`throw an error`, { required: true })
  </script>
  <script id="300" type="application/vnd.observable.javascript">
    Inputs.table(errorLog)
  </script>
  <script id="279" type="application/vnd.observable.javascript" pinned="">
    errorCell = {
      errorTrigger;
      // Errors thrown here are picked up by catchAll
      throw new Error("An error " + Math.random().toString(16).substring(3));
    }
  </script>
  <script id="292" type="application/vnd.observable.javascript" pinned="">
    catchAll((cellName, reason) => {
      mutable errorLog = mutable errorLog.concat({
        cellName,
        reason
      });
    }, invalidation)
  </script>
  <script id="294" type="application/vnd.observable.javascript">
    mutable errorLog = []
  </script>
  <script id="119" type="text/markdown">
    ### Implementation
  </script>
  <script id="416" type="application/vnd.observable.javascript" pinned="">
    viewof error = {
      const view = Inputs.input();

      const notify = (event) => {
        view.value = event.detail.error;
        view.dispatchEvent(new Event("input", { bubbles: true }));
      };

      const processInspectorNode = (el) => {
        el.addEventListener("error", notify);
      };

      // Attach to current cells
      [...document.querySelectorAll(".observablehq").values()].forEach(
        processInspectorNode
      );
      // Watch for new cells
      const root = document.querySelector(".observablehq-root");
      if (root) {
        const observer = new MutationObserver((mutationList, observer) => {
          for (const mutation of mutationList) {
            [...mutation.addedNodes].forEach(processInspectorNode);
          }
        });
        observer.observe(root, {
          childList: true
        });
        invalidation.then(observer.disconnect);
      }
      return view;
    }
  </script>
  <script id="7" type="application/vnd.observable.javascript" pinned="">
    catchAll = (handler, invalidation) => {
      const listener = () => handler("unknown", viewof error.value);
      viewof error.addEventListener("input", listener);
      if (invalidation)
        invalidation.then(() => {
          viewof error.removeEventListener(listener);
        });
    }
  </script>
  <script id="216" type="text/markdown">
    ### Tests and CI

    We load the testing framework asynchronously to avoid statically depending on test libraries in production use. We can externally check these tests pass with [healthcheck](https://webcode.run/observablehq.com/@endpointservices/healthcheck?target=%40tomlarkworthy%2Fcatch-all&excludes=errorCell&wait=5) which is passed to an external monitoring solution (see [howto-monitoring](https://observablehq.com/@tomlarkworthy/howto-monitoring)).

    Continuous integration is important for a library like this where API changes in Observable can easily break the implementation.
  </script>
  <script id="214" type="application/vnd.observable.javascript">
    testing = {
      viewof errorTrigger, catchAll;
      const [{ Runtime }, { default: define }] = await Promise.all([
        import(
          "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js"
        ),
        import(`https://api.observablehq.com/@tomlarkworthy/testing.js?v=3`)
      ]);
      const module = new Runtime().module(define);
      return Object.fromEntries(
        await Promise.all(
          ["expect", "createSuite"].map((n) => module.value(n).then((v) => [n, v]))
        )
      );
    }
  </script>
  <script id="227" type="application/vnd.observable.javascript">
    viewof suite = testing.createSuite()
  </script>
  <script id="233" type="application/vnd.observable.javascript">
    suite.test("Errors are logged", async (done) => {
      const numErrors = mutable errorLog.length;
      viewof errorTrigger.dispatchEvent(new Event("input")); // trigger an error
      setTimeout(() => {
        const newNumErrors = mutable errorLog.length;
        testing.expect(newNumErrors - numErrors).toBeGreaterThan(0);
        done();
      }, 500);
    })
  </script>
  <script id="207" type="application/vnd.observable.javascript">
    import { footer } from "@endpointservices/footer"
  </script>
  <script id="210" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
