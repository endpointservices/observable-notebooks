<!doctype html>
<notebook theme="air">
  <title>Exponentially Weighted Moving Rate Estimation with Fast Initialization</title>
  <script id="175" type="application/vnd.observable.javascript">
    md`# Exponentially Weighted Moving Rate Estimation with Fast Initialization

    For use as serverless in-memory rate limiters ([packaged](https://observablehq.com/@tomlarkworthy/rate-estimation-min)).

    ![](${await FileAttachment("image.png").url()})

    Rate limiters are used to prevent damage and are an important tools for reliability engineering.

    This rate estimator is designed to 

    - By used in Pareto situations where most tenants are far from engineering limits
    - Optimized for small memory footprint
    - Designed to reside in lambda memory.
    - Fast convergence on initialization

    The assumption is that only a few high traffic customers will need rate limiting at any time. Those kinds of workloads will end up hitting all lambda clones in production. Thus it's enough to estimate the rate on an individual runtime and multiple by the number of running clones. Its approximate but cheap.

    ## Implementation Sketch

    Serverless runtimes are booted up frequently, so they need to converge to good estimates fast. As each runtime will have to hold rate counters for all 'recent customers', each counter needs to be lightweight.

    To estimate rate we use an Exponentially Weighted Moving Average (EWMA) of the event intervals. At low sample counts we have a _fastConverge_ feature to calculate rate estimates based on small sample size statistics. 

    The following page expains how the _fastConverge_ optimization works.
    `
  </script>
  <script id="546" type="application/vnd.observable.javascript">
    md`## Experiment on _fastConverge_ Parameter`
  </script>
  <script id="377" type="application/vnd.observable.javascript">
    mutable experiment = ({
      window_secs: 2,
      start_t: start_t,
      first: true,
      rate_estimator: rate_estimator({
        fastConverge: false,
        forgetFactor: 0.02,
        initial_rate: 45 / 1000 // Time unit is millis not seconds
      }),
      rate_estimator_fast: rate_estimator({
        fastConverge: true,
        forgetFactor: 0.02,
        initial_rate: 45 / 1000 // Time unit is millis not seconds
      }),
      samples: []
    })
  </script>
  <script id="381" type="application/vnd.observable.javascript">
    experiment_step = {
      const sample = now;
      if (now > experiment.start_t + experiment.window_secs * 1000) return;

      if (experiment.first) {
        experiment.rate_estimator.last_t = sample;
        experiment.rate_estimator_fast.last_t = sample;
        experiment.start_t = sample;
        experiment.first = false;
        return;
      }

      // Update running rate estimators
      experiment.rate_estimator = experiment.rate_estimator.observeAtTime(sample);
      experiment.rate_estimator_fast = experiment.rate_estimator_fast.observeAtTime(sample);

      // Push new sample, time and predictions
      experiment.samples.push({
        t: sample,
        r1: experiment.rate_estimator.estimateRateAtTime(sample) * 1000,
        r2: experiment.rate_estimator_fast.estimateRateAtTime(sample) * 1000,
      })
      // expire old samples
      while (experiment.samples[0].t < sample - experiment.window_secs * 1000) 
        experiment.samples.shift()
    }
  </script>
  <script id="473" type="application/vnd.observable.javascript">
    mutable start_t = Date.now() // Also used to reset experiments
  </script>
  <script id="578" type="application/vnd.observable.javascript">
    md`

    The following is a timeseries of the 'now' spike train. On the Y axis is an estimate of the frequency (frames per second). The blue and red are estimates of the rate, with and without the _fastConverge_ parameter. The rate estimation has a low forgetting factor (0.02), so the initial state takes a long time to be forgotten without _fastConverge_.
    `
  </script>
  <script id="465" type="application/vnd.observable.javascript">
    {
      function reset() {
        mutable start_t = Date.now()
      }
      return html`<button onclick=${reset}>run</button>`
    }
  </script>
  <script id="386" type="application/vnd.observable.javascript">
    converge = {
      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const viewportHeight = 280;
      const viewportWidth = 500;
      const xMapper = d3
        .scaleTime()
        .domain([experiment.samples[0].t, Math.min(now, experiment.start_t + experiment.window_secs * 1000)])
        .range([margin.left, viewportWidth - margin.right]);

      const yMapper = d3
        .scaleLinear()
        .domain([0, 70])
        .range([viewportHeight - margin.bottom, margin.top]);

      const line = d3
        .line()
        .x(d => xMapper(d[0]))
        .y(d => yMapper(d[1]));

      const xAxis = function(g) {
        return g.attr("transform", `translate(0,${viewportHeight - margin.bottom})`).call(
          d3
            .axisBottom(xMapper)
            .ticks(d3.timeSecond.every(1))
        );
      };

      const yAxis = function(g) {
        return g.attr("transform", `translate(${margin.left},0)`).call(
          d3
            .axisLeft(yMapper)
            .ticks(5)
            .tickSizeOuter(0)
        );
        // to remove the axis line, add the following
        // .call(g => g.select(".domain").remove());
      };

      const svg = d3
        .create("svg")
        .attr("xmlns", "http://www.w3.org/2000/svg")
        .attr("width", viewportWidth)
        .attr("height", viewportHeight)
        .attr("style", "border:1px solid black");

      svg
        .append('rect')
        .attr('fill', '#FFF')
        .attr('width', width)
        .attr('height', viewportHeight)
      svg
        .append("path")
        .datum(experiment.samples.flatMap(s => [[s.t, 0], [s.t, 20], [s.t, 0]]))
        .attr("d", line)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 1.5)
        .attr("stroke-miterlimit", 1)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round");

      svg
        .append("path")
        .datum(experiment.samples.map(s => [s.t, s.r1]))
        .attr("d", line)
        .attr("fill", "none")
        .attr("stroke", "red")
        .attr("stroke-width", 1.5)
        .attr("stroke-miterlimit", 1)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round");

      svg
        .append("path")
        .datum(experiment.samples.map(s => [s.t, s.r2]))
        .attr("d", line)
        .attr("fill", "none")
        .attr("stroke", "blue")
        .attr("stroke-width", 1.5)
        .attr("stroke-miterlimit", 1)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round");

      svg.append("g").call(xAxis);
      svg.append("g").call(yAxis);

      return svg.node();
    }
  </script>
  <script id="711" type="application/vnd.observable.javascript">
    md`[Get gif](https://observablehq.com/@tomlarkworthy/svg-to-gif?id=@tomlarkworthy/rate-estimation&cell=converge)`
  </script>
  <script id="596" type="application/vnd.observable.javascript">
    md`## Experiment on rate tracking

    The forgetFactor controls how must history is integrated into the running rate estimate. A small value is smooth but slow to react to changes in the rate.

    `
  </script>
  <script id="599" type="application/vnd.observable.javascript">
    mutable experiment_tracking = ({
      start_t: start_t,
      window_secs: 2,
      first: true,
      rate_estimator: rate_estimator({
        fastConverge: true,
        forgetFactor: forgetFactor,
        initial_rate: 0
      }),
      samples: []
    })
  </script>
  <script id="603" type="application/vnd.observable.javascript">
    experiment_tracking_step = {
      while (true) {
        const sample = Date.now()
        if (experiment_tracking.first) {
          experiment_tracking.rate_estimator.last_t = sample;
          experiment_tracking.first = false;
        } else {
          // Update running rate estimators
          experiment_tracking.rate_estimator = experiment_tracking.rate_estimator.observeAtTime(sample);

          // Push new sample, time and predictions
          experiment_tracking.samples.push({
            t: sample,
            r2: experiment_tracking.rate_estimator.estimateRateAtTime(sample) * 1000,
          })
          // expire old samples
          while (experiment_tracking.samples[0].t < sample - experiment_tracking.window_secs * 1000) 
            experiment_tracking.samples.shift()
        }
        const delay = 1.0 / frequency * 1000;
        yield Promises.tick(delay);
      }
    }
  </script>
  <script id="645" type="application/vnd.observable.javascript">
    viewof forgetFactor = slider({
      min: 0, 
      max: 1, 
      step: 0.01, 
      value: 0.2, 
      title: "forgetFactor",
    })
  </script>
  <script id="621" type="application/vnd.observable.javascript">
    viewof frequency = slider({
      min: 1, 
      max: 60, 
      step: 1, 
      value: 20, 
      title: "Events per second"
    })
  </script>
  <script id="608" type="application/vnd.observable.javascript">
    {
      function reset() {
        mutable start_t = Date.now()
      }
      return html`<button onclick=${reset}>run</button>`
    }
  </script>
  <script id="606" type="application/vnd.observable.javascript">
    {
      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const viewportHeight = 300;
      const viewportWidth = width;
      const xMapper = d3
        .scaleTime()
        .domain([now - experiment_tracking.window_secs * 1000, now])
        .range([margin.left, viewportWidth - margin.right]);

      const yMapper = d3
        .scaleLinear()
        .domain([0, 70])
        .range([viewportHeight - margin.bottom, margin.top]);

      const line = d3
        .line()
        .x(d => xMapper(d[0]))
        .y(d => yMapper(d[1]));

      const xAxis = function(g) {
        return g.attr("transform", `translate(0,${300 - margin.bottom})`).call(
          d3
            .axisBottom(xMapper)
            .ticks(d3.timeSecond.every(1))
        );
      };

      const yAxis = function(g) {
        return g.attr("transform", `translate(${margin.left},0)`).call(
          d3
            .axisLeft(yMapper)
            .ticks(5)
            .tickSizeOuter(0)
        );
        // to remove the axis line, add the following
        // .call(g => g.select(".domain").remove());
      };

      const svg = d3
        .create("svg")
        .attr("width", width)
        .attr("height", 300)
        .attr("style", "border:1px solid black");

      svg
        .append("path")
        .datum(experiment_tracking.samples.flatMap(s => [[s.t, 0], [s.t, 20], [s.t, 0]]))
        .attr("d", line)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 1.5)
        .attr("stroke-miterlimit", 1)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round");

      svg
        .append("path")
        .datum(experiment_tracking.samples.map(s => [s.t, s.r2]))
        .attr("d", line)
        .attr("fill", "none")
        .attr("stroke", "blue")
        .attr("stroke-width", 1.5)
        .attr("stroke-miterlimit", 1)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round");

      svg.append("g").call(xAxis);
      svg.append("g").call(yAxis);

      return svg.node();
    }
  </script>
  <script id="684" type="application/vnd.observable.javascript">
    md`## Experiment on Number of clones 

    If we have _n_ clones with user traffic randomly load balanced over them. Then obviously they only see _nth_ the frequency so we should _n_ their estimate too. But should we need also scale their forgetting factor too to keep their convergence rate constant? 

    __TODO, not critical right now__
    `
  </script>
  <script id="64" type="application/vnd.observable.javascript">
    md`## Forgetful Rate Estimator

    Takes a stream of time measurements, and estimates the rate. E.g. send it "new Date().getTime() / 1000" and it will converge to (frames per second)

    By default it assumes a rate of 1 dt. You have to initialize the historical state which it then forgets over time by the _forgetFactor_. Without _fastConverge_ it assumes it is always in the steady state. So if you have a low _forgetFactor_, it will be slow to forget its initial conditions.

    _fastCoverge_ takes into account the number of samples already taken. When there is a low sample count, new measurements are weighted more heavily than the _forgetFactor_ would. This makes the estimate converge much more quickly after restart.
    `
  </script>
  <script id="115" type="application/vnd.observable.javascript">
    rate_estimator = ({
        fastConverge = true,
        forgetFactor = 0.9,
        initial_rate = 1,
        initial_t = 0,
      } = {}) => {
      const smallSetThreshold = Math.floor(1.0 / forgetFactor)
      class RateEstimate {
        constructor(state) {
          Object.assign(this, state);
        }
        observeAtTime (t) {
          const interval = t - this.last_t;
          if (fastConverge && this.n < smallSetThreshold) {
            const n = this.n + 1
            return new RateEstimate({
              n: n,
              last_t: t,
              dt: ((n - 1) * (this.dt) + 1 * interval) / n
            });
          } else {
            return new RateEstimate({
              n: this.n + 1,
              last_t: t,
              dt: (1 - forgetFactor) * (this.dt) + forgetFactor * interval
            });
          }
        }
        estimateRateAtTime (t) {
          if (t === this.last_t) {
            // No time has passed since last observation
            // Use historical mean interval
            return 1.0 / this.dt;
          } else {
            const interval = t - this.last_t;
            if (interval < this.dt) {
              // If less time has passed than expected, we can use
              // the existing estimate
              return 1.0 / this.dt;
            } else {
              // Its been a long time since an observation
              // The lack of information should affect the prediction
              return this.observeAtTime(t).estimateRateAtTime(t);
            }
          }
        }
      }
      return new RateEstimate({
        n: 0,
        last_t: initial_t,
        dt: 1.0 / Math.max(initial_rate, 0.00001)
      })
    }
  </script>
  <script id="124" type="application/vnd.observable.javascript" pinned="">
    mutable frames_per_second_estimator = rate_estimator({
      fastConverge: true,
      forgetFactor: 0.01,
      initial_rate: 30,
      initial_t: (new Date().getTime() - 16) / 1000
    })
  </script>
  <script id="132" type="application/vnd.observable.javascript" pinned="">
    { 
      mutable frames_per_second_estimator = frames_per_second_estimator.observeAtTime(now / 1000)
      return frames_per_second_estimator.estimateRateAtTime(now/1000)
    }
  </script>
  <script id="88" type="application/vnd.observable.javascript">
    viewof rate_estimator_tests = createSuite()
  </script>
  <script id="231" type="application/vnd.observable.javascript">
    rate_estimator_tests.test("rate_estimator_tests.forgetFactor", () => {
      expect(
        rate_estimator({
          fastConverge: false,
          forgetFactor: 0.7
        }).observeAtTime(2).estimateRateAtTime(2)
      ).toBeCloseTo(0.59)

      expect(
        rate_estimator({
          fastConverge: false,
          forgetFactor: 0.2
        }).observeAtTime(2).estimateRateAtTime(2)
      ).toBeCloseTo(0.83)
    })
  </script>
  <script id="245" type="application/vnd.observable.javascript">
    rate_estimator_tests.test("rate_estimator_tests.initial_rate", () => {
      expect(
        rate_estimator({
          fastConverge: false,
          initial_rate: 0.5
        }).observeAtTime(2).estimateRateAtTime(2)
      ).toBeCloseTo(0.5)

      expect(
        rate_estimator({
          fastConverge: false,
          initial_rate: 2
        }).observeAtTime(0.5).estimateRateAtTime(0.5)
      ).toBeCloseTo(2)
    })
  </script>
  <script id="286" type="application/vnd.observable.javascript">
    rate_estimator_tests.test("rate_estimator_tests.estimateRateAtTime(t)", () => {
      expect(
        rate_estimator({
          fastConverge: false,
          initial_rate: 2
        }).estimateRateAtTime(0)
      ).toBeCloseTo(2)

      expect(
        rate_estimator({
          fastConverge: false,
          initial_rate: 2
        }).estimateRateAtTime(2)
      ).toBeCloseTo(0.54)

    })
  </script>
  <script id="332" type="application/vnd.observable.javascript">
    rate_estimator_tests.test("rate_estimator_tests.fastConverge(t)", () => {
      // Slow to converge (low forgetFactor)
      // initialized very wrong
      let estimator = rate_estimator({
          fastConverge: true,
          forgetFactor: 0.001,
          initial_rate: 100
        })
      // First measurement is initialization
      expect(
        estimator.estimateRateAtTime(0)
      ).toBeCloseTo(100)

      // Delays to first observation pull down rate estimate
      expect(
        estimator.estimateRateAtTime(1)
      ).toBeLessThan(100)

      // Do an observation after 1 second.
      estimator = estimator.observeAtTime(1)

      // As this is first time we expect to just use that 
      expect(
        estimator.estimateRateAtTime(1)
      ).toBe(1)

      debugger;
      // Do an observation after 1.5 second, 0.5 seconds after the first
      estimator = estimator.observeAtTime(1.5)

      // With fastConverge we have had two samples, one with an interval of 1 and one with an interval of 0.5
      // Average interval is thus 0.75 (TODO I am not sure arithmetic mean is ideal for frequency domain)
      expect(
        estimator.estimateRateAtTime(1)
      ).toBeCloseTo(1.0 / 0.75)
    })
  </script>
  <script id="0" type="application/vnd.observable.javascript">
    md`## Exponentially Weighted Moving Average (EWMA)

    Takes the average of a stream of numbers, weighted by a forget factor. 1 means ignore history. 0 means ignore fresh data.
    `
  </script>
  <script id="9" type="application/vnd.observable.javascript">
    running_mean = ({
        forgetFactor = 0.9,
        initial = 0
      } = {}) => {
      let mean = initial;
      return (datum) => {
        mean = (1 - forgetFactor) * (mean) + forgetFactor * datum;
        return mean
      }
    }
  </script>
  <script id="15" type="application/vnd.observable.javascript">
    viewof running_mean_tests = createSuite()
  </script>
  <script id="18" type="application/vnd.observable.javascript">
    running_mean_tests.test("config.initial", () => {
      expect(running_mean({
        initial: 1
      })(1)).toBe(1)

      expect(running_mean({
        initial: 2
      })(2)).toBe(2)
    })
  </script>
  <script id="47" type="application/vnd.observable.javascript">
    running_mean_tests.test("config.forgetFactor", () => {
      expect(running_mean({
        forgetFactor: 0.9
      })(1)).toBe(0.9)

      expect(running_mean({
        forgetFactor: 0.2
      })(1)).toBe(0.2)
    })
  </script>
  <script id="11" type="application/vnd.observable.javascript">
    import {expect, createSuite} from '@tomlarkworthy/testing'
  </script>
  <script id="626" type="application/vnd.observable.javascript">
    import {slider} from "@jashkenas/inputs"
  </script>
  <script id="478" type="application/vnd.observable.javascript">
    import {html} from '@observablehq/htl'
  </script>
  <script id="349" type="application/vnd.observable.javascript">
    d3 = require("d3@6")
  </script>
  <script id="740" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="758" type="application/vnd.observable.javascript" pinned="">
    footer
  </script>
</notebook>
