<!doctype html>
<notebook theme="air">
  <title>Password Secured Clientside AWS Notebook</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`# Password Secured Clientside AWS Notebook

    In a [previous notebook](https://observablehq.com/@tomlarkworthy/access-aws) I secured AWS credentials behind a [serverside cell](https://observablehq.com/@tomlarkworthy/serverside-cells) proxy. This is good if you do not want AWS credentials exposed to the notebook user and want full control over AWS API interactions. It would be a good way of building a product. However, its still quite a burden to develop as you have to write alot of boilerplate in the proxy layer. 

    ![Rake hitting me in the face](${await FileAttachment("myproxy.jpg").url()})

    This _notebook removes the need for a proxy altogether_ by minting temporary credentials server-side to pass to the front end. This means the notebook connects to AWS directly running off short lived credentials. To prevent abuse the endpoint is password protected.

    ** Using Argon2 password hashing, we are able to store the password in the notebook itself **

    The main benefits of this method is
    - You can work with the AWS SDK in the local browser
    - Notebooks can be forked and still work, even unpublished, as long as credentials are fetched from a published original
    - Master credentials are still hidden
    - If there was token leak it would only have limited time to be exploited

    There are some drawbacks
    - Only works if AWS endpoints have CORS
    - Can only be used in a freindly environment
    - You lose fine grained control over what the user can do within an API.

    This suits sole programmer wanting to experiment with AWS with low friction. There is an even simpler way by encrypting the [secret in the front end](https://observablehq.com/@endpointservices/notebook-secret).
    `
  </script>
  <script id="363" type="application/vnd.observable.javascript">
    md`### The default build of the AWS Browser SDK`
  </script>
  <script id="45" type="application/vnd.observable.javascript">
    AWS = require('https://sdk.amazonaws.com/js/aws-sdk-2.799.0.min.js').then(_ => window['AWS'])
  </script>
  <script id="367" type="application/vnd.observable.javascript">
    md`### The Argon2i password hashing algorithm
    we hide the password in plain sight.`
  </script>
  <script id="349" type="application/vnd.observable.javascript">
    import {argon2} from '@tomlarkworthy/argon2'
  </script>
  <script id="431" type="application/vnd.observable.javascript">
    stored_password = "44dd7cab46f45921e05c4bcd92593f140918726463fcb00e"
  </script>
  <script id="397" type="application/vnd.observable.javascript">
    salt = "Gtoc2Rhc2s" // If you ahve multiple users it should be unique per user
  </script>
  <script id="442" type="application/vnd.observable.javascript">
    md`User must supply a password in memory that hashes to the stored version. For the sake of a demo, **the password for this notebook is _qwerty_**.`
  </script>
  <script id="391" type="application/vnd.observable.javascript">
    viewof password = html`<input placeholder="enter password">`
  </script>
  <script id="641" type="application/vnd.observable.javascript" pinned="">
    suite.test("Can use the AWS API based on user supplied password", () => {
      expect(testAWSAPICallResponse.Body.toString()).toBe("foo")
    })
  </script>
  <script id="663" type="application/vnd.observable.javascript">
    md`### Hashing algorithm`
  </script>
  <script id="412" type="application/vnd.observable.javascript" pinned="">
    encode = async (password, salt) => (await argon2.hash({
      pass: password, 
      salt: salt,
      time: 10, // rounds
      mem: 1024, // used memory, in KiB
      type: argon2.ArgonType.Argon2i // OWASP recommendation
    })).hashHex;
  </script>
  <script id="660" type="application/vnd.observable.javascript">
    md`## Implementation`
  </script>
  <script id="479" type="application/vnd.observable.javascript">
    md`### Serverside temporary credential generator

    - Matches password sent in header to stored one in notebook
    - returns temporary credentials if password matches`
  </script>
  <script id="44" type="application/vnd.observable.javascript" pinned="">
    credential_generator = async (req, res, context) => {
      res.header("Access-Control-Allow-Origin", "*"); 
      res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, authorization");
      res.header("Access-Control-Allow-Methods", "GET, OPTIONS");
      if (req.method === 'OPTIONS') res.status(200).end(); // Get CORS preflights ACKed ASAP

      // Password check
      if (await encode(req.headers['authorization'], salt) !== stored_password) {
        res.status(403).end()
      }

      // Fetch master AWS secrets from secret store. In the form "<CLIENT>,<SECRET>"
      const aws_creds = context.secrets['tomlarkworthy_aws'].split(",");
      AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
        masterCredentials: {
          accessKeyId: aws_creds[0],
          secretAccessKey: aws_creds[1]
        }
      });

      // Request a fresh token and return derived temporary credentials
      await AWS.config.credentials.refreshPromise()
      res.json({
        accessKeyId: AWS.config.credentials.accessKeyId,
        secretAccessKey: AWS.config.credentials.secretAccessKey,
        sessionToken: AWS.config.credentials.sessionToken
      });
    }
  </script>
  <script id="259" type="application/vnd.observable.javascript">
    md`## Deploy Token Generator
    Access to master credentials is acheived with [secret injection](https://observablehq.com/@tomlarkworthy/secret-manager) 
    `
  </script>
  <script id="41" type="application/vnd.observable.javascript">
    import { deploy } from "@endpointservices/webcode"
  </script>
  <script id="143" type="application/vnd.observable.javascript" pinned="">
    credentials = deploy("credentials", credential_generator, {
      secrets: ["tomlarkworthy_aws"] // Here is how master creds are injected
    })
  </script>
  <script id="476" type="application/vnd.observable.javascript">
    md`## Automatic CredFetcher using user supplied password
    We can wrap our token generating endpoint as a custom credential supplier for the AWS SDK, so it automatically refreshes.

    We place the endpoint url in a new variable, so that if someone forks this notebook, they still point to the original. Anybody can fork this notbook and work on it, as long as they know the password (_qwerty_ in this case).
    `
  </script>
  <script id="600" type="application/vnd.observable.javascript">
    credentials_copy = 'https://endpointservice.web.app/notebooks/@tomlarkworthy/aws-serverless-password/deployments/credentials/secrets/tomlarkworthy_aws'
  </script>
  <script id="561" type="application/vnd.observable.javascript" pinned="">
    CredFetcher = class CredFetcher extends AWS.Credentials {
      constructor() {
        super();
        this.expired = true;
      }
      needsRefresh() {
        return this.expired || Date() - this.lastRefresh > 15 * 60 * 1000; // Refresh every 15 mins
      }
      refresh(callback) {
        const self = this;
        fetch(credentials.href, {
          headers: { authorization: password } // User supplied password
        })
          .then((r) => r.json())
          .then((creds) => {
            this.accessKeyId = creds.accessKeyId;
            this.secretAccessKey = creds.secretAccessKey;
            this.sessionToken = creds.sessionToken;
            this.lastRefresh = Date();
            this.expired = false;
            callback();
          })
          .catch((err) => callback(err));
      }
    }
  </script>
  <script id="508" type="application/vnd.observable.javascript" pinned="">
    assign_creds = {
      AWS.config.credentials = new CredFetcher();
    }
  </script>
  <script id="511" type="application/vnd.observable.javascript">
    md`## Check we can read bucket
    Clientside and through the AWS API`
  </script>
  <script id="714" type="application/vnd.observable.javascript">
    md`

    AWS S3 SDK does not work until you enable a CORS policy in the bucket permissions

    ~~~js
    [
        {
            "AllowedHeaders": [
                "*"
            ],
            "AllowedMethods": [
                "GET",
                "HEAD"
            ],
            "AllowedOrigins": [
                "*"
            ],
            "ExposeHeaders": [],
            "MaxAgeSeconds": 3000
        }
    ]
    ~~~
    `
  </script>
  <script id="515" type="application/vnd.observable.javascript" pinned="">
    testAWSAPICallResponse = {
      assign_creds; // Make sure we retry after loading creds
      return new AWS.S3()
        .getObject({
          Bucket: "tomlarkworthy-access-aws",
          Key: "access-aws/example.txt"
        })
        .promise();
    }
  </script>
  <script id="547" type="application/vnd.observable.javascript" pinned="">
    suite.test("00: GetObject returns file containing 'foo'", () => {
      expect(testAWSAPICallResponse.Body.toString()).toBe("foo")
    })
  </script>
  <script id="632" type="application/vnd.observable.javascript">
    md`# ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³ ðŸ¥³`
  </script>
  <script id="154" type="application/vnd.observable.javascript">
    md `## Other Tests
    `
  </script>
  <script id="146" type="application/vnd.observable.javascript">
    import {createSuite, expect} from '@tomlarkworthy/testing'
  </script>
  <script id="150" type="application/vnd.observable.javascript">
    viewof suite = createSuite({
      timeout_ms: 10000
    })
  </script>
  <script id="158" type="application/vnd.observable.javascript">
    suite.test("01: GET with right password is 200", async () => {
      const response = await fetch(credentials.href, {
        headers: {
          "authorization": "qwerty"
        }
      });
      if (response.status !== 200) console.error(await response.text())
      expect(response.status).toBe(200);
    })
  </script>
  <script id="204" type="application/vnd.observable.javascript">
    suite.test("02: GET with wrong password is 403", async () => {
      const response = await fetch(credentials.href, {
        headers: {
          "authorization": "qwerty1"
        }
      });
      expect(response.status).toBe(403);
    })
  </script>
  <script id="718" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="720" type="application/vnd.observable.javascript" pinned="">
    footer
  </script>
</notebook>
