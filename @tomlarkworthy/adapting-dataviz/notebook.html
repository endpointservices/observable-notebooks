<!doctype html>
<notebook theme="air">
  <title>How to adapt other people's Dataviz</title>
  <script id="0" type="text/markdown">
    # How to adapt other people's Dataviz

    You might find something visually useful on [Observablehq.com](https://observablehq.com/) but often it's not written in the way you actually need. You *could* fork it, but often this causes a long-term maintenance burden as the two sources diverge. There are a few other options though

    [*juice*](https://observablehq.com/@tomlarkworthy/juice) can take any DataViz builder and add back-writability to any construction parameter. For example, making selection options dynamic. This is useful for converting static DataViz into real-time components, for instance.

    [*flowQueue*](https://observablehq.com/@tomlarkworthy/flow-queue) can transform any Dataflow expressed logic into a function, allowing you to convert from a single example into a functional builder pattern.

    I'll show you some examples of how to use these using DataViz by other people.
  </script>
  <script id="35" type="text/markdown">
    ## Making [@saneef](https://observablehq.com/@saneef)'s [radar-chart](https://observablehq.com/@saneef/radar-chart) back-writable

    Saneef has a nice radar chart component, but it doesn't work the way *I* want.

    1. to customize the data you need to fiddle with d3 in a fluent style, whereas I prefer data passed in as a parameter.
    2. the data is specified as a denormalized list, whereas I prefer as a single object.
    3. For my application the scores need to be [synchronized](https://observablehq.com/@observablehq/synchronized-inputs) from data loaded elsewhere, so I want to be able to synchronize the values dynamically.

    Fortunately, we can change all these opinions without asking [@saneef](https://observablehq.com/@saneef) to do anything!
  </script>
  <script id="46" type="application/vnd.observable.javascript">
    sampleRadarChart
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    import { sampleRadarChart, RadarChart } from "@saneef/radar-chart"
  </script>
  <script id="57" type="text/markdown">
    ### 1. Making a functional interface

    We can use normal programming abstraction to introduce a builder.
  </script>
  <script id="61" type="application/vnd.observable.javascript" pinned="">
    radarChart = ({
      data = [],
      width = 640,
      height = width / 1.333,
      margins = {
        top: 50,
        right: 50,
        bottom: 50,
        left: 50
      }
    } = {}) => {
      const svg = htl.svg`<svg width=${width} height=${height} viewbox="0 0 ${width} ${height}">`;
      const radarChart = new RadarChart(svg)
        .size(width, height)
        .margins(margins)
        .data(Object.entries(data).map(([key, val]) => ({ axis: key, value: val })))
        .field({ axis: "axis", value: "value" })
        .baselineValue(3)
        .curve(d3.curveLinearClosed)
        .render();

      return svg;
    }
  </script>
  <script id="66" type="text/markdown">
    So now we can use our builder *radarChart* to create multiple charta with different custom data. Cool.
  </script>
  <script id="68" type="text/html" pinned="">
    ${radarChart({
    width: 400,
    data: {"label 1": 1, "label 2":2, "cool": 4}
    })}

    ${radarChart({
    width: 400,
    data: {"something": 1, "cool":2, "cool": 4, "boo": 4, "baz": 3}
    })}
  </script>
  <script id="123" type="text/markdown">
    ### 2. Adding back-writability

    Many people do not add back-writability to their charts, if they had no need, why would they? Luckily we can add that by wrapping a static component functional builder with [juice](https://observablehq.com/@tomlarkworthy/juice), that creates a new builder that creates dynamic components.

    The juice configuration just needs to state which constructor arguments should be extracted as a JSON path and the name they become in the composite object.

    For my application, the radar chart labels are fixed, but the values should be back-writable. So I can create this new dynamic component like so:
  </script>
  <script id="140" type="application/vnd.observable.javascript">
    import { juice } from "@tomlarkworthy/juice"
  </script>
  <script id="138" type="application/vnd.observable.javascript" pinned="">
    personalityChart = juice(radarChart, {
      rationality: "[0].data['rationality']",
      empathy: "[0].data['empathy']",
      resourcefulness: "[0].data['resourcefulness']"
    })
  </script>
  <script id="192" type="text/markdown">
    So now I can can create the viz in exactly the same way, juice passes through all the existing parameters so nothing changes at construction time.
  </script>
  <script id="153" type="application/vnd.observable.javascript">
    viewof personality = personalityChart({
      width: 450,
      margins: { top: 100, left: 100, right: 100, bottom: 100 },
      data: {
        rationality: 4,
        empathy: 1,
        resourcefulness: 2
      }
    })
  </script>
  <script id="197" type="text/markdown">
    What changes is the return type, it now is a composite object with values for all the extra fields configured:
  </script>
  <script id="159" type="application/vnd.observable.javascript" pinned="">
    personality
  </script>
  <script id="200" type="text/markdown">
    But these fields are actually views themselves so you can do fine grained binding to them, such as attaching sliders or manually setting them
  </script>
  <script id="169" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.range([0, 5], {
        label: "rationality",
        step: 1
      }),
      viewof personality.rationality
    )
  </script>
  <script id="178" type="application/vnd.observable.javascript">
    Inputs.bind(
      Inputs.range([0, 5], {
        label: "empathy",
        step: 1
      }),
      viewof personality.empathy
    )
  </script>
  <script id="180" type="application/vnd.observable.javascript" pinned="">
    Inputs.bind(
      Inputs.range([0, 5], {
        label: "resourcefulness",
        step: 1
      }),
      viewof personality.resourcefulness
    )
  </script>
  <script id="202" type="text/markdown">
    With this technique we can do things far beyond what @saneef designed for.
  </script>
  <script id="209" type="application/vnd.observable.javascript">
    bigRadar = juice(
      radarChart,
      Object.fromEntries(
        Array.from({ length: 16 }).map((_, i) => [i, `[0].data[${i}]`])
      )
    )
  </script>
  <script id="268" type="application/vnd.observable.javascript">
    viewof run = Inputs.toggle({
      label: "run"
    })
  </script>
  <script id="217" type="application/vnd.observable.javascript">
    viewof vals = bigRadar({
      width: 500
    })
  </script>
  <script id="227" type="application/vnd.observable.javascript">
    updater = {
      while (run) {
        const ts = new Date() / 10000;
        viewof vals.value = Object.fromEntries(
          Array.from({ length: 16 }).map((_, i) => [
            i,
            5 * (Math.sin(ts * (i + 1)) + 1)
          ])
        );

        yield Promises.delay(100);
      }
    }
  </script>
  <script id="520" type="text/markdown">
    With back-writability in place we can compose hierarchically and use the component within a *single cell application* (see [scaling UI](https://observablehq.com/@tomlarkworthy/ui-development))
  </script>
  <script id="280" type="text/markdown">
    ## Creating a functional interface from one-off Dataflow DataViz

    It's quite common to see a nice DataViz in a narrative piece, but because the author was never designing for reuse, so it was developed as a one-off with no builder.

    For example, look at this beautiful comparison plot from [@observablehq/correlation-over-time](https://observablehq.com/@observablehq/correlation-over-time)
  </script>
  <script id="287" type="application/vnd.observable.javascript">
    import { comparisonPlot as comparisonPlotSample } from "@observablehq/correlation-over-time"
  </script>
  <script id="305" type="application/vnd.observable.javascript">
    comparisonPlotSample
  </script>
  <script id="314" type="text/markdown">
    Before we can start modding it with *juice*, we need to wrap it in a functional interface. We can dataflow-to-function conversion achieve using a *flowQueue*. First, we need to identify what upstream cells are needed to configure the viz. In this case **data**, **period** and **colorScheme**. We need to supply those at import time using the *with* clause. I find it useful during development to use Inputs to model these parameter cells because they can be set manually and programatically.
  </script>
  <script id="368" type="text/markdown">
    ### inputs cells
  </script>
  <script id="332" type="application/vnd.observable.javascript">
    viewof dataInputRaw = Inputs.textarea({ label: "data (as JSON)", minlength: 3 })
  </script>
  <script id="336" type="application/vnd.observable.javascript">
    data = eval(dataInputRaw)
  </script>
  <script id="347" type="application/vnd.observable.javascript">
    viewof period = Inputs.select(
      [
        "date",
        "hour",
        "day",
        "weekend",
        "week",
        "month",
        "quarter",
        "daytime",
        "feel"
      ],
      {
        label: "period"
      }
    )
  </script>
  <script id="342" type="application/vnd.observable.javascript">
    viewof colorScheme = Inputs.select(
      [
        "Cyclical, Nameable, High Perceptual Differentiation (rainbow)",
        "Dark to Light (magma)",
        "Optimized for Color Vision Deficiency (cividis)",
        "Diverging (RdYlBu)"
      ],
      {
        label: "colorScheme"
      }
    )
  </script>
  <script id="370" type="text/markdown">
    ### import the output cell
  </script>
  <script id="361" type="text/markdown">
    The inputs are substituted at import time within a *with* clause, so that the output cell **comparisonPlot** is now affected by their changes. 
  </script>
  <script id="324" type="application/vnd.observable.javascript" pinned="">
    import { comparisonPlot } with {
      data,
      period,
      colorScheme
    } from "@observablehq/correlation-over-time"
  </script>
  <script id="375" type="text/markdown">
    ### Wrap with flowQueue

    We need a flowQueue to helps us manage the underlying dataflow logic.
  </script>
  <script id="382" type="application/vnd.observable.javascript">
    import { flowQueue } from "@tomlarkworthy/flow-queue"
  </script>
  <script id="379" type="application/vnd.observable.javascript" pinned="">
    viewof args = flowQueue()
  </script>
  <script id="415" type="application/vnd.observable.javascript" pinned="">
    args
  </script>
  <script id="408" type="text/markdown">
    The active task in the flowQueue will be called args. When that changes we need to push its values into our input cells, and tell them to update
  </script>
  <script id="411" type="application/vnd.observable.javascript" pinned="">
    loadArgs = {
      viewof dataInputRaw.value = JSON.stringify(args.data);
      viewof period.value = args.period;
      viewof colorScheme.value = args.colorScheme;

      viewof dataInputRaw.dispatchEvent(new Event("input", { bubbles: true }));
      viewof period.dispatchEvent(new Event("input", { bubbles: true }));
      viewof colorScheme.dispatchEvent(new Event("input", { bubbles: true }));
    }
  </script>
  <script id="417" type="text/markdown">
    We expect that changing the inputs will cause our output cell (`comparisonPlot`) to update. After it is updated we want to consider the tasks complete and return the value from the `flowQueue`. So we create a cell triggered by c`omparisonPlot` dataflow to resolve the `flowQueue` tasks
  </script>
  <script id="422" type="application/vnd.observable.javascript" pinned="">
    resolveTask = {
      viewof args.resolve(comparisonPlot);
    }
  </script>
  <script id="425" type="text/markdown">
    To load a task we send to the *flowQueue*. So here we can create our functional interface.
  </script>
  <script id="428" type="application/vnd.observable.javascript" pinned="">
    comparisonPlotFn = async ({
      data = [],
      period = "month",
      colorScheme = "Dark to Light (magma)"
    } = {}) =>
      await viewof args.send({
        data,
        period,
        colorScheme
      })
  </script>
  <script id="493" type="text/markdown">
    So now we can create (multiple) diagrams just by calling a builder function, despite the implementation being written in the dataflow style, and by a different person!
  </script>
  <script id="433" type="application/vnd.observable.javascript" pinned="">
    html`${await comparisonPlotFn({
      period: "hour",
      data: myData
    })}
    ${await comparisonPlotFn({
      period: "day",
      data: myData
    })}
    `
  </script>
  <script id="469" type="application/vnd.observable.javascript">
    myData = [
      {
        date: "2019-09-27T01:00:00.000Z",
        demand: 60870,
        hour: 20,
        daytime: 1,
        day: 3,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 31.1
      },
      {
        date: "2019-09-27T02:00:00.000Z",
        demand: 58914,
        hour: 21,
        daytime: 1,
        day: 3,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 30
      },
      {
        date: "2019-09-27T03:00:00.000Z",
        demand: 55656,
        hour: 22,
        daytime: 1,
        day: 3,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 29.4
      },
      {
        date: "2019-09-27T04:00:00.000Z",
        demand: 51579,
        hour: 23,
        daytime: 1,
        day: 3,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 29.4
      },
      {
        date: "2019-09-27T05:00:00.000Z",
        demand: 47630,
        hour: 0,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 28.9
      },
      {
        date: "2019-09-27T06:00:00.000Z",
        demand: 44379,
        hour: 1,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 27.8
      },
      {
        date: "2019-09-27T07:00:00.000Z",
        demand: 42075,
        hour: 2,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 27.2
      },
      {
        date: "2019-09-27T08:00:00.000Z",
        demand: 40525,
        hour: 3,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 26.7
      },
      {
        date: "2019-09-27T09:00:00.000Z",
        demand: 39477,
        hour: 4,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 2,
        temp: 25.6
      },
      {
        date: "2019-09-27T10:00:00.000Z",
        demand: 39391,
        hour: 5,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 1,
        temp: 25
      },
      {
        date: "2019-09-27T11:00:00.000Z",
        demand: 40767,
        hour: 6,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 1,
        temp: 23.9
      },
      {
        date: "2019-09-27T12:00:00.000Z",
        demand: 43381,
        hour: 7,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 1,
        temp: 23.3
      },
      {
        date: "2019-09-27T13:00:00.000Z",
        demand: 44128,
        hour: 8,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 1,
        temp: 23.9
      },
      {
        date: "2019-09-27T14:00:00.000Z",
        demand: 45056,
        hour: 9,
        daytime: 2,
        day: 4,
        weekend: 0,
        week: 39,
        month: 8,
        quarter: 2,
        feel: 1,
        temp: 25
      }
    ]
  </script>
  <script id="525" type="application/vnd.observable.javascript">
    import {footer} from '@endpointservices/footer-with-backups'
  </script>
  <script id="528" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
