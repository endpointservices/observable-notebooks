<!doctype html>
<notebook theme="air">
  <title>Animated Wormhole with frame capture</title>
  <script id="0" type="application/vnd.observable.javascript">
    md`# Animated Wormhole with frame capture`
  </script>
  <script id="29" type="application/vnd.observable.javascript">
    import {slider} from "@jashkenas/inputs"
  </script>
  <script id="969" type="application/vnd.observable.javascript">
    import {color} from "@jashkenas/inputs"
  </script>
  <script id="963" type="application/vnd.observable.javascript">
    import {button} from "@jashkenas/inputs"

  </script>
  <script id="1087" type="application/vnd.observable.javascript">
    import {checkbox} from "@jashkenas/inputs"

  </script>
  <script id="31" type="application/vnd.observable.javascript">
    viewof canvas_w = slider({
      min: 1,
      max: 1024,
      step: 1,
      value: 400,
      format: ",",
      description:
        "Width of canvas"
    })
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    viewof canvas_h = slider({
      min: 1,
      max: 1024,
      step: 1,
      value: 600,
      format: ",",
      description:
        "Height of canvas"
    })
  </script>
  <script id="300" type="application/vnd.observable.javascript">
    viewof animated_wormhole = {
      var ctx = DOM.context2d(canvas_w, canvas_h);
      ctx.strokeStyle = foreground;
      ctx.lineCap = "round"; 

      while (true) {
        wormholeFrame(ctx, Date.now());
        yield ctx.canvas;
      }  
    }
  </script>
  <script id="943" type="application/vnd.observable.javascript">
    wormholeFrame = (ctx, time) => {

      function unitToScreen(unitCoords) {
        return [0.5 * canvas_w + 0.5 * canvas_w * unitCoords[0],
                0.5 * canvas_h + 0.5 * canvas_h * unitCoords[1]];
      }

      function t_period(per_sec) {
        var per_millis = per_sec * 1000;
        return (time % (per_millis)) / per_millis;
      }

      function magnitude(vec2) {
        return Math.sqrt(vec2[0]*vec2[0] + vec2[1]*vec2[1]);
      }

      function wormDepth(vec2) {
        return Math.max(1.0 / (magnitude(vec2) + wormhole_width), 1);
      }

      function wormDeform(vec2) {
        var depth = wormDepth(vec2);
        return [
          (vec2[0]) * scale_x,
          (vec2[1] + scale_y_inv * depth) * scale_y + offset_y,
        ];
      };

      const gridStep = 2.0 / lines;
      const microStep = gridStep / 5;

      ctx.fillStyle = "black";
      ctx.fillRect(0,0, canvas_w, canvas_h);

      const dead_zone = 1;
      ctx.fillStyle = foreground;
      ctx.lineWidth = 1;


      // Grid between -1 and 1
      if (decoration) {
        for (var i = -1; i <= 1; i+=gridStep) {
          for (var j = -1; j <= 1; j+=gridStep) {
            for (var im = 0; im < gridStep; im += microStep) {
              if (magnitude([i + im, j]) < dead_zone) continue;
              ctx.beginPath();
              ctx.moveTo.apply(ctx, unitToScreen(wormDeform([i + im - microStep, j])));
              ctx.lineTo.apply(ctx, unitToScreen(wormDeform([i + im, j])));
              ctx.stroke();
            }
            for (var jm = 0; jm < gridStep; jm += microStep) {
              if (magnitude([i, j + jm]) < dead_zone) continue;
              ctx.beginPath();
              ctx.moveTo.apply(ctx, unitToScreen(wormDeform([i, j + jm - microStep])));
              ctx.lineTo.apply(ctx, unitToScreen(wormDeform([i, j + jm])));
              ctx.stroke();
            }
          } 
        }
      }


      // Draw fixed framing the wormhole
      ctx.beginPath();
      var radius = 1;
      var center = [0, 0];
      for (var theta = 0; theta <= 2 * Math.PI + 0.1; theta += 0.1) {
        ctx.lineTo.apply(ctx, unitToScreen(wormDeform([
          radius * Math.cos(theta) + center[0],
          radius * Math.sin(theta) + center[1]
        ])));
      }
      ctx.stroke();

      // Draw animated circles around the epicenter
      for (var i = -1; i < 0 - gridStep; i += gridStep) { 
        ctx.beginPath();
        var radius = i + t_period(1) * gridStep;
        var center = [0, 0];
        for (var theta = 0; theta <= 2 * Math.PI + 0.1; theta += 0.1) {
          ctx.lineTo.apply(ctx, unitToScreen(wormDeform([
            radius * Math.cos(theta) + center[0],
            radius * Math.sin(theta) + center[1]
          ])));
        }
        ctx.stroke();
      }

      // Draw radial arcs outwards around the epicenter
      for (var theta = 0; theta <= 2 * Math.PI; theta += 2 * Math.PI / arcs) {   
        var center = [0, 0];
        ctx.beginPath();
        for (var i = -1; i < 0; i += gridStep) { 
          var radius = i;
          ctx.lineTo.apply(ctx, unitToScreen(wormDeform([
            radius * Math.cos(theta) + center[0],
            radius * Math.sin(theta) + center[1]
          ])));
        }
        ctx.stroke();
      }

      // We will also some circles translating near the wormhole

      if (decoration) {
        for (var i = 0; i < 10; i++) {
          ctx.beginPath();
          var center = [
            Math.sin(time / (501 + i)),
            Math.sin(time / (601 + i))          
          ];
          for (var theta = 0; theta <= 2 * Math.PI; theta += 0.05) {
            ctx.lineTo.apply(ctx, unitToScreen(wormDeform([
              0.1 * Math.cos(theta) + center[0],
              0.1 * Math.sin(theta) + center[1]
            ])));
          }
          ctx.fill();
        }
      }
    }
  </script>
  <script id="104" type="application/vnd.observable.javascript">
    viewof foreground = color({
      value: "#ff8300",
      title: "Foreground Color"
    })
  </script>
  <script id="1103" type="application/vnd.observable.javascript">
    viewof decoration = checkbox({
      description: "Turn on extras",
      options: [{ value: "toggle", label: "On" }],
      value: ["toggle"]
    })
  </script>
  <script id="321" type="application/vnd.observable.javascript">
    viewof lines = slider({
      min: 0,
      max: 64,
      step: 1,
      value: 14})
  </script>
  <script id="888" type="application/vnd.observable.javascript">
    viewof arcs = slider({
      min: 0,
      max: 32,
      step: 1,
      value: 10})
  </script>
  <script id="587" type="application/vnd.observable.javascript">
    viewof scale_x = slider({
      min: 0,
      max: 0.75,
      value: 1})
  </script>
  <script id="599" type="application/vnd.observable.javascript">
    viewof scale_y = slider({
      min: 0,
      max: 1,
      value: 0.5})
  </script>
  <script id="609" type="application/vnd.observable.javascript">
    viewof scale_y_inv = slider({
      min: -2,
      max: 2,
      value: .9})
  </script>
  <script id="615" type="application/vnd.observable.javascript">
    viewof offset_y = slider({
      min: -1,
      max: 1,
      value: -.9})
  </script>
  <script id="937" type="application/vnd.observable.javascript">
    viewof wormhole_width = slider({
      min: -0.5,
      max: 0.5,
      value: 0.3})
  </script>
  <script id="1108" type="application/vnd.observable.javascript">
    md`## Render frames to a zip`
  </script>
  <script id="1085" type="application/vnd.observable.javascript">
    viewof capture = checkbox({
      description: "Turn on frame capture",
      options: [{ value: "toggle", label: "On" }]
    })
  </script>
  <script id="953" type="application/vnd.observable.javascript">
    viewof render_fps = slider({
      min: 0,
      max: 1024,
      steps:1,
      value: 30})
  </script>
  <script id="978" type="application/vnd.observable.javascript">
    viewof render_secs = slider({
      min: 0,
      max: 60,
      steps:1,
      value: 1})
  </script>
  <script id="960" type="application/vnd.observable.javascript">
    preview = {
      if (!capture) return;
      var ctx = DOM.context2d(canvas_w, canvas_h);
      ctx.strokeStyle = foreground;
      ctx.lineCap = "round"; 

      const tmpRenders = [];
      for (var frame = 0; frame < render_fps * render_secs; frame++) {
        wormholeFrame(ctx, (frame / render_fps) * 1000);
        var canvas = ctx.canvas;
        tmpRenders.push(canvas.toDataURL());
        yield canvas;
      }
      mutable renders = tmpRenders;
    }
  </script>
  <script id="986" type="application/vnd.observable.javascript">
    mutable renders = []
  </script>
  <script id="1067" type="application/vnd.observable.javascript">
    JSZip = require('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js')
  </script>
  <script id="1000" type="application/vnd.observable.javascript">
    frames = {
      if (!renders || renders.length == 0) return;
      function id(index) {
        var str = "" + index;
        return ('0000'+str).substring(str.length);
      }

      // https://stackoverflow.com/a/37138144
      function dataURLtoBlob(dataurl) {
          const arr = dataurl.split(',');
          const mime = arr[0].match(/:(.*?);/)[1];
          const bstr = atob(arr[1]);
          var n = bstr.length;
          const u8arr = new Uint8Array(n);
          while(n--){
              u8arr[n] = bstr.charCodeAt(n);
          }
          return new Blob([u8arr], {type:mime});
      }

      var zip = new JSZip();

      for (var frame = 0; frame < renders.length; frame++) {
        // https://stackoverflow.com/a/37138144
        const imgData = renders[frame];
        const strDataURI = imgData.substr(22, imgData.length);
        const blob = dataURLtoBlob(imgData);
        const objurl = URL.createObjectURL(blob);

        zip.file("frame-" + id(frame) + ".png", strDataURI, {base64: true});
      }

      // Generate the zip file asynchronously
      return zip.generateAsync({type:"blob"})
        .then(function(content) {
        // Force down of the Zip file
        const zipUrl = URL.createObjectURL(content);
        return html`<a
             href=${zipUrl}
             download="frames.zip">
            frames.zip
           </a><br>`
      });
    }
  </script>
  <script id="1113" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="1131" type="application/vnd.observable.javascript">
    footer
  </script>
</notebook>
