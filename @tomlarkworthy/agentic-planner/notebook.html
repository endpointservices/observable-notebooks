<!doctype html>
<notebook theme="air">
  <title>Roboco-op 3.0: Agentic Notebook Assistent</title>
  <script id="0" type="text/markdown">
    # Roboco-op 3.0: Agentic Notebook Assistent

  </script>
  <script id="2031" type="application/vnd.observable.javascript">
    ui = {
      endpoint;
      keepalive(myModule, "initial_response");
      const ui = htl.html`<div>
      <h2>Robocoop 3.0</h2>
      ${reversibleAttach(ui_attached, style)}
      ${reversibleAttach(ui_attached, viewof endpoint)}
      ${
        viewof endpoint.value !=
        "https://openai-proxy.endpointservices.workers.dev/v1/responses"
          ? reversibleAttach(ui_attached, viewof OPENAI_API_KEY)
          : undefined
      }
      ${reversibleAttach(ui_attached, viewof model)}
      ${reversibleAttach(ui_attached, viewof active_tools)}
      ${reversibleAttach(ui_attached, viewof workingModule)}
      ${reversibleAttach(ui_attached, viewof prompt_example)}
      ${reversibleAttach(ui_attached, viewof prompt)}
      ${reversibleAttach(ui_attached, viewof yolo)}
      ${reversibleAttach(ui_attached, viewof clear)}
      <div style="max-height: 1024px; overflow: auto">
        ${reversibleAttach(ui_attached, viewof history_ui)}
      </div>
      ${reversibleAttach(ui_attached, viewof undo_last)}
    </div>`;

      setTimeout(() => {
        viewof history_ui.parentNode.scrollTop =
          viewof history_ui.parentNode.scrollHeight;
      }, 0);
      return ui;
    }
  </script>
  <script id="2855" type="application/vnd.observable.javascript">
    history
  </script>
  <script id="2881" type="text/markdown" pinned="">
    ```js
    import { ui, expect} from "@tomlarkworthy/agentic-planner"
    ```
  </script>
  <script id="2254" type="text/markdown">
    ## About

    Roboco-op 2.0 runs inside the notebook along side userspace code. This means it can **read program values** and **write new cells**. It has the dataflow dependancy graph at hand which it uses to gather context. The notebook environment is reactive, so modifications are applied immediately and cascade to only the cells downstream of dataflow. The agent can write new tools, test its code, and draw diagrams. 

    This is a better workflow for agents than mainstream development tooling, where code and program are separate and programs must be repeatedly restarted from scratch. In Roboco-op the agent is reactively syncronized to the running program state and able to modify code in-flight.

    Inline unit tests update reactively too, and the notebook supports data-viz out-of-the-box. When running on [ObservableHQ.com](https://observablehq.com/@tomlarkworthy/agentic-planner) the cells it creates are not visible, but they exist and can be depended on, when running on [Lopecode](https://github.com/tomlarkworthy/lopecode) changes are visible. 
  </script>
  <script id="2797" type="text/markdown">
    ## TDD
  </script>
  <script id="1217" type="text/markdown">
    ## Failing Tests
  </script>
  <script id="862" type="application/vnd.observable.javascript">
    viewof failing_tests = tests({
      filter: (test) => test.computed && test.state == "rejected"
    })
  </script>
  <script id="2799" type="application/vnd.observable.javascript">
    tests_module = viewof currentModules.value.get(myModule)
  </script>
  <script id="1566" type="text/markdown">
    ## Architecture
  </script>
  <script id="12" type="text/markdown">
    Inspired by [Cline](https://github.com/cline/cline)
  </script>
  <script id="1462" type="text/markdown">
    The design is extremely simple. The bot is [forced to pick a tool each iteration](https://community.openai.com/t/new-api-feature-forcing-function-calling-via-tool-choice-required/731488). We have two lifecycle tools, `attempt_completion` or `ask_followup_question`, and several task tools. The bot then just keeps calling the tools, and the tools execute and repost to the API and the bot calls a new tool. The lifecycle tools are special cases that hold up the control flow for human interaction.

    ${mermaid`flowchart TD
        Start([Prompt])
        End([End])
        Start --> Pick[LLM call]
        Pick -- "function_call" --> Type{Tool type?}

        Type -- "Lifecycle tool" --> Human

        Human --> End
        Human --> Respond

        Type -- "Task tool" --> Respond

        Respond -- "function_output" --> Pick



    `}
  </script>
  <script id="2012" type="text/markdown">
    ## TODO

    - MCP integration
    - Reading cells as images
    - FileAttachment support
    - Fix main issue with tests
  </script>
  <script id="2848" type="application/vnd.observable.javascript">
    import {exporter} from '@tomlarkworthy/exporter'
  </script>
  <script id="2851" type="application/vnd.observable.javascript">
    exporter()
  </script>
  <script id="395" type="text/markdown">
    ## Interface
  </script>
  <script id="2023" type="application/vnd.observable.javascript">
    import { reversibleAttach } from "@tomlarkworthy/reversible-attachment"
  </script>
  <script id="2026" type="application/vnd.observable.javascript">
    viewof ui_attached = Inputs.toggle({
      label: "ui_attached",
      value: true
    })
  </script>
  <script id="46" type="text/html">
    <style>
      .plan div {
        font-size: 1em;
        padding: 0.25rem;
        border: black solid 1px;
      }
    </style>
  </script>
  <script id="2290" type="application/vnd.observable.javascript">
    viewof endpoint = Inputs.bind(
      Inputs.select(
        new Map([
          [
            "demo",
            "https://openai-proxy.endpointservices.workers.dev/v1/responses"
          ],
          ["OpenAI", "https://api.openai.com/v1/responses"]
        ]),
        {
          label: "OpenAI API URL"
        }
      ),
      localStorageView("OPENAI_API_URL", {
        defaultValue:
          "https://openai-proxy.endpointservices.workers.dev/v1/responses"
      })
    )
  </script>
  <script id="1994" type="application/vnd.observable.javascript">
    viewof OPENAI_API_KEY = Inputs.bind(
      Inputs.password({
        label: "OPENAI_API_KEY",
        placeholder: "paste openAI key here"
      }),
      localStorageView("OPENAI_API_KEY")
    )
  </script>
  <script id="1181" type="application/vnd.observable.javascript">
    viewof model = Inputs.select(reasoning_models, { label: "model" })
  </script>
  <script id="2699" type="application/vnd.observable.javascript">
    viewof active_tools = Inputs.select(new Map(tools.map((t) => [t.name, t])), {
      multiple: true,
      value: tools,
      label: "active tools"
    })
  </script>
  <script id="768" type="application/vnd.observable.javascript">
    viewof prompt_example = Inputs.select(prompts, { label: "example prompts" })
  </script>
  <script id="2756" type="application/vnd.observable.javascript">
    viewof workingModule = Inputs.select(
      [...currentModules.values()].map((m) => m.name),
      {
        label: "working module"
      }
    )
  </script>
  <script id="1199" type="application/vnd.observable.javascript">
    viewof prompt = Inputs.textarea({
      label: "prompt",
      submit: "go",
      value: prompt_example,
      minlength: 1
    })
  </script>
  <script id="575" type="application/vnd.observable.javascript">
    viewof yolo = Inputs.toggle({ label: "YOLO", value: true })
  </script>
  <script id="2015" type="application/vnd.observable.javascript">
    viewof clear = Inputs.button("clear", {
      reduce: () => {
        viewof calls.value = [];
        viewof calls.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="248" type="application/vnd.observable.javascript">
    viewof history_ui = plan(calls)
  </script>
  <script id="674" type="application/vnd.observable.javascript">
    viewof undo_last = Inputs.button("undo last", {
      reduce: () => {
        viewof calls.value = viewof calls.value.slice(0, -2);
        viewof calls.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="213" type="text/markdown">
    ## Tools
  </script>
  <script id="1285" type="application/vnd.observable.javascript">
    tools = [
      //evalJavaScriptTool,
      attempt_completionTool,
      ask_followup_questionTool,
      list_modulesTool,
      list_cellsTool,
      describe_cellsTool,
      create_cellTool,
      replace_cellTool,
      peek_variableTool,
      search_cellsTool
    ]
  </script>
  <script id="215" type="text/markdown">
    #### attempt_completion


  </script>
  <script id="222" type="application/vnd.observable.javascript">
    attempt_completionTool = ({
      type: "function",
      name: "attempt_completion",
      strict: true,
      description:
        "Use this tool to present the final *validated* conclusion to the user.",
      parameters: {
        type: "object",
        properties: {
          result: {
            type: "string",
            description:
              "The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don't end your result with questions or offers for further assistance."
          }
        },
        required: ["result"],
        additionalProperties: false
      },
      execute: async ({ result } = {}) => viewof completionFeedback.value
    })
  </script>
  <script id="362" type="application/vnd.observable.javascript">
    viewof completionFeedback = Inputs.textarea({
      placeholder: "add feedback to continue",
      submit: "feedback"
    })
  </script>
  <script id="344" type="application/vnd.observable.javascript">
    attempCompletetionDialog = (calls_view, latest, tool) => {
      viewof completionFeedback.value = "";
      const listener = async (event) => {
        viewof completionFeedback.removeEventListener("input", listener);
        const response = await runTools(latest);
        calls_view.value.push(response);
        calls_view.dispatchEvent(new Event("input"));
      };
      viewof completionFeedback.addEventListener("input", listener);
      return htl.html`
      ${md`${tool.arguments.result}`}
      ${viewof completionFeedback}
    `;
    }
  </script>
  <script id="292" type="text/markdown">
    #### ask_followup_question 
  </script>
  <script id="296" type="application/vnd.observable.javascript">
    ask_followup_questionTool = ({
      type: "function",
      name: "ask_followup_question",
      strict: true,
      description:
        " Ask the user a question to gather additional information needed to complete the task. This tool should be used when you encounter ambiguities, need clarification, or require more details to proceed effectively. It allows for interactive problem-solving by enabling direct communication with the user. Use this tool judiciously to maintain a balance between gathering necessary information and avoiding excessive back-and-forth.",
      parameters: {
        type: "object",
        properties: {
          question: {
            type: "string",
            description:
              "The question to ask the user. This should be a clear, specific question that addresses the information you need."
          }
        },
        required: ["question"],
        additionalProperties: false
      },
      execute: async ({ result } = {}) => viewof followUpResponse.value
    })
  </script>
  <script id="376" type="application/vnd.observable.javascript">
    viewof followUpResponse = Inputs.textarea({
      placeholder: "enter your response",
      submit: "respond"
    })
  </script>
  <script id="321" type="application/vnd.observable.javascript">
    followUpQuestionDialog = (calls_view, latest, tool) => {
      viewof followUpResponse.value = "";
      const listener = async (event) => {
        viewof followUpResponse.removeEventListener("input", listener);
        const response = await runTools(latest);
        calls_view.value.push(response);
        calls_view.dispatchEvent(new Event("input"));
      };
      viewof followUpResponse.addEventListener("input", listener);
      return htl.html`
      ${md`${tool.arguments.question}`}
      ${viewof followUpResponse}
    `;
    }
  </script>
  <script id="220" type="text/markdown">
    #### evalJavaScriptTool
  </script>
  <script id="218" type="application/vnd.observable.javascript">
    evalJavaScriptTool
  </script>
  <script id="397" type="text/markdown">
    #### list_modules 
  </script>
  <script id="412" type="application/vnd.observable.javascript">
    import { moduleMap, viewof currentModules } from "@tomlarkworthy/module-map"
  </script>
  <script id="402" type="application/vnd.observable.javascript">
    list_modulesTool = ({
      type: "function",
      name: "list_modules",
      strict: true,
      description:
        "Use this to discover all loaded modules in the runtime. Modules are notebooks and contains cells and file attachments",
      parameters: {
        type: "object",
        properties: {},
        required: [],
        additionalProperties: false
      },
      execute: async ({ result } = {}) => runtimeSummary()
    })
  </script>
  <script id="410" type="application/vnd.observable.javascript">
    runtimeSummary = async () => {
      const moduleMap = await getModules();
      const modules = [...moduleMap.values()].sort();
      return `### modules\n${modules
        .map(
          (module) => `- ${module.name}${
            module?.dependsOn?.length > 0
              ? `\n  - dependsOn\n${
                  module.dependsOn &&
                  module.dependsOn.map((d) => `    - ${d}`).join("\n")
                }`
              : ""
          }
    `
        )
        .join("")}`;
    }
  </script>
  <script id="471" type="application/vnd.observable.javascript">
    test_list_modulesTool = md`${await list_modulesTool.execute()}`
  </script>
  <script id="445" type="text/markdown">
    #### list_cells
  </script>
  <script id="447" type="application/vnd.observable.javascript">
    list_cellsTool = ({
      type: "function",
      name: "list_cells",
      strict: true,
      description:
        "Use this list the cells in a module. They are listed in the order they appear in a notebook. Adjacent cells are likely to be semantically related, but functionally ordering does not matter. Anonymous cells could be documentation for a nearby code cell.",
      parameters: {
        type: "object",
        properties: {
          module_name: {
            type: "string"
          }
        },
        required: ["module_name"],
        additionalProperties: false
      },
      execute: async ({ module_name } = {}) => {
        const module = await getModule(module_name);
        if (!module) return `Error: module ${module_name} not found`;
        const cells = await cellMapCompat(module.module);

        return `${module_name} contents:\n
    ${[...cells.entries()]
      .map(([name, variables]) => summarizeCell({ name, variables }))
      .join("")}
        `;

        return cells;
      }
    })
  </script>
  <script id="461" type="application/vnd.observable.javascript">
    test_list_cellsTool = list_cellsTool.execute({
      module_name: "main"
    })
  </script>
  <script id="2613" type="text/markdown">
    ### search_cells
  </script>
  <script id="2621" type="application/vnd.observable.javascript" pinned="">
    search_cellsTool = ({
      type: "function",
      name: "search_cells",
      strict: true,
      description:
        "Search for cells in the runtime module whose source code matches a regular expression. Returns up to 20 matching cells",
      parameters: {
        type: "object",
        properties: {
          module_name: { type: ["string", "null"] },
          pattern: { type: "string" },
          flags: { type: "string" }
        },
        required: ["module_name", "pattern", "flags"],
        additionalProperties: false
      },
      execute: async ({ module_name, pattern, flags = "" } = {}) => {
        const modules = module_name
          ? [await getModule(module_name)]
          : [...(await moduleMap(runtime)).values()];

        if (!module_name && !modules[0])
          return "Error: module " + module_name + " not found";

        const results = [];
        let regex;
        try {
          regex = new RegExp(pattern, flags);
        } catch (err) {
          return "Error: invalid regular expression: " + err.message;
        }

        for (let module of modules) {
          if (results.length >= 20) break;
          const cells = await cellMapCompat(module.module);

          for (const [cell_name, variables] of cells.entries()) {
            if (results.length >= 20) break;
            const source = await decompile(variables);
            if (regex.test(source)) {
              results.push({
                module,
                cell_name,
                variables,
                source
              });
            }
          }
        }
        if (results.length === 0)
          return (
            "No cells matching /" +
            pattern +
            "/" +
            flags +
            " in module " +
            module_name
          );
        return (
          "Cells matching /" +
          pattern +
          "/" +
          flags +
          " in module " +
          module_name +
          " (up to 20):\n" +
          (
            await Promise.all(
              results.map((n) =>
                cellDescription(n.module.name, n.cell_name, n.variables, n.source)
              )
            )
          ).join("\n")
        );
      }
    })
  </script>
  <script id="2655" type="application/vnd.observable.javascript">
    viewof searchPattern = Inputs.text({
      label: "search pattern",
      value: "^test_"
    })
  </script>
  <script id="2618" type="application/vnd.observable.javascript">
    test_search_for_cell_digit_name = {
      debugger;
      const result = search_cellsTool.execute({
        module_name: null,
        pattern: searchPattern,
        flags: ""
      });
      return result;
    }
  </script>
  <script id="457" type="application/vnd.observable.javascript">
    import {
      decompile,
      compile,
      cellMap
    } from "@tomlarkworthy/observablejs-toolchain"
  </script>
  <script id="2862" type="application/vnd.observable.javascript">
    import { cellMapCompat } from "@tomlarkworthy/cell-map"
  </script>
  <script id="504" type="application/vnd.observable.javascript">
    summarizeCell = ({ name, variables } = {}) => {
      const definitionSize = variables.reduce(
        (total, variable) => variable._definition.toString().length,
        0
      );
      return `- ${typeof name == "string" ? name : `${name}`}
      - inputs: [${variables[0]._inputs.map((i) => i._name)}]
      - reachable: ${variables[0]._reachable}
      - definition size: ${definitionSize} bytes
    `;
    }
  </script>
  <script id="535" type="text/markdown">
    #### describe_cells
  </script>
  <script id="2636" type="application/vnd.observable.javascript">
    cellDescription = async (module_name, cell_name, variables, source) => {
      return `#### module '${module_name}' cell '${
        variables[0]._name || cell_name
      }':
    - inputs: [${variables[0]._inputs.map((i) => i._name)}]
    - outputs: [${[...variables[0]._outputs].map((i) => i._name)}]
    - reachable: ${variables[0]._reachable}${
        variables[0]._reachable
          ? `\n- value: ${await summarizeVariable(
              variables[0]._name,
              variables[0],
              {
                max_size: 1
              }
            )}\n`
          : ""
      }
    <code>
    ${source}
    </code>
    `;
    }
  </script>
  <script id="539" type="application/vnd.observable.javascript">
    describe_cellsTool = ({
      type: "function",
      name: "describe_cells",
      strict: true,
      description:
        "Describes cells, their inputs cells and their output cells, and their definition in a <code>...</code> block.",
      parameters: {
        type: "object",
        properties: {
          module_name: {
            type: "string"
          },
          cell_names: {
            type: ["array"],
            items: {
              type: ["string", "number"]
            }
          }
        },
        required: ["module_name", "cell_names"],
        additionalProperties: false
      },
      execute: async ({ module_name, cell_names } = {}) => {
        const module = await getModule(module_name);
        if (!module) return `Error: module ${module_name} not found`;
        const cells = await cellMapCompat(module.module);

        return `### module ${module_name}
    ${(
      await Promise.all(
        cell_names.map(async (cell_name) => {
          if (!cells.has(cell_name))
            return `Error: cell ${cell_name} not found in module ${module_name}`;
          const variables = cells.get(cell_name);
          const source = await decompile(variables);
          return cellDescription(module_name, cell_name, variables, source);
        })
      )
    ).join("\n")}

    `;
      }
    })
  </script>
  <script id="543" type="application/vnd.observable.javascript">
    test_describe_cellsTool = describe_cellsTool.execute({
      module_name: "@tomlarkworthy/module-map",
      cell_names: [0, "moduleMap"]
    })
  </script>
  <script id="614" type="text/markdown">
    ### create_cell
  </script>
  <script id="689" type="application/vnd.observable.javascript">
    create_cellTool = ({
      type: "function",
      name: "create_cell",
      strict: true,
      description:
        "Add cells to the runtime. Optionally specify after_cell to insert after an existing cell.",
      parameters: {
        type: "object",
        properties: {
          module_name: { type: "string" },
          source: { type: "string" },
          after_cell: { type: ["integer", "string", "null"] }
        },
        required: ["module_name", "source", "after_cell"],
        additionalProperties: false
      },
      execute: async ({ module_name, source, after_cell } = {}) => {
        const module = await getModule(module_name);
        if (!module) return `Error: module ${module_name} not found`;
        let idx = -1;
        if (after_cell) {
          const cells = await cellMapCompat(module.module);
          if (!cells.has(after_cell))
            return `Error: cell '${after_cell}' not found in module '${module_name}'`;
          const target = cells.get(after_cell).at(-1);
          idx = [...runtime._variables].findIndex((v) => v === target) + 1;
          if (idx < 0) return `Error: could not locate target cell '${after_cell}'`;
        }
        let variables;
        try {
          variables = createCell({
            module: module.module,
            source
          });
        } catch (err) {
          return `Error: ${err?.message || err}`;
        }
        if (after_cell) {
          variables.forEach((v, i) =>
            repositionSetElement(runtime._variables, v, idx + i)
          );
        }
        return summarizeVariable(variables[0]._name, variables[0]);
      }
    })
  </script>
  <script id="697" type="application/vnd.observable.javascript">
    test_create_cellTool = {
      return create_cellTool.execute({
        module_name: "main",
        source: "akljlksda = {}"
      });
    }
  </script>
  <script id="1301" type="application/vnd.observable.javascript">
    test_create_cell_dupe = create_cellTool.execute({
      module_name: "main",
      source: "createCell = 54"
    })
  </script>
  <script id="2279" type="application/vnd.observable.javascript">
    test_create_cell_after = create_cellTool.execute({
      module_name: "main",
      source: "after_cell_test_4 = 81",
      after_cell: 1
    })
  </script>
  <script id="721" type="application/vnd.observable.javascript">
    function createCell({ module, source } = {}) {
      const defs = compile(source);
      // check for collisions
      debugger;
      defs.forEach((def) => {
        if (
          def._name &&
          module._scope.has(def._name) &&
          /* scoped variables can exist for errors but not actually be real in the runtime*/ main._runtime._variables.has(
            module._scope.get(def._name)
          )
        ) {
          throw "duplicate name";
        }
      });
      const variables = defs.map((def) => {
        let _fn;
        eval("_fn = " + def._definition);
        return module.variable({}).define(def._name, def._inputs, _fn);
      });
      return variables;
    }
  </script>
  <script id="700" type="application/vnd.observable.javascript">
    test_create_cell_anon = createCell({ module: myModule, source: "45" })
  </script>
  <script id="1239" type="text/markdown">
    ### replace_cell
  </script>
  <script id="1251" type="application/vnd.observable.javascript">
    replace_cellTool = ({
      type: "function",
      name: "replace_cell",
      strict: true,
      description: "Replace a cell with a new definition.",
      parameters: {
        type: "object",
        properties: {
          module_name: {
            type: "string"
          },
          cell_name: {
            type: "string"
          },
          source: {
            type: "string"
          }
        },
        required: ["module_name", "cell_name", "source"],
        additionalProperties: false
      },
      execute: async ({ module_name, cell_name, source } = {}) => {
        const module = await getModule(module_name);
        if (!module) return `Error: module ${module_name} not found`;
        const cells = await cellMapCompat(module.module);
        if (!cells.has(cell_name))
          return `Error: cell '${cell_name}' in module '${module_name}' not found.`;
        const variables = cells.get(cell_name);
        try {
          const cell = replaceCell({
            module: module.module,
            variables,
            source
          });
        } catch (err) {
          return `Error: ${err.message}`;
        }
        return `ok`;
      }
    })
  </script>
  <script id="1267" type="application/vnd.observable.javascript">
    function replaceCell({ module, source, variables } = {}) {
      const defs = compile(source);

      let resposition = false, insertionIndex = -1;
      if (defs.length !== variables.length) {
        resposition = true;
        insertionIndex =
            [...runtime._variables].findIndex(
              (v) => v == variables.at(-1)
            );
        variables.forEach((v) => v.delete());
        for (let i = 0; i < defs.length; i++) {
          variables.push(module.variable({}));
        }
      }

      defs.forEach((v, i) => {
        const variable = variables[i];
        let _fn;
        eval("_fn = " + v._definition);
        variable.define(v._name, v._inputs, _fn);
        if (resposition)
          repositionSetElement(runtime._variables, variable, insertionIndex + i);
      });
      return variables;
    }
  </script>
  <script id="1253" type="application/vnd.observable.javascript">
    sample_variable = 43
  </script>
  <script id="1262" type="application/vnd.observable.javascript">
    test_replace_cellTool = replace_cellTool.execute({
      module_name: "main",
      cell_name: "sample_variable",
      source: "sample_variable = 52"
    })
  </script>
  <script id="895" type="text/markdown">
    ### peek_cell
  </script>
  <script id="1249" type="text/markdown">
    TODO:
    - Allow applying a function to the output with Javascript (e.g. CSS selector)
  </script>
  <script id="901" type="application/vnd.observable.javascript">
    import { inspect, Inspector, src } from "@tomlarkworthy/inspector"
  </script>
  <script id="2229" type="application/vnd.observable.javascript">
    async function summarizeVariable(
      variable_name,
      variable,
      { max_size = 0 } = {}
    ) {
      let cancel;
      const result = await new Promise((resolve) => {
        setTimeout(() => {
          resolve(`variable '${variable_name}' is pending`);
        }, 2000);
        cancel = observe(variable, {
          fulfilled: (value) => resolve(summarizeJS(value, { max_size })),
          rejected: (error) =>
            resolve(
              `variable '${variable_name}' in an an error state: ${summarizeJS(
                error,
                { max_size }
              )}`
            )
        });
      });
      return result;
    }
  </script>
  <script id="897" type="application/vnd.observable.javascript">
    peek_variableTool = ({
      type: "function",
      name: "peek_variable",
      strict: true,
      description:
        "Query the value of a variable, often the name of the cell owning it, but views and mutable cells contain two variables",
      parameters: {
        type: "object",
        properties: {
          module_name: {
            type: "string"
          },
          variable_name: {
            type: "string"
          },
          max_size: {
            type: "integer"
          }
        },
        required: ["module_name", "variable_name", "max_size"],
        additionalProperties: false
      },
      execute: async ({ module_name, variable_name, max_size } = {}) => {
        const module = await getModule(module_name);
        if (!module) return `Error: module ${module_name} not found`;
        const cells = await cellMapCompat(module.module);
        const options = [
          variable_name,
          `viewof ${variable_name}`,
          `mutable ${variable_name}`
        ];
        const cell_title = options.find((option) => cells.get(option));
        if (cell_title === undefined)
          return `can't find variables under ${variable_name}`;
        const variables = cells.get(cell_title);
        let variable;
        if (variables.length == 1) variable = variables[0];
        else {
          variable = variables.find((v) => v._name == variable_name);
        }

        return await summarizeVariable(variable_name, variable);
      }
    })
  </script>
  <script id="1126" type="application/vnd.observable.javascript">
    test_peek_variableTool = peek_variableTool.execute({
      module_name: "main",
      variable_name: "peek_variableTool",
      max_size: 1000
    })
  </script>
  <script id="1143" type="application/vnd.observable.javascript">
    mutable cool = "43"
  </script>
  <script id="1384" type="application/vnd.observable.javascript">
    errored = {
      throw Error("deliberate error for testing");
    }
  </script>
  <script id="1389" type="application/vnd.observable.javascript" pinned="">
    pending = new Promise(() => {})
  </script>
  <script id="1145" type="application/vnd.observable.javascript">
    test_peek_variableTool_mutable = peek_variableTool.execute({
      module_name: "main",
      variable_name: "cool",
      max_size: 1000
    })
  </script>
  <script id="1386" type="application/vnd.observable.javascript">
    test_peek_variableTool_error = peek_variableTool.execute({
      module_name: "main",
      variable_name: "errored",
      max_size: 1000
    })
  </script>
  <script id="1391" type="application/vnd.observable.javascript">
    test_peek_variableTool_pending = peek_variableTool.execute({
      module_name: "main",
      variable_name: "pending",
      max_size: 1000
    })
  </script>
  <script id="1223" type="application/vnd.observable.javascript">
    test_peek_variableTool_tests = peek_variableTool.execute({
      module_name: "main",
      variable_name: "failing_tests",
      max_size: 1000
    })
  </script>
  <script id="832" type="text/markdown">
    ### Helpers
  </script>
  <script id="2868" type="application/vnd.observable.javascript" pinned="">
    moduleVariables = (module) =>
      module._runtime._variables.filter((v) => v._module == module)
  </script>
  <script id="2220" type="application/vnd.observable.javascript">
    import { summarizeJS } from "@tomlarkworthy/summarizejs"
  </script>
  <script id="2007" type="application/vnd.observable.javascript">
    import { localStorageView } from "@tomlarkworthy/local-storage-view"
  </script>
  <script id="21" type="application/vnd.observable.javascript">
    import {
      responses,
      runTools,
      evalJavaScriptTool
    } from "@tomlarkworthy/openai-responses-api"
  </script>
  <script id="729" type="application/vnd.observable.javascript">
    import {
      thisModule,
      keepalive,
      main,
      runtime,
      repositionSetElement,
      observe
    } from "@tomlarkworthy/runtime-sdk"
  </script>
  <script id="727" type="application/vnd.observable.javascript">
    viewof myModule = thisModule()
  </script>
  <script id="834" type="application/vnd.observable.javascript">
    async function getModules() {
      return moduleMap();
    }
  </script>
  <script id="841" type="application/vnd.observable.javascript">
    async function getModule(name) {
      const modules = await getModules();
      return [...modules.values()].find((m) => m.name == name);
    }
  </script>
  <script id="859" type="application/vnd.observable.javascript">
    import { tests } from "@tomlarkworthy/tests"
  </script>
  <script id="1183" type="text/markdown">
    ## Static Data
  </script>
  <script id="532" type="application/vnd.observable.javascript">
    prompts = [
      "",
      "Explain how moduleMap works",
      "add a function to compute fibonacci sequence",
      "is yolo toggled?",
      "create some synthetic data and then visualize it with Plot (inbuilt function)"
    ]
  </script>
  <script id="1187" type="application/vnd.observable.javascript">
    reasoning_models = ["gpt-5-mini", "o4-mini", "o3-mini", "o3"]
  </script>
  <script id="1377" type="text/markdown">
    ## State
  </script>
  <script id="26" type="application/vnd.observable.javascript">
    initial_response = {
      console.log("initial_response");
      debugger;
      viewof calls.value = [];
      viewof calls.dispatchEvent(new Event("input"));
      const call = await responses({
        url: viewof endpoint.value,
        model,
        instructions,
        input: prompt,
        tools: viewof active_tools.value,
        parallel_tool_calls: false,
        reasoning: {
          effort: "high",
          summary: "auto"
        },
        tool_choice: "required"
      });
      viewof calls.value.push(call);
      viewof calls.dispatchEvent(new Event("input"));
    }
  </script>
  <script id="2857" type="application/vnd.observable.javascript" pinned="">
    step(calls[5])
  </script>
  <script id="228" type="application/vnd.observable.javascript">
    viewof calls = Inputs.input([])
  </script>
  <script id="1372" type="text/markdown">
    ## UI Builders
  </script>
  <script id="269" type="application/vnd.observable.javascript">
    actions = (calls_view, latest) => {
      if (!latest) return undefined;

      if (latest.error) return error(latest.error)

      const toolCalls = latest.output.filter((o) => o.type == "function_call");
      const actions = toolCalls.map((f) => f.name);

      if (
        !actions.includes("ask_followup_question") &&
        !actions.includes("attempt_completion") &&
        viewof yolo.value
      ) {
        runTools(latest).then((response) => {
          calls_view.value.push(response);
          calls_view.dispatchEvent(new Event("input"));
        });
        return undefined;
      }
      return htl.html`<div class="actions" style="display: flex;">
    ${
      !actions.includes("ask_followup_question") &&
      !actions.includes("attempt_completion")
        ? Inputs.button("execute", {
            reduce: async () => {
              const response = await runTools(latest);
              calls_view.value.push(response);
              calls_view.dispatchEvent(new Event("input"));
            }
          })
        : undefined
    }
    ${
      actions.includes("ask_followup_question")
        ? followUpQuestionDialog(
            calls_view,
            latest,
            toolCalls.find((call) => call.name == "ask_followup_question")
          )
        : undefined
    }
    ${
      actions.includes("attempt_completion")
        ? attempCompletetionDialog(
            calls_view,
            latest,
            toolCalls.find((call) => call.name == "attempt_completion")
          )
        : undefined
    }
    </div>`;
    }
  </script>
  <script id="648" type="application/vnd.observable.javascript">
    error = (error) => {
      return htl.html`<div class="error">
    <h4>error</h4>
    <pre>
    ${JSON.stringify(error, null, 2)}
    </pre>
    </div>`;
    }
  </script>
  <script id="244" type="application/vnd.observable.javascript">
    plan = (calls) => htl.html`<div class="plan">
    <div class="history">
      ${calls.filter((x) => x).map(step)}
    </div>
    ${actions(viewof calls, calls.at(-1))}
    </div>`
  </script>
  <script id="32" type="application/vnd.observable.javascript">
    step = (response) =>
      htl.html`<div id=${response.id} class="step">
      <div>
        ${response.input.map((i) => input(response, i))}
      </div>
      <div>
        ${response.output && response.output.map((o) => output(response, o))}
      </div>
    </div>`
  </script>
  <script id="94" type="application/vnd.observable.javascript">
    input = (response, input) => {
      if (input.type == "function_call_output")
        return input_function_call_output(response, input);
      else if (input.content) return input_content(response, input);
      else console.error("unhandled input type", input.type);
    }
  </script>
  <script id="134" type="application/vnd.observable.javascript">
    input_content = (response, input) => htl.html`<div 
        id=${input.id}
        class="input_message">
        <b>${input.role}</b>: ${input.content}
    </div>`
  </script>
  <script id="96" type="application/vnd.observable.javascript">
    input_function_call_output = (response, input) => htl.html`<div 
        id=${input.id}
        class="function_call_output">
        <h4>function_call_output</h4>
        ${md`${input.output}`}
    </div>`
  </script>
  <script id="57" type="application/vnd.observable.javascript">
    output = (response, output) => {
      if (output.type == "message") return output_message(response, output);
      else if (output.type == "function_call")
        return output_message_function_call(response, output);
      else if (output.type == "reasoning")
        return output_message_reasoning(response, output);
      else {
        console.error("unhandled output type", output.type);
      }
    }
  </script>
  <script id="111" type="application/vnd.observable.javascript">
    output_message_function_call = (response, output) => htl.html`<div 
        id=${output.id}
        class="function_call">
        <h4>function_call</h4>
        <code>
          ${output.name}(${JSON.stringify(output.arguments, null, 2)})
        </code>
    </div>`
  </script>
  <script id="147" type="application/vnd.observable.javascript">
    output_message_reasoning = (response, output) => htl.html`<div 
        id=${output.id}
        class="reasoning">
        <h4>reasoning</h4>
        ${output.summary.map((summary) =>
          output_message_reasoning_summary(response, output, summary)
        )}
    </div>`
  </script>
  <script id="617" type="application/vnd.observable.javascript">
    output_message_reasoning_summary = (response, output, summary) => {
      return html`<div class="summary_text">
        ${summary.text}
      </div>`;
    }
  </script>
  <script id="72" type="application/vnd.observable.javascript">
    output_message = (response, output) => htl.html`<div 
        id=${output.id}
        class="plan_output">
        <h4>output_message</h4>
        ${output.content.map((content) =>
          output_message_content(response, output, content)
        )}
    </div>`
  </script>
  <script id="77" type="application/vnd.observable.javascript">
    output_message_content = (response, output, content) => {
      if (content.type == "output_text")
        return output_message_content_output_text(response, output, content);
      else {
        console.error("unhandled content type", content.type);
      }
    }
  </script>
  <script id="82" type="application/vnd.observable.javascript">
    output_message_content_output_text = (
      response,
      output,
      content
    ) => htl.html`<div 
        id=${output.id}
        class="output_text">
        ${md`${content.text}`}
    </div>`
  </script>
  <script id="890" type="text/markdown">
    ## Prompt
  </script>
  <script id="2750" type="application/vnd.observable.javascript">
    context_menu
  </script>
  <script id="800" type="application/vnd.observable.javascript">
    import { viewof selectedCell, context_menu } from "@tomlarkworthy/editor-4"
  </script>
  <script id="204" type="application/vnd.observable.javascript">
    {
      workingModule;
      return md`${await instructions()}`;
    }
  </script>
  <script id="199" type="application/vnd.observable.javascript">
    instructions = {
      keepalive(myModule, "failing_tests");
      return async () => `RULES
    - You are Roboco-op, a highly professional software engineer with extensive knowledge Observable notebooks, data analysis and visualization, and literate programming.
    - You are executing inside a browser, collaberating with a user on a notebook, executing inside the notebook. 
    - A notebook is made up of modules, cells and fileattachments. It is a literate programming environment and most modules contain useful information in anonymous markdown cells.
    - Both you and the user can manipulate Observable source code in the notebook. All usage suggestions to the user should thus be in the form of Observable cell source code.
    - You are capable of querying the notebook to discover its capabilities. Use tools to provide answers based on facts.
    - When understanding cells, always run 'describe_cells' on preceeding anonymous cells, as they may contain critical information needed to understand the cell properly. Prefer decribing more cells than you think you need to ensure coverage and full understanding. Follow the inputs to cells to ensure you understand the dependancies before answering.
    - Use the replace_cell or create_cell tool modify the notebook. You do not need to display the changes before using the tool.
    - Do not ask for more information than necessary. Use the tools provided to accomplish the user's request efficiently and effectively. When you've completed your task, you *MUST* use the attempt_completion tool to present the result to the user. The user may provide feedback, which you can use to make improvements and try again.
    - You are only allowed to ask the user questions using the ask_followup_question tool. Use this tool only when you need additional details to complete a task, and be sure to use a clear and concise question that will help you move forward with the task. However if you can use the available tools to avoid having to ask the user questions, you should do so. For example, if the user mentions a specific cell, you should use the list_modules tool to list the modules in the runtime and check if the cell they are talking about is there, rather than asking the user to provide the cell themselves.
    - Your goal is to try to accomplish the user's task, NOT engage in a back and forth conversation. Be terse.
    - Never suggest code you have not executed and checked the result of. Use temporary cells for scratch calculations, but if creating a cannonical test use a unit test prefixed with 'test_'.
    - NEVER end attempt_completion result with a question or request to engage in further conversation! Formulate the end of your result in a way that is final and does not require further input from the user.
    - You are STRICTLY FORBIDDEN from starting your messages with "Great", "Certainly", "Okay", "Sure". You should NOT be conversational in your responses, but rather direct and to the point. For example you should NOT say "Great, I've updated the CSS" but instead something like "I've updated the CSS". It is important you be clear and technical in your messages.
    - When presented with images, utilize your vision capabilities to thoroughly examine them and extract meaningful information. Incorporate these insights into your thought process as you accomplish the user's task.
    - Like any professional software engineer, you make mistakes, which is why you attempt to verify operations have executed as you expected with peek_cell. Furthermore, you document examples through unit tests.
    - You check for failing tests in the "@tomlarkworthy/agentic-planner" module, cell "failing_tests", cells prefixed with 'test_' is automatically picked up by the test suite. If you observe an empty array in "failing_tests" then nothing is failing!
    - You can write a test like so 
    <code>
    test_foo = {
      expect(await "foo").toEqual("bar");
    }"
    </code>
    - You write in observablejs source code, so a simple cell might look like
    <code>
    myCell = {
      return "foo"
    }
    </code>

    ====

    USER CONTEXT

    You are to do most of your work in "${viewof workingModule.value}" module.


    You can look for failing tests in the "${
        tests_module.name
      }" notebook, cell "failing_tests". It currently is evaluating to

    ${await peek_variableTool.execute({
      module_name: tests_module.name,
      variable_name: "failing_tests"
    })}
    `;
    }
  </script>
  <script id="2890" type="application/vnd.observable.javascript">
    import { expect } from "@tomlarkworthy/jest-expect-standalone"
  </script>
  <script id="2903" type="application/vnd.observable.javascript" pinned="">
    import { foo } from "@tomlarkworthy/gepa"
  </script>
</notebook>
