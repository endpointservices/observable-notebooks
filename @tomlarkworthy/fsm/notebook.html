<!doctype html>
<notebook theme="air">
  <title>ðŸ‘‹ Hello, javascript-state-machine â¨¯ Plot</title>
  <script id="0" type="text/markdown">
    #  ðŸ‘‹ Hello, [javascript-state-machine](https://github.com/jakesgordon/javascript-state-machine) â¨¯ [Plot](https://observablehq.com/plot/) 

    ```js
    import {StateMachine, visualizeFsm} from "@tomlarkworthy/fsm"
    ```
  </script>
  <script id="21" type="application/vnd.observable.javascript">
    StateMachine = (await import("https://esm.sh/javascript-state-machine@3.1.0"))
      .default
  </script>
  <script id="245" type="application/vnd.observable.javascript">
    visualizeFsm = (
      fsm,
      {
        layout = (state, index) =>
          d3.pointRadial(((2 - index) * 2 * Math.PI) / fsm.allStates().length, 100)
      } = {}
    ) => {
      const nodes = new Map(fsm.allStates().map((m, i) => [m, layout(m, i)]));
      const edges = Object.entries(fsm._fsm.config.map).flatMap(
        ([from, transtions], i) =>
          Object.entries(transtions).map(([name, transtion], j) => [
            [from, nodes.get(from)],
            [name, nodes.get(transtion.to)]
          ])
      );
      return Plot.plot({
        inset: 60,
        aspectRatio: 1,
        axis: null,
        marks: [
          Plot.dot(nodes.entries(), {
            x: ([k, c]) => c[0],
            y: ([k, c]) => c[1],
            r: 40,
            stroke: ([k, c]) => (k == fsm.state ? "blue" : "black"),
            strokeWidth: ([k, c]) => (k == fsm.state ? 4 : 2)
          }),
          Plot.arrow(edges, {
            x1: ([[, [x1]]]) => x1,
            y1: ([[, [, y1]]]) => y1,
            x2: ([, [, [x2]]]) => x2,
            y2: ([, [, [, y2]]]) => y2,
            bend: true,
            //strokeWidth: ([, , value]) => value,
            strokeLinejoin: "miter",
            headLength: 24,
            inset: 48
          }),
          Plot.text(nodes.entries(), {
            x: ([k, c]) => c[0],
            y: ([k, c]) => c[1],
            text: ([k, c]) => k
          }),
          Plot.text(edges, {
            x: ([[, [x1, y1]], [, [x2, y2]]]) => (x1 + x2) / 2 + (y1 - y2) * 0.15,
            y: ([[, [x1, y1]], [, [x2, y2]]]) => (y1 + y2) / 2 - (x1 - x2) * 0.15,
            text: ([[, [x1, y1]], [label, [x2, y2]]]) => label
          })
        ]
      });
    }
  </script>
  <script id="25" type="text/markdown">
    # Example
  </script>
  <script id="5" type="application/vnd.observable.javascript">
    output && visualizeFsm(fsm)
  </script>
  <script id="27" type="application/vnd.observable.javascript">
    viewof output = Inputs.text({ label: "output", disabled: true, value: " " })
  </script>
  <script id="282" type="application/vnd.observable.javascript">
    viewof state = output &&
      Inputs.text({ label: "state", disabled: true, value: fsm.state })
  </script>
  <script id="55" type="text/html">
    <div style="display: flex;">
      ${output && fsm.allTransitions().map((state) => htl.html`<div style="width: 100px">${
        Inputs.button(html`<span style="color: ${!fsm.transitions().includes(state)? 'black': 'green'};">${state}</span>`, {
          reduce: () => fsm[state](),
          width: 100,
          disabled: !fsm.transitions().includes(state)
        })
    }`)}
    </div>
  </script>
  <script id="35" type="application/vnd.observable.javascript" pinned="">
    fsm = new StateMachine({
      init: "solid",
      transitions: [
        { name: "melt", from: "solid", to: "liquid" },
        { name: "freeze", from: "liquid", to: "solid" },
        { name: "vaporize", from: "liquid", to: "gas" },
        { name: "condense", from: "gas", to: "liquid" }
      ],
      methods: {
        onMelt: function () {
          viewof output.value = "I melted";
        },
        onFreeze: function () {
          viewof output.value = "I froze";
        },
        onVaporize: function () {
          viewof output.value = "I vaporized";
        },
        onCondense: function () {
          viewof output.value = "I condensed";
        },
        // Always trigger dataflow on output cell after a change
        onAfterTransition: () => viewof output.dispatchEvent(new Event("input"))
      }
    })
  </script>
</notebook>
