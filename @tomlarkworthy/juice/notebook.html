<!doctype html>
<notebook theme="air">
  <title>Squeezing more Juice out of UI libraries</title>
  <script id="0" type="text/markdown">
    # Squeezing more _Juice_ out of UI libraries

    Sometimes you want the configuration of a view component to be reactive. You want the arguments in the constructor to become part of the value in a view. For example, making the *options* in a *select* part of the value enables you to back-write into the view to update the drop down. You don't want to do this using *dataflow* because its part of a single cell UI.

    This utility moves configuration parameters into the value. Hopefully this helps us squeeze a little more juice out of existing Input libraries, a useful technique for [scaling UI development](https://observablehq.com/@tomlarkworthy/ui-development)

    This utility was created in response to conversations with [@mkfreeman](/@mkfreeman) and [@dleeftink](/@dleeftink) who both independently had a requirement for a select with mutable options. I decided it would be useful to solve this problem in a general way so we could take any UI component and pull out its configuration to suit.

    ~~~js
    import {juice} from '@tomlarkworthy/juice'
    ~~~


  </script>
  <script id="663" type="text/markdown">
    ## fastest way to make UI components

    Convert static renderers into reactive components:
    ```js
    (name, age) => html`Your name is \${name} your age is \${age}`
    ```
  </script>
  <script id="675" type="application/vnd.observable.javascript" pinned="">
    import { exporter } from "@tomlarkworthy/exporter"
  </script>
  <script id="681" type="application/vnd.observable.javascript" pinned="">
    exporter()
  </script>
  <script id="650" type="application/vnd.observable.javascript" pinned="">
    profile = juice((name, age) => html`Your name is ${name} your age is ${age}`, {
      name: "[0]", // we index into the ...arguments array
      age: "[1]"
    })
  </script>
  <script id="653" type="application/vnd.observable.javascript" pinned="">
    viewof example = profile("tom", 21) // profile now constructs a reactive component
  </script>
  <script id="655" type="application/vnd.observable.javascript" pinned="">
    Inputs.bind(Inputs.range([0, 99]), viewof example.age) // so you can do granular biunding
  </script>
  <script id="524" type="text/markdown">
    ## *juice* API

    ~~~
        juice(VIEW_BUILDER, JUICE_CONFIG) => NEW_VIEW_BUILDER
    ~~~

    ### 1st arg is a view builder

    _**juice**_ is a higher order function that takes a **view builder** function as its **1st arg**, and returns a new **view builder** function. *Inputs.select* is an example of a view builder function that can be found in the standard library. View builders are a common form of packaging a UI component on Observable. 

    *A view builder is a function that takes some configuration as its arguments and returns a view*

    ~~~js
        juice(VIEW_BUILDER, ???) => VIEW_BUILDER
    ~~~

    ### 2nd arg is the argument remapping

    The 2nd argument of juice configures how static configuration arguments are moved the view's value output. It is is expressed as an *key-value* object dictionary. The *key* is the property name in the resultant composite view, the *value* is a lodash path into the view builders configuration *...arg* array, have a look at the examples below to see how the path syntax works.

    ~~~js
        juice(VIEW_BUILDER, {subview => ...args path}) => VIEW_BUILDER
    ~~~

    ### Returns a view builder with a composite value

    The result of applying *juice* is a new view builder. 

    The new builder has an identical argument list to the original one. Input arguments form the base args for internal calls to the view builder. 


    The new builder has a very different value type though. The value becomes a dictionary of values. One entry *"result"* is the original return value.  The other entries correspond to entries in the *argument remapping* configuration mentioned above. Note the fields are mutable, and you can write back into them to update the UI configuration.



  </script>
  <script id="642" type="text/markdown">
    ### Works with any functional UI

    You can animate your own custom constructors or [D3 charts](https://observablehq.com/@tomlarkworthy/juice-and-charts)
  </script>
  <script id="595" type="text/markdown">
    #### Example

    If we *juice* the *range* builder:
    ~~~js
    dynamicRange = juice(Inputs.range, {
      label: "[1].label",
      min: "[0][0]", 
      max: "[0][1]", 
    })
    ~~~

    We can instantiate ranges as normal:-

    ~~~js
    viewof myDynamicRange = dynamicRange([0, 10], {label: "cool"})
    ~~~

    But we end up with a view whose value is of the form

    ~~~js
    {label: "...", min: -1, max: 1, result: 0}
    ~~~

    And we back-write into it from anywhere else in the notebook

    ~~~js
    {
      viewof myDynamicRange.max.value = 1000;
      viewof myDynamicRange.max.dispatchEvent(new Event('input', {bubbles: true}));
    }
    ~~~

    Because the value is a nested view, each subview supports *Inputs.bind* individually, see [scaling UI development](https://observablehq.com/@tomlarkworthy/ui-development#nesting-views-with-the-view-literal-https-observablehq-com-tomlarkworthy-view-) for why this is important.


  </script>
  <script id="434" type="text/markdown">
    ### Open Issues

    ##### DOM state lost when parameters

    When a configuration parameter is updated, the DOM node is deleted and replaced with a fresh node, this breaks things like mouse event handlers, caret position etc. My normal goto solution for DOM state loss is nanomorph, but nanomorph does not work with Inputs ([bug](https://github.com/observablehq/inputs/issues/184)). So, for now, we do the crude DOM swap and live with the UI state loss glitches.

  </script>
  <script id="440" type="application/vnd.observable.javascript" pinned="">
    viewof stateLostExample = dynamicRange()
  </script>
  <script id="442" type="application/vnd.observable.javascript" pinned="">
    stateLostExampleUpdater = {
      let i = 0;
      const banner = "Label updates break the slider :( ";
      while (true) {
        yield Promises.delay(100);
        stateLostExample.label = (banner + banner).substring(i, i + 15);
        i = (i + 1) % banner.length;
      }
    }
  </script>
  <script id="451" type="text/markdown">
    ## Implementation
  </script>
  <script id="16" type="application/vnd.observable.javascript">
    juice = (builder, targets = {}) => (...args) => {
      const result = proxyVariable({
        name: "result",
        get: () => viewUI.value,
        set: (newVal) => (viewUI.value = newVal)
      });

      const proxyPassthrough = (evt) => {
        result.dispatchEvent(new CustomEvent("input", evt));
      };

      let viewUI = builder(...args);
      viewUI.addEventListener("input", proxyPassthrough);

      const vars = Object.fromEntries(
        Object.entries(targets)
          .filter(([target, _]) => target !== "result") // result var is handled a bit differently
          .map(([target, path]) => {
            const v = variable(_.get(args, path), { name: target });
            v.addEventListener("assign", () => {
              // Patch the args based on the current values in the variables
              Object.keys(targets).forEach((target) => {
                const path = targets[target];
                // Current value, normally pulled from the vairable but special case for the 'result'
                const value =
                  target === "result" ? viewUI.value : vars[target].value;
                _.update(args, path, () => value);
              });
              // We create a whole new view and substitute it in
              const newView = builder(...args);
              viewUI.replaceWith(newView); // A fair amount of state is lost here, but reconcile doesn't work
              viewUI.removeEventListener("input", proxyPassthrough);
              viewUI = newView;
              viewUI.addEventListener("input", proxyPassthrough);
            });
            return [target, v];
          })
      );
      const ui = view`<span>${["...", vars]}${["result", result]}${viewUI}`;
      return ui;
    }
  </script>
  <script id="575" type="application/vnd.observable.javascript">
    md`### helpers`
  </script>
  <script id="132" type="application/vnd.observable.javascript">
    function proxyVariable({ name = "variable", get, set } = {}) {
      const self = document.createComment(name);
      return Object.defineProperties(self, {
        value: {
          get: get,
          set: set,
          enumerable: true
        },
        toString: {
          value: () => `${get()}`
        }
      });
    }
  </script>
  <script id="261" type="application/vnd.observable.javascript">
    md`## Range with dynamic max and min

    Here we extract the ranges first arg, *max* and *min* to be their own backwritable subviews
    `
  </script>
  <script id="269" type="application/vnd.observable.javascript" pinned="">
    dynamicRange = juice(Inputs.range, {
      label: "[1].label",
      min: "[0][0]", // "range" is first arg (index 0), the min is the 1st arg of the range array
      max: "[0][1]", // "range" is first arg, the max is the 2nd paramater of that array
      result: "[1].value" // "result" can be set in the options.value, options being the 2nd arg (index 0)
    })
  </script>
  <script id="272" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicRangeExample = dynamicRange([-1, 1], { label: "dynamic range" })
  </script>
  <script id="400" type="application/vnd.observable.javascript" pinned="">
    dynamicRangeExample
  </script>
  <script id="303" type="application/vnd.observable.javascript">
    dynamicRangeExample
  </script>
  <script id="283" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicRangeMin = dynamicRange([-1, 1], {
      label: "dynamic range min",
      value: -1
    })
  </script>
  <script id="406" type="application/vnd.observable.javascript">
    dynamicRangeMin
  </script>
  <script id="286" type="application/vnd.observable.javascript" pinned="">
    viewof dynamicRangeMax = dynamicRange([-1, 1], {
      label: "dynamic range max",
      value: 1
    })
  </script>
  <script id="310" type="application/vnd.observable.javascript">
    dynamicRangeMax
  </script>
  <script id="288" type="application/vnd.observable.javascript" pinned="">
    minMaxConstraints = {
      // We want dynamicRangeMax to constrain the dynamic range's max and min
      Inputs.bind(viewof dynamicRangeExample.max, viewof dynamicRangeMax.result);
      Inputs.bind(viewof dynamicRangeExample.min, viewof dynamicRangeMin.result);
      // Of course, the max of the min should also be constrained by the max too
      Inputs.bind(viewof dynamicRangeMin.max, viewof dynamicRangeMax.result);
      Inputs.bind(viewof dynamicRangeMax.min, viewof dynamicRangeMin.result);
    }
  </script>
  <script id="484" type="application/vnd.observable.javascript">
    md`### Select with Dynamic Options`
  </script>
  <script id="486" type="application/vnd.observable.javascript" pinned="">
    dynamicSelect = juice(Inputs.select, {
      label: "[1].label",
      options: "[0]", // "options" is first arg (index 0) of Inputs.select
      result: "[1].value" // "result" can be set in the options.value, options being the 2nd arg (index 0)
    })
  </script>
  <script id="496" type="application/vnd.observable.javascript">
    Inputs.button("deal", {
      reduce: () => {
        const rndCard = () => {
          const card = Math.floor(Math.random() * 52);
          return (
            ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"][
              card % 14
            ] + ["♠", "♥", "♦", "♣"][Math.floor(card / 14)]
          );
        };
        viewof exampleSelect.options.value = [rndCard(), rndCard()];
        viewof exampleSelect.options.dispatchEvent(new Event("input"));
      }
    })
  </script>
  <script id="30" type="application/vnd.observable.javascript" pinned="">
    viewof exampleSelect = dynamicSelect([], { label: "play a card" })
  </script>
  <script id="45" type="application/vnd.observable.javascript">
    import { view, variable } from "@tomlarkworthy/view"
  </script>
  <script id="47" type="application/vnd.observable.javascript">
    import { viewroutine, ask } from "@tomlarkworthy/viewroutine"
  </script>
</notebook>
