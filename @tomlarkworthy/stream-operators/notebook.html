<!doctype html>
<notebook theme="air">
  <title>RxJS inspired stream operators for views</title>
  <script id="0" type="text/markdown">
    # RxJS inspired stream operators for *views*


    [Reactive Extension's (RxJS)](https://rxjs.dev/) container class is an _Observable_. Rx defines a set of stream operators to combine and transform _Observables_ into other _Observables_.

    Observable[sic] Notebooks are nothing to do with RxJS, but have "views" which represent two reactive variables:
    1. the control-plane variable "_viewof X_", often a DOM node.
    2. the data-plane value "_X_", which is an independent reactivity participant.

    Note the "viewof" does not need to to be a DOM node and it this notebook it will not be used like that.

    In this notebook we note that a "_viewof_" can act like an RxJS Observable. It wraps a stream of values, and thus, we can make analogous viewof counterparts to RxJS's stream Operators. With our RxJS-like Stream Operators, we will combine and transform views, to create new views.

    In this notebook we explore how some of RxJS's operators can solve some common Observablehq dataflow gotchas.
  </script>
  <script id="46" type="text/markdown">
    ## Fizz Buzz Example

    Walking through an implementation of FizzBuzz using stream operator's introduces the coding style. 
  </script>
  <script id="253" type="text/markdown">
    RxJS has a "creation" operator called [_interval_](https://rxjs.dev/api/index/function/interval) that creates a reactive stream that emits in incrementing numbers every "period" milliseconds. We can do the same thing:-
  </script>
  <script id="17" type="application/vnd.observable.javascript" pinned="">
    viewof counter = interval({ period: 500, invalidation })
  </script>
  <script id="258" type="text/markdown">
    With our _interval_ it returns a "viewof" as opposed to an _Observable_. We also have to pass in the _invalidation_ promise so that if the cell is reevaluated the timer is removed. Note: all our stream operators need the invalidation promise passed in.

    If we now look at the value of the _counter_ below, it is updating every half a second, but note the control-plane _viewof_ above is not. This is important, when we combine streams we work with the "viewofs", which are static wiring, but underneath them the dataplane is reactive and processing dataflow idiomatically to the Observable's notebook dataflow paradigm.
  </script>
  <script id="44" type="application/vnd.observable.javascript" pinned="">
    counter
  </script>
  <script id="276" type="text/markdown">
    Lets implement FizzBuzz as two independently combined streams, Fizz and Buzz. 

    For Fizz, we emit Fizz if we see the counter is divisible by 3, otherwise we emit null. We can use a reactive ["map"](https://rxjs.dev/api?query=map). Our input view is our previous viewof (not the data channel!)
  </script>
  <script id="48" type="application/vnd.observable.javascript" pinned="">
    viewof fizz = map({
      view: viewof counter,
      map: (count) => {
        if (count % 3 == 0) return "Fizz";
        return null;
      },
      invalidation
    })
  </script>
  <script id="280" type="text/markdown">
    Note the result of the map is another viewof, which depends only on the previous viewof counter, so is not affected by dataflow either but the underlying data channel is recomputing at the same rate as _counter_ (see below)
  </script>
  <script id="52" type="application/vnd.observable.javascript" pinned="">
    fizz
  </script>
  <script id="287" type="text/markdown">
    Buzz is the same thing but for numbers divisible by 5 numbers.
  </script>
  <script id="54" type="application/vnd.observable.javascript" pinned="">
    viewof buzz = map({
      view: viewof counter,
      map: (count) => {
        if (count % 5 == 0) return "Buzz";
        return null;
      },
      invalidation
    })
  </script>
  <script id="57" type="application/vnd.observable.javascript" pinned="">
    buzz
  </script>
  <script id="289" type="text/markdown">
    Now lets try to combine streams. In FizzBuzz you either say fizz or buzz or both if the number is divisible by 5 and 3. If the number is not any of those you say the number. So we need to combine three streams (Fizz, Buzz and Counter).

    A common stream combinator is ["combineLatest"](https://rxjs.dev/api/operators/combineLatest), which provides the latest values of multiple streams to a function, that then computes the emitted value.

    Our viewof -> RxJS mapping converts the passed in viewof streams to values internally, and forwards them to the internal function in the same order but as values now. We never depend on data channels directly otherwise the stream operator call would recompute every data update.

  </script>
  <script id="64" type="application/vnd.observable.javascript" pinned="">
    viewof fizzBuzzCombineLatest = combineLatest({
      // three views
      views: [viewof counter, viewof fizz, viewof buzz],
      // three **values**
      map: (count, fizz, buzz) =>
        fizz && buzz ? fizz + buzz : fizz || buzz || count,
      invalidation
    })
  </script>
  <script id="109" type="text/markdown">
    _fizzBuzzCombineLatest_ shows the glitchiness of combining synchronised streams with _combineLatest_, sometimes there are extra frames merging a previous value to a new value, depending on the order of evaluation. 

    The result is more updates than you would expect.
  </script>
  <script id="71" type="application/vnd.observable.javascript" pinned="">
    fizzBuzzCombineLatest
  </script>
  <script id="366" type="text/markdown">
    We can count the number of updates with a scan
  </script>
  <script id="370" type="application/vnd.observable.javascript" pinned="">
    viewof countFizzBuzzCombineLatest = scan({
      view: viewof fizzBuzzCombineLatest,
      seed: 0,
      scan: (acc, element) => acc + 1,
      invalidation
    })
  </script>
  <script id="374" type="application/vnd.observable.javascript" pinned="">
    countFizzBuzzCombineLatest
  </script>
  <script id="380" type="text/markdown">
    Now we can clearly see that there are three updates per clock update! This is a common source of bugs in Observable reactive programming! Merging multiple active dataflow add the rate of updates, furthermore the order of the cell updates is indeterminate. ObservableHQ dataflow is most analogous to RxJS's combineLatest operator.
  </script>
  <script id="386" type="text/markdown">
    RxJS has an alternative solution, the [zip](https://www.learnrxjs.io/learn-rxjs/operators/combination/zip) operator, which waits until every stream emits before emitting an array of those values.
  </script>
  <script id="130" type="application/vnd.observable.javascript" pinned="">
    viewof fizzBuzzZipArray = zip({
      views: [viewof counter, viewof fizz, viewof buzz],
      invalidation
    })
  </script>
  <script id="132" type="application/vnd.observable.javascript" pinned="">
    fizzBuzzZipArray
  </script>
  <script id="400" type="text/markdown">
    For zip and combineLatest you can add a map parameter to transform the stream inline.
  </script>
  <script id="395" type="application/vnd.observable.javascript" pinned="">
    viewof fizzBuzzZip = zip({
      views: [viewof counter, viewof fizz, viewof buzz],
      map: (count, fizz, buzz) =>
        fizz && buzz ? fizz + buzz : fizz || buzz || count,
      invalidation
    })
  </script>
  <script id="582" type="application/vnd.observable.javascript" pinned="">
    fizzBuzzZip
  </script>
  <script id="408" type="text/markdown">
    Now when we count the downstream updates we get one update every 500 millis! We solved FizzBuzz the stream orientated way!
  </script>
  <script id="403" type="application/vnd.observable.javascript" pinned="">
    viewof countFizzBuzzZip = scan({
      view: viewof fizzBuzzZip,
      seed: 0,
      scan: (acc, element) => acc + 1,
      invalidation
    })
  </script>
  <script id="406" type="application/vnd.observable.javascript" pinned="">
    countFizzBuzzZip
  </script>
  <script id="423" type="text/markdown">
    The zip operator is useful for fixing Obervable dataflow glitches caused by combining synchronised streams.
  </script>
  <script id="496" type="text/markdown">
    ## Other Examples
  </script>
  <script id="426" type="text/markdown">
    #### Rate reduction

    Another annoyance with Observable Notebook dataflow is its hard to reduce the rate of dataflow. As soon as a cell references another cell, the downstream cell will always recompute at least as frequently as the upstream cell.

    We can fix this with stream operators, if a map function returns undefined, no update is made.

    In the following function we will create a cell that updates once a second by only emitting if the counter is even, thereby halving the frequency of updates
  </script>
  <script id="439" type="application/vnd.observable.javascript" pinned="">
    viewof evens = map({
      view: viewof counter,
      map: (v) => (v % 2 ? undefined : v),
      invalidation
    })
  </script>
  <script id="443" type="application/vnd.observable.javascript" pinned="">
    evens
  </script>
  <script id="448" type="text/markdown">
    #### Deduplication

    Another common difficulty is preventing duplicate updates, this organically arrises when filtering collections. Often minor perturbations of the selection criteria lead to the same sub-selection, so why cascade that change downstream? More generally, if a cell output is the same, there is no need to propagate a change. We can use scan to achieve this.
  </script>
  <script id="454" type="application/vnd.observable.javascript" pinned="">
    viewof headsOrTails = map({
      view: viewof counter,
      map: (v) => (Math.random() > 0.5 ? "Heads" : "Tails"),
      invalidation
    })
  </script>
  <script id="458" type="application/vnd.observable.javascript" pinned="">
    headsOrTails
  </script>
  <script id="461" type="application/vnd.observable.javascript" pinned="">
    viewof deduped = scan({
      view: viewof headsOrTails,
      scan: (acc, value) => (acc !== value ? value : undefined),
      invalidation
    })
  </script>
  <script id="466" type="application/vnd.observable.javascript" pinned="">
    deduped
  </script>
  <script id="492" type="text/markdown">
    #### Temporal Rate Measurement

    The scan is pretty flexible. We can compute a running rate computation. First we map a stream to timestamps, scan to collect those within the last 5 seconds, then compute the average.
  </script>
  <script id="513" type="application/vnd.observable.javascript" pinned="">
    viewof timestamp = map({
      view: viewof deduped,
      map: () => performance.now(),
      invalidation
    })
  </script>
  <script id="519" type="application/vnd.observable.javascript" pinned="">
    timestamp
  </script>
  <script id="530" type="application/vnd.observable.javascript" pinned="">
    viewof last_5_secs = scan({
      view: viewof timestamp,
      seed: [],
      scan: (acc, next) => {
        acc.push(next);
        while (acc[0] < performance.now() - 5000) acc.shift();
        return acc;
      },
      invalidation
    })
  </script>
  <script id="533" type="application/vnd.observable.javascript" pinned="">
    last_5_secs
  </script>
  <script id="540" type="application/vnd.observable.javascript" pinned="">
    viewof rate = map({
      view: viewof last_5_secs,
      map: (array) => array.length / (0.001 * (array.at(-1) - array.at(1))),
      invalidation
    })
  </script>
  <script id="542" type="text/markdown" pinned="">
    ${rate} per second
  </script>
  <script id="562" type="text/markdown">
    We don't actually need to do these computations in different cells, you can wire everything up purely in imperative code if you want. It looks ugly as hell though.
  </script>
  <script id="567" type="application/vnd.observable.javascript" pinned="">
    viewof rate2 = map({
      map: (array) => array.length / (0.001 * (array.at(-1) - array.at(1))),
      view: scan({
        seed: [],
        scan: (acc, next) => {
          acc.push(next);
          while (acc[0] < performance.now() - 5000) acc.shift();
          return acc;
        },
        view: map({
          map: () => performance.now(),
          view: viewof deduped,
          invalidation
        }),
        invalidation
      }),
      invalidation
    })
  </script>
  <script id="564" type="text/markdown" pinned="">
    ${rate2} per second
  </script>
  <script id="250" type="text/markdown">
    ## Operator Implementation
  </script>
  <script id="113" type="text/markdown">
    In most places returning `undefined` means skip an update.
  </script>
  <script id="24" type="text/markdown">
    ### interval

    https://rxjs.dev/api/index/function/interval
  </script>
  <script id="27" type="application/vnd.observable.javascript">
    function interval({ period = 0, invalidation }) {
      const result = Inputs.input();
      let count = 0;
      debugger;
      const onTick = () => {
        debugger;
        result.value = count++;
        result.dispatchEvent(new Event("input"));
      };
      const id = setInterval(onTick, period);
      invalidation.then(() => clearInterval(id));
      return result;
    }
  </script>
  <script id="268" type="text/markdown">
    ### map

    https://rxjs.dev/api/index/function/map
  </script>
  <script id="271" type="application/vnd.observable.javascript">
    function map({ view, map = (v) => v, invalidation }) {
      const result = Inputs.input();
      const handler = () => {
        const val = map(view.value);
        if (val !== undefined) {
          result.value = val;
          result.dispatchEvent(new Event("input"));
        }
      };
      view.addEventListener("input", handler);

      invalidation.then(() => view.removeEventListener("input", handler));
      handler();
      return result;
    }
  </script>
  <script id="359" type="text/markdown">
    ### scan

    https://rxjs.dev/api/operators/scan
  </script>
  <script id="362" type="application/vnd.observable.javascript">
    function scan({ view, scan = (acc, v) => v, seed, invalidation }) {
      const result = Inputs.input();
      let acc = seed;

      const handler = () => {
        const update = scan(acc, view.value);
        if (update !== undefined) {
          acc = update;
          result.value = acc;
          result.dispatchEvent(new Event("input"));
        }
      };

      view.addEventListener("input", handler);

      invalidation.then(() => view.removeEventListener("input", handler));

      handler();
      return result;
    }
  </script>
  <script id="97" type="text/markdown">
    ### combineLatest

    https://rxjs.dev/api/index/function/combineLatest
  </script>
  <script id="7" type="application/vnd.observable.javascript">
    function combineLatest({
      views = [],
      map = (...views) => views,
      invalidation
    }) {
      const result = Inputs.input();
      const recompute = () => {
        const latest = map(...views.map((v) => v.value));
        if (latest !== undefined) {
          result.value = latest;
          result.dispatchEvent(new Event("input"));
        }
      };
      views.forEach((view) => view.addEventListener("input", recompute));
      invalidation.then(() => {
        views.forEach((view) => view.removeEventListener("input", recompute));
      });
      return result;
    }
  </script>
  <script id="118" type="text/markdown">
    ### zip

    https://rxjs.dev/api/index/function/zip
  </script>
  <script id="121" type="application/vnd.observable.javascript">
    function zip({ views = [], map = (...values) => values, invalidation }) {
      const result = Inputs.input();
      const queues = views.map(() => []);
      const handlers = views.map((view, i) => {
        const handler = () => {
          queues[i].push(view.value);
          if (queues.every((q) => q.length > 0)) {
            const vals = queues.map((q) => q.shift());
            const out = map(...vals);
            if (out !== undefined) {
              result.value = out;
              result.dispatchEvent(new Event("input"));
            }
          }
        };
        view.addEventListener("input", handler);
        return { view, handler };
      });

      invalidation.then(() => {
        handlers.forEach(({ view, handler }) =>
          view.removeEventListener("input", handler)
        );
      });

      return result;
    }
  </script>
</notebook>
