<!doctype html>
<notebook theme="air">
  <title>Self Folding Kirigami: The Castle Wall Constructs</title>
  <script id="114" type="application/vnd.observable.javascript">
    md`# Self Folding Kirigami: The Castle Wall Constructs

    Wouldn't it be nice if the paper folded itself? A demo of how to automate UI controls with [@tomlarkworthy/animation](https://observablehq.com/@tomlarkworthy/animation)

    `
  </script>
  <script id="1179" type="application/vnd.observable.javascript">
    viewof animator = {
      function objMap(obj, func) {
        return Object.fromEntries(
          Object.entries(obj).map(([k, v]) => [k, func(v, k)])
        );
      }
      return player({
        state: "playing",
        animation: viewof folds,
        writeFn: newVal => {
          const val = objMap(newVal, (v, k) =>
            k !== "n" ? v * 360 - 180 : Math.floor(v * 10)
          );
          viewof controls.value = val;
          viewof controls.dispatchEvent(new CustomEvent('input'));
        },
        invalidationPromise: invalidation
      });
    }
  </script>
  <script id="519" type="application/vnd.observable.javascript">
    view = {
      return new Promise(resolve => {
        let eye = new ln.Vector(9, 2, 40);

        let center = new ln.Vector(eye.x, eye.y, 0);
        let up = new ln.Vector(0, 1, 0);
        const height = 500;
        let paths = scene.render(
          eye,
          center,
          up,
          width,
          height,
          35,
          0.5,
          1000,
          0.3
        );

        resolve(html`
          ${ln.toSVG(paths, 610, 400)}
        `);
      });
    }
  </script>
  <script id="1171" type="application/vnd.observable.javascript">
    viewof folds = animation({
      tRange: [0, tEnd * 2],
      dims: dims,
      pixelsPerT: 50,
      keyFrames: {
        c0: [
          { t: 0, y: 0 },
          { t: 0.5, y: 0 },
          { t: tEnd * 2 - 0.5, y: 1 },
          { t: tEnd * 2, y: 1 }
        ],
        c1: [
          { t: 0, y: 0.5 },
          { t: tEnd * 0.5, y: 0.45 },
          { t: tEnd - 0.5, y: 0.5 },
          { t: tEnd + 0.5, y: 0.5 },
          { t: tEnd * 1.5, y: 0.7 },
          { t: tEnd * 2, y: 0.5 }
        ],
        x0: step(0.75, 0.75),
        x1: step(1, 0),
        x2: step(1.5, 0.75),
        x3: step(4.5, 1), //cred
        x4: step(2.5, 0.75),
        x5: step(3, 0),
        x6: step(3.5, 0.25),
        x7: step(3.5, 0.75),
        x8: step(4, 0.75),
        n: [
          { t: 0, y: 0.2 },
          { t: 4, y: 0.2 },
          { t: tEnd, y: 0.6 },
          { t: tEnd - 4, y: 0.2 },
          { t: tEnd * 2, y: 0.2 }
        ]
      }
    })
  </script>
  <script id="808" type="application/vnd.observable.javascript">
    viewof controls = verticalSliders({
      names: dims,
      labels: dims,
      mins:  Array(12).fill(-180),
      maxs:  Array(12).fill(180),
      steps: Array(12).fill(1)
    })
  </script>
  <script id="1242" type="application/vnd.observable.javascript">
    tEnd = 6
  </script>
  <script id="1248" type="application/vnd.observable.javascript">
    tDur = 0.5
  </script>
  <script id="1246" type="application/vnd.observable.javascript">
    step = (t, value, duration = tDur) => [
      { t: 0, y: 0.5 },
      { t: t - duration, y: 0.5 },
      { t: t, y: value },
      { t: 2 * tEnd - t, y: value },
      { t: 2 * tEnd - t + duration, y: 0.5 },
      { t: 2 * tEnd, y: 0.5 }
    ]
  </script>
  <script id="1216" type="application/vnd.observable.javascript">
    dims = ["c0", "c1", "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "n"]
  </script>
  <script id="296" type="application/vnd.observable.javascript">
    model = {
      const flipX = (shape) => ({
          frame: (controls) => ln.scale(new ln.Vector(-1, 1, 1)),
          folds: [shape()]
        })

      const repeat = (n, shape, next) => range(n).reduce(
        (acc, i) => shape(() => acc),
        next || (() => {})
      )

      const crenulation = (next) => ({
        frame: (u) => ln.rotate(new ln.Vector(0, 1, 0),-u.x3 * toRad)
                        .translate(new ln.Vector(0,1,0)),
        shape: squaredrectangle(1,1),
        folds: [{
          frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x3 * toRad)
                          .translate(new ln.Vector(0,1,0)),
          shape: squaredrectangle(1,1),
          folds: [next()]
        }]

      })
      const flatSide = () => ({ // inner
          frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x0 * toRad)
                              .translate(new ln.Vector(2,0,0)),
          shape: squaredrectangle(2,4),
          folds: [
            {
              frame: () => ln.translate(new ln.Vector(2,-1,0)),
              folds: [repeat(2, crenulation)]
            }, { // Tall outer wall
              frame: (u) => ln.translate(new ln.Vector(1,0,0))
                              .rotate(new ln.Vector(0, 1, 0), u.x1 * toRad)
                              .translate(new ln.Vector(3,0,0)),
              shape: squaredrectangle(5,4),
              folds: [{
                frame: () => ln.rotate(new ln.Vector(0,1,0), 180 * toRad).translate(new ln.Vector(0,-1,0)),
                folds: [repeat(2, crenulation)]
              },{ // Foot flap
                frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x2 * toRad)
                                    .translate(new ln.Vector(5,0,0)),
                shape: squaredrectangle(1,4)
              }]
            }
          ]
        })

      const indentSide = () => ({ // inner
          frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x4 * toRad)
                              .translate(new ln.Vector(2,0,0)),
          shape: squaredrectangle(2,4),
          folds: [{
              frame: () => ln.translate(new ln.Vector(2,-1,0)),
              folds: [repeat(2, crenulation)]
            }, { // Upper outer wall
              frame: (u) => ln.translate(new ln.Vector(1,0,0))
                              .rotate(new ln.Vector(0, 1, 0), u.x5 * toRad)
                              .translate(new ln.Vector(3,0,0)),
              shape: squaredrectangle(2,4),
              folds: [{
                  frame: () => ln.rotate(new ln.Vector(0,1,0), 180 * toRad).translate(new ln.Vector(0,-1,0)),
                  folds: [repeat(2, crenulation)]
                }, { // Underhang flap
                  frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x6 * toRad)
                                      .translate(new ln.Vector(2,0,0)),
                  shape: squaredrectangle(1,4),
                  folds: [{ // Indented lower wall
                    frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x7 * toRad)
                                        .translate(new ln.Vector(1,0,0)),
                    shape: squaredrectangle(3,4),
                    folds: [{ // Foot
                      frame: (u) => ln.rotate(new ln.Vector(0, 1, 0), u.x8 * toRad)
                                          .translate(new ln.Vector(3,0,0)),
                      shape: squaredrectangle(2,4)
                    }]
                  }
                ]
              }]
            }
          ]
        })
      const cellFlat = (next) => {
        let nextValue = undefined;
        if (next) nextValue = next();
        return ({
          // Walkway
          folds: [{
            frame: () => ln.translate(new ln.Vector(-2,0,0)),
            shape: squaredrectangle(4,4)
          },flatSide(), flipX(flatSide), {
            frame:() => ln.translate(new ln.Vector(0,4,0)),
            ...nextValue && {folds: [nextValue]}
          }]
        })
      }
      const cellIndent = (next) => {
        let nextValue = undefined;
        if (next) nextValue = next();
        return ({
          // Walkway
          folds: [{
            frame: () => ln.translate(new ln.Vector(-2,0,0)),
            shape: squaredrectangle(4,4)
          },indentSide(), flipX(indentSide), {
            frame:() => ln.translate(new ln.Vector(0,4,0)),
            ...nextValue && {folds: [nextValue]}
          }]
        })
      }

      return ({
        frame: (controls) => ln.rotate(new ln.Vector(1, 0, 0), (90) * toRad)
                      .rotate(new ln.Vector(0, 1, 0), (controls.c0) * toRad)
                      .rotate(new ln.Vector(1, 0, 0), (controls.c1 - 29) * toRad)
                      .translate(new ln.Vector(0,0,0)),
        folds: [repeat(
                  Math.ceil(Math.max(1, Math.abs(controls.n))
                ), (next) => cellFlat(() => cellIndent(next)))]
      })
    }
  </script>
  <script id="813" type="application/vnd.observable.javascript">
    html`<style>
          svg {
             background-image: linear-gradient(green, black); 
          }
          polyline {
            stroke: yellow;
            stroke-width: 1px;
          }
        input[type=range][orient=vertical]
        {
          writing-mode: bt-lr; /* IE */
          -webkit-appearance: slider-vertical; /* WebKit */
          width: 8px;
          height: 175px;
          padding: 0 5px;
        }
    </style>`
  </script>
  <script id="123" type="application/vnd.observable.javascript">
    scene = {
      // first thing is to create a scene
      const scene = new ln.Scene()

      function loadModel(scene, frame, model) {
        const f = model.frame ? frame.mul(model.frame(controls))
                              : frame;
        if(model.shape) scene.add(new ln.TransformedShape(model.shape, f));
        (model.folds || []).forEach(fold => {
          loadModel(scene, f, fold);
        })
      }

      loadModel(scene, ln.identity(), model);

      return scene;
    }
  </script>
  <script id="217" type="application/vnd.observable.javascript">
    squaredrectangle = (w, h) => {
      const thickness= 0.01;
      const min = new ln.Vector(0, 0, 0)
      const max = new ln.Vector(w, h, thickness)
      const cube = new ln.Cube(min, max)

      cube.insec

      // we can specify which paths to render and create new ones:
      cube.paths = function() {
        const paths = []
        const { x: x1, y: y1} = this.min
        const { x: x2, y: y2} = this.max
        for(let i = 0; i <= w; i++) {
          const x = x1 + (x2 - x1) * (i / w);
          paths.push([new ln.Vector(x, 0, thickness), new ln.Vector(x, h, thickness)])
          paths.push([new ln.Vector(x, 0, 0), new ln.Vector(x, h, 0)])
        }

        for(let j = 0; j <= h; j++) {
          const y = y1 + (y2 - y1) * (j / h);
          paths.push([new ln.Vector(0, y, thickness), new ln.Vector(w, y, thickness)])
          paths.push([new ln.Vector(0, y, 0), new ln.Vector(w, y, 0)])
        }
        return paths
      }
      return cube;
    }
  </script>
  <script id="647" type="application/vnd.observable.javascript">
    range = (n) => [...Array(n).keys()];
  </script>
  <script id="1196" type="application/vnd.observable.javascript">
    import {verticalSliders} from '@tomlarkworthy/vertical-sliders'
  </script>
  <script id="378" type="application/vnd.observable.javascript">
    toRad = Math.PI / 180
  </script>
  <script id="240" type="application/vnd.observable.javascript">
    import {slider} from "@jashkenas/inputs"
  </script>
  <script id="1163" type="application/vnd.observable.javascript">
    import {animation, player} from '@tomlarkworthy/animation'
  </script>
  <script id="147" type="application/vnd.observable.javascript">
    ln = import('https://unpkg.com/@lnjs/core@0.5.0/es/index.js?module')
  </script>
  <script id="1384" type="application/vnd.observable.javascript" pinned="">
    import { footer } from "@tomlarkworthy/footer"
  </script>
  <script id="1402" type="application/vnd.observable.javascript" pinned="">
    footer
  </script>
</notebook>
