function _1(md){return(
md`# Single Stroke Art Transformation

Transforming SVGs to single stokes suitable for machining`
)}

function _2(md){return(
md`## Original`
)}

function _dallE20240713220023ARealisticSingleLine(FileAttachment){return(
FileAttachment("DALL路E 2024-07-13 22.00.23 - A realistic single line drawing of a mint plant, detailed and capturing attention. The drawing should showcase the mint leaves- distinct shape and tex.webp").image()
)}

function _4(md){return(
md`Original art generated by ChatGPT, but then turned to SVG using https://svgconverter.app/, the SVG was tidied in Inkscape, and finally medial axised in this notebook`
)}

function _5(md){return(
md`## SVGed`
)}

function _source(svg,svg_plant){return(
svg`${svg_plant.replace(/<\?xml.*\?>/, "")}`
)}

function _svg_plant(FileAttachment){return(
FileAttachment("DALL路E 2024-07-13 22@3.svg").text()
)}

function _paths(source){return(
[...source.querySelectorAll("path")].map((d) => d.getAttribute("d"))
)}

function _transforms(paths,scaleAxisTransform){return(
paths.map((t) => scaleAxisTransform(t, { scale: 3 }))
)}

function _10(md){return(
md`## Medial Axis Transformed`
)}

function _art(svg,transforms){return(
svg`<svg
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    viewBox="0 0 1024 1024"
    stroke="black" stroke-width=1 >
  ${transforms.map((t) => svg`<path d="${t}" />`)}

`
)}

function _12(md){return(
md`## flow_mat (Medial/Scale Axis Transform)
### finds the skeleton of a shape`
)}

function _flo_mat(){return(
import("https://unpkg.com/flo-mat@3.0.1/browser/index.min.js")
)}

function _matsToPath(flo_mat)
{
  /**
   * Returns an SVG path string of a line.
   * @param ps The line endpoints.
   */
  function getLinePathStr(ps) {
    let [[x0, y0], [x1, y1]] = ps;
    return `M${x0} ${y0} L${x1} ${y1}`;
  }

  /**
   * Returns an SVG path string of a quadratic bezier curve.
   * @param ps The quadratic bezier control points.
   */
  function getQuadBezierPathStr(ps) {
    let [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`;
  }

  /**
   * Returns an SVG path string of a cubic bezier curve.
   * @param ps The cubic bezier control points.
   */
  function getCubicBezierPathStr(ps) {
    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`;
  }

  /**
   * Returns a function that draws an array of MAT curves on an SVG element.
   * @param mats An array of MATs to draw.
   * @param svg The SVG element on which to draw.
   * @param type The type of MAT to draw. This simply affects the class on the
   * path element.
   */
  function drawMats(mats) {
    const paths = [];
    mats.forEach(f);

    /**
     * Draws a MAT curve on an SVG element.
     */
    function f(mat) {
      let cpNode = mat.cpNode;

      if (!cpNode) {
        return;
      }

      let fs = [
        ,
        ,
        getLinePathStr,
        getQuadBezierPathStr,
        getCubicBezierPathStr
      ];

      flo_mat.traverseEdges(cpNode, function (cpNode) {
        if (flo_mat.isTerminating(cpNode)) {
          return;
        }
        let bezier = flo_mat.getCurveToNext(cpNode);
        if (!bezier) {
          return;
        }
        paths.push(fs[bezier.length](bezier));
      });
    }
    return paths.join();
  }

  return drawMats;
}


function _scaleAxisTransform(flo_mat,matsToPath){return(
(path, { scale = 1.5 } = {}) => {
  const paths = flo_mat.getPathsFromStr(path);
  const mats = flo_mat.findMats(paths);
  const sats = mats.map((mat) => flo_mat.toScaleAxis(mat, scale));
  return matsToPath(sats);
}
)}

export default function define(runtime, observer) {
  const main = runtime.module();
  function toString() { return this.url; }
  const fileAttachments = new Map([
    ["DALL路E 2024-07-13 22@3.svg", {url: new URL("./files/d1c8fc4aa10aaab45892cd82d0d15919b928b6554f0cca40992b82960096ae2767de3e5717174054b32ba862c38b81fdd3251c89b26a14323a47c995c177f1b3.svg", import.meta.url), mimeType: "image/svg+xml", toString}],
    ["DALL路E 2024-07-13 22.00.23 - A realistic single line drawing of a mint plant, detailed and capturing attention. The drawing should showcase the mint leaves- distinct shape and tex.webp", {url: new URL("./files/7678149e9926da11177671e4aa9c21fa8fc73e7df46593661d03c5ae77033e3e4091c4c7838dadc5648f07c7b387dbafc7e6a9d019a37893d37a89f0f802eb44.webp", import.meta.url), mimeType: "image/webp", toString}]
  ]);
  main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
  main.variable(observer()).define(["md"], _1);
  main.variable(observer()).define(["md"], _2);
  main.variable(observer("dallE20240713220023ARealisticSingleLine")).define("dallE20240713220023ARealisticSingleLine", ["FileAttachment"], _dallE20240713220023ARealisticSingleLine);
  main.variable(observer()).define(["md"], _4);
  main.variable(observer()).define(["md"], _5);
  main.variable(observer("source")).define("source", ["svg","svg_plant"], _source);
  main.variable(observer("svg_plant")).define("svg_plant", ["FileAttachment"], _svg_plant);
  main.variable(observer("paths")).define("paths", ["source"], _paths);
  main.variable(observer("transforms")).define("transforms", ["paths","scaleAxisTransform"], _transforms);
  main.variable(observer()).define(["md"], _10);
  main.variable(observer("art")).define("art", ["svg","transforms"], _art);
  main.variable(observer()).define(["md"], _12);
  main.variable(observer("flo_mat")).define("flo_mat", _flo_mat);
  main.variable(observer("matsToPath")).define("matsToPath", ["flo_mat"], _matsToPath);
  main.variable(observer("scaleAxisTransform")).define("scaleAxisTransform", ["flo_mat","matsToPath"], _scaleAxisTransform);
  return main;
}
